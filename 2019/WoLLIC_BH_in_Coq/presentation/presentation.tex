%20 min preso!
\documentclass[xcolor=table]{beamer}
\usepackage{beamerthemesplit}
\usepackage{wrapfig}
\usetheme{SPbGU}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{fancyvrb}
\usetikzlibrary{calc}
\usetikzlibrary{shapes,arrows}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{positioning}

\usepackage{minted}
\usepackage{verbments}

\usepackage{tabularx}
\newcolumntype{Y}{>{\raggedleft\arraybackslash}X}


\newtheorem{mytheorem}{Theorem}
\renewcommand{\thealgorithm}{}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture] \node (#1) {};}
\def\Put(#1,#2)#3{\leavevmode\makebox(0,0){\put(#1,#2){#3}}}

\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}

\beamertemplatenavigationsymbolsempty

\title[Bar-Hillel Theorem in Coq]{Bar-Hillel Theorem Mechanization in Coq}
%\subtitle[YaccConstructor]{Parsing techniques for graph analysis}
% То, что в квадратных скобках, отображается в левом нижнем углу.
\institute[JetBrains Research]{
JetBrains Research, Programming Languages and Tools Lab  \\
Saint Petersburg University
}

% То, что в квадратных скобках, отображается в левом нижнем углу.
\author[Semyon Grigorev]{Sergey Bozhko, Leyla Khatbullina, \textbf{Semyon Grigorev}}

\date{July 05, 2019}

\begin{document}
{
\begin{frame}[fragile]
  \begin{table}
  \centering
  \begin{tabularx}{\linewidth}{YcX}
    \includegraphics[height=1.5cm]{pictures/jetbrainsResearch.pdf} \hfill
    & \begin{minipage}[t]{0.3\textwidth}\center \vspace{-1cm}  WoLLIC 2019
      \end{minipage}
    & \hfill \includegraphics[height=1.5cm]{pictures/SPbGU_Logo.png}
  \end{tabularx}
  \end{table}
  \titlepage
\end{frame}
}

\begin{frame} \frametitle{Automated Theorem Proving}
  $$
  \underbrace{\texttt{CACATGGAGAGTTTGA\dots CTGGATCACCTCCTTT}}_{\sim 1500 \text{ symbols}}
  $$
  \begin{minipage}[t]{0.5\textwidth}
    \begin{itemize}
      \item Classification
      \pause
      \begin{itemize}
        \item Secondary structure handling
      \end{itemize}
      \pause
      \item Metagenomic assembly processing
      \begin{itemize}
        \item Filter out chimeric sequences
        \item Secondary structure handling
      \end{itemize}
    \end{itemize}
  \end{minipage}
~
  \begin{minipage}[t]{0.45\textwidth}
    %\onslide<2-3>\includegraphics[height=6cm]{pictures/16s.pdf}
  \end{minipage}

\end{frame}


\begin{frame} \frametitle{Formal Language Theory Mechanization}

\begin{itemize}
  \item Use parsing to extract features, not to model secondary structure
  \begin{itemize}
    \item As compared to the classical way of probabilistic CF grammars utilization
  \end{itemize}
  \pause
  \item Formal grammars as secondary structure description
  \item Parsing as features extraction
  \item Artificial neural network as probabilistic model for features processing
\end{itemize}

\end{frame}

\begin{frame} \frametitle{The Bar-Hillel Teorem}
\begin{theorem}[Bar-Hillel]
	If $L_1$ is a context-free language and $L_2$ is a regular language, then $L_1 \cap L_2$ is context-free.
\end{theorem}
\end{frame}

\begin{frame} \frametitle{Sketch of the Proof}
\begin{enumerate}
  \item We can assume that there is a contextfree grammar $G_{CNF}$ in Chomsky normal form, such that $L(G_{CNF}) = L_1$
  \pause
  \item We can assume that there is a set of regular languages $\{A_1 \ldots A_n\}$ where each $A_i$ is recognized by a DFA with precisely one final state and $L_2 = A_1 \cup \ldots \cup A_n$
  \pause
  \begin{itemize}
    \item If $ L \neq \varnothing $ and $L$ is regular then $L$ is the union of regular language $A_1, \ldots , A_n$ where each $A_i$ is accepted by a DFA with precisely one final state
  \end{itemize}
  \pause
  \item For each $A_i$ we can explicitly define a grammar of the intersection: $L(G_{CNF}) \cap A_i$
  \pause
  \item Finally, we join them together with the operation of the union
\end{enumerate}

\end{frame}

\begin{frame}[fragile] \frametitle{Hofmann's Results Generalization}

Jana Hofmann provides mechanization of the part of CFL in the Coq
\begin{itemize}
    \item Basic definitions: terminal, nonterminal, grammar, word, $\dots$
    \pause
    \item \textbf{Context-Free grammar to the Chomsky Normal Form convertion}
\end{itemize}
\pause

\begin{center}
  \begin{minipage}[t]{0.47\textwidth}
\begin{center}
    \begin{pyglist}[language=coq, numbers=none, numbersep=5pt]
    Inductive ter : Type :=
     | T : nat -> ter.
  	\end{pyglist}

    Yana Hofmann
  \end{center}
  \end{minipage}
  ~ \vline \vline ~
  \begin{minipage}[t]{0.47\textwidth}
\begin{center}
    \begin{pyglist}[language=coq, numbers=none, numbersep=5pt]
    Inductive ter : Type :=
     | T : Tt -> ter.
    \end{pyglist}

    We need an arbitrary type for terminals and nontermianls!
  \end{center}
  \end{minipage}

\pause
\vspace{0.5cm}
And now we should carefully rewrite all existing stuff \dots
\end{center}


\end{frame}


\begin{frame}[fragile] \frametitle{DFA Splitting}
\begin{pyglist}[language=coq, numbers=none, numbersep=5pt]
Lemma correct_split:
   forall dfa w,
     dfa_language dfa w <->
     exists sdfa,
        In sdfa (split_dfa dfa) /\ s_dfa_language sdfa w.
\end{pyglist}
\end{frame}

\begin{frame}[fragile] \frametitle{Chomsky Induction}

  \begin{lemma} \label{lemma:chomskyind1}
  Let $G$ be a grammar in CNF. Consider an arbitrary nonterminal $N \in G$ and phrase which consists only of terminals $w$.
  If $w$ is derivable from $N$ and $|w| \ge 2$, then there exists two nonterminals $N_1, N_2$ and two phrases $w_1, w_2$ such that: $N \to N_1 N_2 \in G$, $der(G, N_1, w_1)$, $der(G, N_2, w_2)$, $|w_1| \ge 1$, $|w_2| \ge 1$ and $w_1 ++ w_2 = w$.
  \pause
  \end{lemma}
\begin{center}
  \includegraphics[height=4.5cm]{pictures/ChomskyInductionIntuition.pdf}
\end{center}
\end{frame}

\begin{frame}[fragile] \frametitle{Chomsky Induction in Coq}

\begin{pyglist}[language=coq, numbers=none, numbersep=5pt]
Definition syntactic_analysis_is_possible :=
forall (G : grammar) (A : var) (w : phrase),
   der G A w -> (R A w \in G)
                \/
                (exists rhs, R A rhs \in G /\ derf G rhs w).

\end{pyglist}
\end{frame}

\begin{frame}[fragile] \frametitle{Languges Union}

  \begin{pyglist}[language=coq, numbers=none, numbersep=5pt]
  Variable grammars: seq (var * grammar).

  Theorem correct_union:
  forall word,
    language (grammar_union grammars) (V (start Vt))
             (to_phrase word)
    <->
    exists s_l,
      language (snd s_l) (fst s_l) (to_phrase word)
      /\
      In s_l grammars.
  \end{pyglist}

\end{frame}



\begin{frame}[fragile] \frametitle{The Final Theorem}

\begin{theorem}
    For any two decidable types $\textbf{Tt}$ and $\textbf{Nt}$ for types of terminals and nonterminals correspondingly. If there exists a bijection from $\textbf{Nt}$ to $\mathbb{N}$ and syntactic analysis is possible (in the sense of our definition), then for any DFA \textbf{\textit{dfa}} and any context-free grammar $\textbf{G}$, there exists the context-free grammar $G_{INT}$, such that $L(G_{INT}) = L(G) \cap L(\textit{dfa})$.
\end{theorem}

\end{frame}

\begin{frame}[fragile] \frametitle{The Final Theorem in Coq}

  %\begin{listing}[h]
      \begin{pyglist}[language=coq, numbers=none, numbersep=5pt]

  Theorem grammar_of_intersection_exists:
    exists
     (NewNonterminal: Type)
     (IntersectionGrammar: @grammar Terminal NewNonterminal)
     St,
    forall word,
      dfa_language dfa word /\ language G S (to_phrase word)
      <->
      language IntersectionGrammar St (to_phrase word).
     \end{pyglist}
  %\caption{Final theorem}
  %\label{lst:lang-eq}
  %\end{listing}

\end{frame}

\begin{frame} \frametitle{Conclusion}

\begin{itemize}
 \item We present mechanized in Coq proof of the Bar-Hillel theorem on the closure of context-free languages under intersection with the regular languages
 \item We generalize the results of Jana Hofmann and Gert Smolka
 \begin{itemize}
   \item The definition of the terminal and nonterminal alphabets in context-free grammar were made generic
   \item All related definitions and theorems were adjusted to work with the updated definition

 \end{itemize}

 \item All results are published at GitHub and are equipped with automatically generated documentation

\end{itemize}

\end{frame}

\begin{frame} \frametitle{Future work}

\begin{itemize}
 \item Ruy J. G. B. de Queiroz vs Jana Hifmann
 \begin{itemize}
   \item We use results of Jana Hofman
   \item Results of Ruy J. G. B. de Queiroz looks more mature
   \item Is it even possible to cretae one ``true'' solution in this area?
 \end{itemize}
 \pause
 \item Mechanization of practical algorithms which are just implementation of the Bar-Hillel theorem
 \begin{itemize}
   \item Context-free path querying algorithm, based on CYK or even on GLL parsing algorithm
   \item Certified algorithm for context-free constrained path querying for graph databases
 \end{itemize}
\end{itemize}

\end{frame}



\begin{frame}
\frametitle{Contact Information}
\begin{itemize}
  \item Semyon Grigorev:
    \begin{itemize}
      \item \href{mailto:s.v.grigoriev@spbu.ru}{s.v.grigoriev@spbu.ru}
      \item \href{mailto:Semen.Grigorev@jetbrains.com}{Semen.Grigorev@jetbrains.com}
    \end{itemize}
  \item Sergey Bozhko:
  \begin{itemize}
    \item  Max Planck Institute for Software Systems (MPI-SWS), Saarbrcken, Germany
    \item  \href{mailto:sbozhko@mpi-sws.com}{sbozhko@mpi-sws.com}
  \end{itemize}
    \item Leyla Khatbullina:
  \begin{itemize}
    \item St.Petersburg Electrotechnical University ``LETI'', St.Petersburg, Russia
    \item  \href{mailto:leila.xr@gmail.com}{leila.xr@gmail.com}
  \end{itemize}
  \item Sources: \href{https://github.com/YaccConstructor/YC_in_Coq}{https://github.com/YaccConstructor/YC\_in\_Coq}
\end{itemize}
\vspace{0.5cm}
\center{\huge{Thanks!}}
\end{frame}
\end{document}
