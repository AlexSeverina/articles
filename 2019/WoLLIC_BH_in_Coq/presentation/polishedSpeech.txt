1. 

Hello. My name is Semyon. 
I am here to present our results in mechanization of the formal language theory. 

2. 

There is quite a few systems which automate theorem proving. 
They are generally used in two scenarios. 
The first one is to ensure the correctness of nontrivial proofs. 
Theorem proving automation is really valuable now, when most proofs are just too big and complex. 
Without automation, it is really hard to guarantee, that a proof is indeed correct, and nobody, who was involved in the development of it, had made any mistakes. 

One other thing proof automation is capable of is facilitation of  development of correct-by-construction algorithms. 
This way, one can prove that their algorithm works as intended, extract it into their favorite executable programming language and be sure that there won't be any surprises when the program actually runs. 

We are most interested in the second application. 

We employ the Coq proof assistant to do the job. 
It is a well known system, based on the calculus of inductive constuctions. 
It provides the ability to extract executable code from a proof. 

3.

Our area of research is formal language theory. 
Of course, there are works which check nontrivial proofs. 
At the same time, results from this area are widely used in applications such as programming languages analysis, database querying and search engines. 
Some of these applications are better be secure, so there is a reason to develop certified algorithms for parsing, regular expressions manipulation and so on. 

4. 

In our work we focus on the Bar-Hillel theorem. 
This theorem states that context-free languages are closed under the intersection with regular languages. 
We prove this therem in Coq. 

But why this particular theorem? 

5. 

The answer is simple: "Because this theorem is important for applications". 
One such application is context-free path querying.
Context-free path querying is a way to search for paths in labeled graphs. 

Let me illustrate it with an example. 

Consider an edge-labeled graph. 
We want to find such paths in the graph which from a well-balanced sequence over the alphabet of two symbols: A and B. 
In other words, we want to find paths which in turn form words of a Dyck language. 

To do it, we can specify a grammar for Dyck language over A and B and use it as a filter for edges.
In our case the answer to the question is an infinite set of paths which meet the condition. 

6. 

From the formal standpoint, we have a context-free grammar which serves as a filter (or query). 
We also have a directed edge-labeled graph, which labels are a subset of the terminals of the grammar. 

Each path in the graph forms a word. 
The function omega is a helper which converts the path into a word. 























































