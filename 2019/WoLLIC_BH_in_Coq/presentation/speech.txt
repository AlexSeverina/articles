1

Hello. My name is Semyon. I want to present our results on a mechanization of a part of the formal language theory.

2

There is a number of systems for theorem prooving automatization.
Generally they can be used in two ways.
The first one is to use such systems for checking correctness of nontrivial proofs.

And the second one is to create certified or correct-by-construction algorithms.

In our work we are interested in the second one.

One of classical systems which provide such ability is a Coq proof assistant.
This proof assistant is based on calculus of inductive constructions and provide ability to extract exicutable code from the proof.

3

The area of our research is a formal language theory. The goals of proof assistants utilization here is, first off all, to check nontrivial proofs.

Within it, results from this area widely used in applications.
For example, in programming languages analysis, database querying, search engines and so on.
And for some of these application it is important to guarantee correctess of used algorithms. For example, for security reasons.

So, there is amount of work which is aimed to provide sertified algorithms for parsing, regular expressions manipulation and so on. 

4

Our work is about Bar-Hillel theorem mechanization.
This theorem says that context-free languages are closed under intersection with regular languages.
And we prove this fact in Coq.

What the reason to do it?
Of course, it is a mechanization of yet another part of the formal language theory and it may be important itself.
But why this theorem? Why not something else?

5

The answer is "Because this theorem is very important for applications".

One of applications of this theorem is context-free path querying.
Context-Free path querying is a way to find paths in edge-labelled graphs.

Suppose we have a graph.

And for some reasons we want to find such paths in this graph that each of them forms a well-balanced sequence over A and B.

In the other words, we want to find paths which form words in Dyck language.

To do it, we can specify a grammar for Dyck language over A and B and use it as a filter for edges.
And the answer in our case is a infinite set of paths which satisfied our condition.

This is a one of possible formulation of CFPQ.

6

Formally, we have a context-free grammar, we use it as a filter, or query.
And we have a directed edge-labelled graph, where labels are subset of of treminals.
Each path in such graph forms a word, and we introduce a helper function omega which converts the path to the word.
Now, having all necessary definitions, we can provide some possible formal definitions of context-free path querying.

The first one is to find all pairs of vertices, such that there exists a path between them which forms a word in the given language.
It is a reachability problem

Another possible formulation is to find all possible paths which form words in the given language.

There are many other variants of this task. For example, it may be necessary to check existence of the paths in graph, or it may be necessary to find paths between two specified vertices.

7

So, we have a context-free language.
Also we have a regular language: we just should equip the given graph with start and final states.
Note that in the most general case, all vertices are start states and all vertices are final states.

So, our goal is to find intersection of the context-free language and the regular one and to analyze it.

And Bar-Hillel theorem says that our problems are desidable. As far as the result of intersection is a context-free language and emptyness of a context-free language is decidable, path existance problem is desidabe.

More over, the constructive prove of this theorem shows how to construct a representation of paths, and how to get pairs of vertices, and so on.

8

Context-free path querying is used for graph analysis in different areas.

For example, in graph database querying, where it was introduced by Yannakakis, and actively developed now.

Or for static code analysis, where it was introduced by Tomas Reps.

So, the Bar-Hillel theorem is important for applications and we hope that mechanization of it is a firs step for creation of certified algorithms for static code analysis and database querying.

9

In our work we use slightly nonclassical way to prove this theorem.
We use grammar-based proof instead of classical PDA-based one.
This way is not new, but seems to be less known.

So, our way contains the following steps.

Firs of all, we assume, that every context-free language can be described by a grammar in the Chomsky Normal Form.

The next, we there is a set of regular languages, such that each language can be recognized by deterministic finite automata with one final state. And union of these languages is L_2.
Namely, here we use the next lemma: if L is nonempty regular langugae, then L is a union of regular languages, such that each language is recognizable by deterministic finite automata with single final state.

After that, we can construct grammar of intersection of each regular language from the set and the grammar of the given language in CNF.

Finally, we should construct an intersection of grammars created at the previous step.

10

Of course, we plan to reuse existing results in formal languages mechanization in Coq.
As we can see, we need both context-free languages and regualr languages, and automata mechanization.

Initially, it was the reason to use Hofmann and Smolka results: they provide mechanization of parts of contex-free and regular languages. But finally we use only the context-free part.

So, Jana Hofmann provides a set of basic definitions, such as language, grammar and so on, and, what is important tor our work, convertion of context-free grammar to CNF.

But, to be reused in our work, Hofmann's results should be improved.
Changes are required in basic definitions: in the definition of terminal symbol and in the definition of nonterminal symbol.

Initially both of them were a natural numbers. And this fact actively uses in other proves.

But in our case we need to be able to use arbitrary type as a terminal and nonterminal.
It is necessary to construct triples of automata states and terminals and nonterminals of the original grammar.

So, we generalize terminal and nonterminal types.

And after that we had carefully refactor everything.

And after that we get proof for the first part: any context-free language can be described by grammar in the Chomsky normal form.

11

The next step is a DFA splitting.
Here we want to represent the given reglar language as a set of languages which is acceptable by DFA with single final state.

To do it we proof the next lemma. Namely, we want to proof that our procedure split_dfa creates a correct splitting.
Note, that the fact that all DFAs in the splitting result contains precisely one final state is encoded at the type level. DFAs in the set have a special type which says that there is only one final state.

12

Next steps require to introduce Chomsky induction. We want to have structural induction which is based on the word derivation steps.

Namely, if the given word w is derivable from nonterminal N then, first of all, there exists a rule for N which contains N1 and N2 at the right part. More over, there exist subwords w1 and w2 such that w is a concatination of w1 and w2 and w1 is derivable from N1 and w2 is derivable form N2.

13

We formalize this inductive construction as the next definition.
Note that in the original definition the grammar is a list of productions, without specification of start nonterminal, so we should to specify start nontermonal separately.

This cnstruction allows us to explicetely construct grammars for intersection of the grammar in CNF and automata from splitting result.

14

And the final step is to build a union of these grammars and to prove that our procedure grammar_union which do it is correct. Namely, we prove that grammar_union preserve s the language.
It means that result of union contains the word if and only if there exists the grammar in the initial set, such that the correspondend language contains the same word.

15

And now we a ready to formulate the final theorem.

It says that for every desidabe type for noterminals and terminals, if there exists byjection between natural numbers and type for nonterminals, and static analysis in terms of our definition is possible ,then
For any DFA and context-free grammar there exisits acontext-free grammar which specifies the language which is the intersection of the languages which are specified by the given grammar and the given DFA.

16

This theorem in terms on Coq.

First of all, we request a type for new nonterminals, which should be a triples.
Then we say that there exists a new grammar over original terminals and new nonterminals, and new start nontermianl,
such that the language which is specified by this grammar with given start nonterminal is exactly the same as the intersection of languages which specified by the given DFA and the given grammar.

17

To summarize. We present mechanization in Coq proof of the fact that context-free languages is closed under intersection with regular languages.

Also we generalize results of Jana Hofmann. So, we hope that now it should be esear to use them for other researches.

And, of course, we publish all code on GitHub. Coq code is equipped with autmatically generated documentation to simplify navigation throu the code and its investigation.

18

The first question for future research is a intergration with other results on formal langiage theory mechanization.
In the current work we use results of Jana Hofmann. But there is, for example, a great stuff which is created by Markus Romas. And his results seem more mature. Should we rebase our solution on this stuff? It is not evident. Because it is not evident that we can create one general solution for all. For example, one can have a case when PDA-based prove more appropriate than our grammar-based one. But, may be, we should create one extensible platform for formal languge theory mechanization. So, I think that it is a question for discussion.

In any case, our results is a first step for sertification of algorithms which are based on the Bar-Hillel theorem.
It may be requred, for example, for security reaons in database engines. And it is a direction for future work.

19

Thank you for attention. I'm ready to answer your questions.
