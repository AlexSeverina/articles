1

Hello. My name is Semyon. I want to present our results on the mechanization of a part of the formal language theory.

2

There is a number of systems for theorem prooving automatization.
Generally, they can be used in two ways.
The first one is to use such systems for checking the correctness of nontrivial proofs.

And the second one is to create certified or correct-by-construction algorithms.

In our work we are interested in the second one.

One of the classical systems which provide such ability is a Coq proof assistant.
This proof assistant is based on the calculus of inductive constructions and provides the ability to extract executable code from the proof.

3

The area of our research is a formal language theory. The goal of proof assistants utilization here is, first of all, to check nontrivial proofs.

At the same time, results from this area widely used in applications.
For example, in programming languages analysis, database querying, search engines and so on.
And for some of these applications, it is important to guarantee the correctness of used algorithms. For example, for security reasons.

So, there is a big amount of work which is aimed to provide certified algorithms for parsing, regular expressions manipulation and so on.

4

Our work is about Bar-Hillel theorem mechanization.
This theorem says that context-free languages are closed under intersection with regular languages.
And we prove this fact in Coq.

What the reason to do it?
Of course, it is mechanization of yet another part of the formal language theory and it may be important itself.
But why this theorem? Why not something else?

5

The answer is "Because this theorem is very important for applications".

One of the applications of this theorem is context-free path querying.
Context-Free path querying is a way to find paths in edge-labeled graphs.

Suppose we have a graph.

And for some reasons, we want to find such paths in this graph that each of them forms a well-balanced sequence over A and B.

In other words, we want to find paths which form words in Dyck language.

To do it, we can specify a grammar for Dyck language over A and B and use it as a filter for edges.
And the answer in our case is an infinite set of paths which satisfied our condition.

This is one of possible formulation of CFPQ.

6

Formally, we have a context-free grammar, we use it as a filter or query.
And we have a directed edge-labeled graph, where labels are a subset of terminals.
Each path in such graph forms a word, and we introduce a helper function omega which converts the path to the word.
Now, having all the necessary definitions, we can provide some possible formal definitions of context-free path querying.

The first one is to find all pairs of vertices, such that there exists a path between them which forms a word in the given language.
It is a reachability problem.

Another possible formulation is to find all possible paths which form words in the given language.

There are many other variants of this task. For example, it may be necessary to check the existence of the paths in the graph, or it may be necessary to find paths between two specified vertices.

7

So, we have a context-free language.
Also, we have a regular language: we just should equip the given graph with start and final states.
Note that in the most general case, all vertices are both start states and final states.

So, our goal is to find the intersection of the context-free language and the regular one and to analyze it.

And Bar-Hillel theorem says that our problems are decidable. As far as the result of intersection is a context-free language and emptiness of a context-free language is decidable, path existence problem is decidable.

Moreover, the constructive proof of this theorem shows how to construct a representation of paths, and how to get pairs of vertices, and so on.

8

Context-free path querying is used for graph analysis in different areas.

For example, in graph database querying, where it was introduced by Yannakakis, and actively developed now.

Or for static code analysis, where it was introduced by Tomas Reps.

So, the Bar-Hillel theorem is important for applications and we hope that mechanization of it is a first step for the creation of certified algorithms for static code analysis and database querying.

9

In our work we use slightly nonclassical way to prove this theorem.
We use grammar-based proof instead of classical PDA-based one.
This way is not new but seems to be less known.

So, our way contains the following steps.

First of all, we assume, that every context-free language can be described by a grammar in the Chomsky Normal Form.

The next, there is a set of regular languages, such that each language can be recognized by a deterministic finite automaton with one final state. And the union of these languages is L_2.
Namely, here we use the next lemma: if L is nonempty regular language, then L is a union of regular languages, such that each language is recognizable by a deterministic finite automaton with the single final state.

After that, we can construct a grammar of intersection of each regular language from the set and the grammar of the given language in CNF.

Finally, we should construct an intersection of grammars created at the previous step.

10

Of course, we plan to reuse existing results in formal languages mechanization in Coq.
As we can see, we need both context-free languages and regular languages, and automata mechanization.

Initially, it was the reason to use Hofmann and Smolka results: they provide mechanization of parts of context-free and regular languages. But finally, we use only the context-free part.

So, Jana Hofmann provides a set of basic definitions, such as language, grammar and so on, and, what is important tor our work, conversion of context-free grammar to CNF.

But, to be reused in our work, Hofmann's results should be improved.
Changes are required in basic definitions: in the definition of terminal symbol and in the definition of the nonterminal symbol.

Initially, both of them were natural numbers. And this fact actively uses in other proves.

But in our case, we need to be able to use arbitrary type as a terminal and nonterminal.
It is necessary to construct triples of automaton states and terminals and nonterminals of the original grammar.

So, we generalize terminal and nonterminal types.

And after that, we had carefully refactored everything.

Finally, we get proof for the first part: any context-free language can be described by grammar in the Chomsky normal form.

11

The next step is a DFA splitting.
Here we want to represent the given regular language as a set of languages which is acceptable by DFA with a single final state.

To do it we proof the next lemma. Namely, we want to prove that our procedure split_dfa creates a correct splitting.
Note, that the fact that all DFAs in the splitting result contains precisely one final state is encoded at the type level. DFAs in the set has a special type which says that there is only one final state.

12

Next steps require to introduce Chomsky induction. We want to have structural induction which is based on the word derivation steps.

Namely, if the given word w is derivable from nonterminal N then, first of all, there exists a rule for N which contains N1 and N2 at the right part. Moreover, there exist subwords w1 and w2 such that w is a concatenation of w1 and w2 and w1 is derivable from N1 and w2 is derivable form N2.

13

We formalize this inductive construction as the next definition.
Note that in the original definition the grammar is a list of productions, without specification of start nonterminal, so we should specify start nonterminal separately.

This construction allows us to explicitly construct grammars for the intersection of the grammar in CNF and automata from splitting result.

14

And the final step is to build a union of these grammars and to prove that our procedure grammar_union which do it is correct. Namely, we prove that grammar_union preserve s the language.
It means that the result of union contains the word if and only if there exists the grammar in the initial set, such that the corresponding language contains the same word.

15

And now we a ready to formulate the final theorem.

It says that for every decidable type for nonterminals and terminals, if there exists bijection between natural numbers and type for nonterminals, and static analysis in terms of our definition is possible, then for any DFA and context-free grammar there exists a context-free grammar which specifies the language which is the intersection of the languages which are specified by the given grammar and the given DFA.

16

This theorem in terms of Coq.

First of all, we request a type for new nonterminals, which should be triples.
Then we say that there exists a new grammar over original terminals and new nonterminals and new start nonterminal,
such that the language which is specified by this grammar with given start nonterminal is exactly the same as the intersection of languages which specified by the given DFA and the given grammar.

17

To summarize. We present mechanization in Coq proof of the fact that context-free languages are closed under intersection with regular languages.

Also, we generalize results of Jana Hofmann. So, we hope that now it should be easier to use them for other researches.

And, of course, we publish all code on GitHub. Coq code is equipped with automatically generated documentation to simplify navigation through the code and its investigation.

18

The first question for future research is integration with other results on formal language theory mechanization.
In the current work we use results of Jana Hofmann. But there is, for example, great stuff which is created by Markus Romas. And his results seem more mature. Should we rebase our solution on this stuff? It is not evident. Because it is not evident that we can create one general solution for all. For example, one can have a case when PDA-based prove more appropriate than our grammar-based one. But, maybe, we should create one extensible platform for formal language theory mechanization. So, I think that it is a question for discussion.

In any case, our result is the first step for certification of algorithms which are based on the Bar-Hillel theorem.
It may be required, for example, for security reasons in database engines. And it is a direction for future work.

19

Thank you for attention. I'm ready to answer your questions.
