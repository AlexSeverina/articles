\documentclass[12pt]{article}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage[utf8x]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{cmap}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{hyperref}
\usepackage{pifont}
\usepackage{tikz}
\usepackage{verbatim}

\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning,automata}
\tikzset{
  every state/.style={minimum size=0.2cm},
  initial text={}
}

\newenvironment{myauto}[1][3]
{
  \begin{center}
    \begin{tikzpicture}[> = stealth,node distance=#1cm, on grid, very thick]
}
{
    \end{tikzpicture}
  \end{center}
}


\begin{document}
\begin{center} {\LARGE Формальные языки} \end{center}

\begin{center} \Large домашнее задание до 23:59 09.10 \end{center}
\bigskip

\begin{enumerate}
  \item Выписать отрицание к лемме о накачке. 
  \item Доказать нерегулярность языка:
  \[ \{ a^l b^m a^n \mid l = 0 \text{ или } m = n \} \]
  Будьте внимательны: необходимо рассмотреть несколько вариантов разбиений, при этом для разных вариантов надо выбирать разные значения константы накачки.
  \item Доказать или опровергнуть утверждение: произведение двух минимальных автоматов всегда дает минимальный автомат (рассмотреть случаи для пересечения, объединения и разности языков).
  \item Для регулярного выражения: 
   \[ (a \mid b)^+ (aa \mid bb \mid abab \mid baba)^* (a \mid b)^+\]
  Построить эквивалентные: 
  \begin{enumerate}
    \item Недетерминированный конечный автомат  
    \item Недетерминированный конечный автомат без $\varepsilon$-переходов
    \item Регулярную грамматику 
    \item Минимальный полный детерминированный конечный автомат 
  \end{enumerate}
  \item Выписать регулярное выражение для языка, порождаемого грамматикой: 
  \begin{align*}
    S &\to c T \mid a U \mid b U \\ 
    T &\to b S \mid a U \\ 
    U &\to a U \mid c T \mid \varepsilon 
  \end{align*}
  Для этого можно составить систему уравнений и применить лемму Ардена (по-английски \href{https://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions/2017#2017}{тут},  по-русски \href{https://coderlessons.com/tutorials/akademicheskii/izuchite-teoriiu-avtomatov/teorema-ardena}{тут}) 
\end{enumerate}


\begin{comment}
  \begin{enumerate}
    \item Построить полный ДКА, распознающий язык чисел, делящихся на 6: \[ \{ \omega \in \{ 0, 1,\dots, 9 \}^* \mid \omega \ \vdots \ 6 \} \]
    \item Построить регулярное выражение, распознающее тот же язык, что и следующий автомат: 
    
    \begin{myauto}
      \node[state]           (q_2)                {$q_2$};
      \node[state,initial]   (q_0) [left=of  q_2] {$q_0$};
      \node[state]           (q_1) [above=of q_2] {$q_1$};
      \node[state]           (q_3) [below=of q_2] {$q_3$};
      \node[state,accepting] (q_4) [right=of q_2] {$q_4$};
  
      \path[->] (q_0) edge [loop above] node [above] {$a, b, c$} () 
                      edge              node [above] {$a$}       (q_1)
                      edge              node [above] {$b$}       (q_2)
                      edge              node [above] {$c$}       (q_3)
                (q_1) edge [loop above] node [above] {$b, c$}    () 
                      edge              node [above] {$a$}       (q_4)
                (q_2) edge [loop above] node [above] {$a, c$}    () 
                      edge              node [above] {$b$}       (q_4)
                (q_3) edge [loop above] node [above] {$a, b$}    () 
                      edge              node [above] {$c$}       (q_4)
      ;
    \end{myauto} 
  
    \item Построить регулярную грамматику, распознающую язык: $\{ \omega \in \{ a, b\}^* \mid (|\omega|_a - |\omega|_b) \ \vdots \ 3 \}$
  \end{enume
  \begin{enumerate}
    \item Доказать или опровергнуть
  \end{enumerate}
  rate}
  
\end{comment}

\end{document}
