\documentclass{beamer}
\usepackage{beamerthemesplit}
\usepackage{wrapfig}
\usetheme{SPbGU}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{cmap} 
\usepackage[T2A]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{ stmaryrd }
\usepackage{fancyvrb}
\usepackage{qtree}
\usepackage{verbatim}
\usepackage{ulem}
\newtheorem{rutheorem}{Теорема}
\newtheorem{ruproof}{Доказательство}
\newtheorem{rudefinition}{Определение}
\newtheorem{rulemma}{Лемма}
\beamertemplatenavigationsymbolsempty

\setbeamertemplate{itemize item}[circle]
\setbeamertemplate{enumerate item}[circle]
\newcommand{\derives}[1][*]{\xRightarrow[]{#1}}

\def\To{\derives[]}
\def\iff{\Leftrightarrow}

\usetikzlibrary{shapes,arrows}
\usetikzlibrary{positioning,automata}
\tikzset{every state/.style={minimum size=0.2cm},
initial text={}
}

\graphicspath{
  {pics/}
}

\newcommand{\incimage}[2][0.8]{ 
  \begin{center}   
    \includegraphics[width=\textwidth, height=#1\textheight, keepaspectratio]{#2}
  \end{center}
  }

\title[]{Сходимость преобразователей программ в метрическом пространстве деревьев}
\subtitle[]{}
\institute[]{
Лаборатория языков инструментов JetBrains\\
}

\author[]{Екатерина Вербицкая}

\date{16 сентября 2019}

\definecolor{orange}{RGB}{179,36,31}

\begin{document}
{
  \begin{frame}
    \titlepage
  \end{frame}
}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Конкатенация трех списков}

  \incimage{appdef.png}

  \incimage{apptree0.png}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Прогонка: переменная на месте шаблона}

  \incimage{appdef.png}

  \incimage{apptree1.png}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Прогонка: шаблон инстанциирован}

    \incimage{apptree2.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Прогонка: конструктор на внешнем уровне}


    \incimage{apptree3.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Прогонка: конкатенация двух списков}


    \incimage{apptree4.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Остаточная программа}


    \incimage{appres.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Прогонка: одинаковые списки}


    \incimage{appsame0.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Разрастание третьего аргумента}


    \incimage{appsame1.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Обобщение}


    \incimage{applet0.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{После обобщения прогонка, как раньше}


    \incimage{applet1.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Язык}


    \incimage{lang.png}

\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Семантика языка}


    \incimage{normrules.png}

\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Операции суперкомпиляции}


    \incimage{supercompilation.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Обращение списка с аккумулирующим параметром}


    \incimage{revdef.png}

\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Предок вложен в лист}


    \incimage{revtree0.png}

\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Обощение вверх}


    \incimage{revtreegen0.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Правый нижний узел --- инстанс предка}


    \incimage{revtreegen1.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Обобщение вниз}


    \incimage{revtreegen2.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Результирующее дерево процессов}


    \incimage{revtreegen3.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Обращение списка со вспомогательной функицией}


    \incimage{revl.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Предок вложен в лист, нет общей структуры}


    \incimage{revltree0.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Обобщение: split}


    \incimage{revltree1.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Результирующее дерево процессов}


    \incimage{revltree2.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Псевдокод суперкомпилятора}


    \incimage{supercompilationcode.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Операции суперкомпиляции}


    \incimage{supercompilation.png}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Терминируемость суперкомпилятора}

Суперкомпилятор должен:

\begin{itemize}
  \item Завершить работу на любой входной программе
  \begin{itemize}
    \item Построить конечное дерево
  \end{itemize}
  \item Построить замкнутое дерево: все листья имеют следующий вид:
  \begin{itemize}
    \item Конструктор без аргументов $c()$
    \item Переменная $x$
    \item Переименование какого-то предка
  \end{itemize}
\end{itemize}   

\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Дерево}


  Дерево: $t : \mathbb{N}^*_1 \to E$

  \begin{itemize}
    \item Не пусто 
    \item Префиксно-замкнуто (предки всегда есть)
    \item Конечно ветвится
    \item Упорядочено (все левые братья есть)
  \end{itemize}


  \begin{itemize}
    \item Множество конечных деревьев: $T(E)$
    \item Множество деревьев (в том числе бесконечных): $T_{\infty}(E)$
  \end{itemize}
  

  

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Абстрактный преобразователь программ}
  \begin{itemize}
    \item АПП $M : T(E) \to T(E)$
    \item АПП $M$ терминируется на $t \in T(E)$, если $\exists i : M^i(t) = M^{i+1}(t)$
    \item АПП $M$ терминируется, если он терминируется на всех деревьях из одного узла
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Метрическое пространство деревьев}
  \begin{itemize}
    \item $d(t, t') = 0 \text{, если } t = t'$
    \item $d(t, t') = 2^{- min \{k \mid t[k] \neq t'[k] \}}$, где $t[k]$ --- корневое поддерево глубины не больше $k$
  \end{itemize}

$d$ --- метрика на деревьях:

  \begin{itemize}
    \item Симметрична
    \item Выполняется аксиома тождества
    \item Выполняется неравенство треугольника
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Сходяшиеся последовательности}

  \begin{itemize}
    \item Последовательность деревьев сходится к $t \iff \exists N : \forall n \geq N : t_n = t$

    \item Последовательность деревьев сходится к $t \iff \forall k : \exists N : \forall n \geq N: t_n[k] = t[k]$
    \item Последовательность деревьев называется последовательностью Коши $\iff \forall k : \exists N : \forall n \geq N: t_n[k] = t_{n+1}[k]$
  \end{itemize}

  \begin{itemize}
    \item АПП $M$ является АПП Коши, если для каждого дерева с одним узлом $t$ последовательность $t, M(t), M^2(t), \dots$ является последовательностью Коши
  \end{itemize}

\vfill 

  Метрическое пространство деревьев является полным: любая последовательность Коши имеет предел.
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Предикаты на деревьях}
Предикат на деревьях: $p : T_{\infty}(E) \to \{ 1, 0 \}$

\begin{itemize}
  \item Предикат  $p$ непрерывен $\iff$ для любой  сходящейся последовательности $t_0, t_1, \dots \in T_{\infty}(E)$ с бесконечным пределом $t$ последовательность $p(t_0), p(t_1), \dots$ сходится к $p(t)$
  \item АПП $M$ сохраняет (maintains) предикат $p$, если для любого дерева с одним узлом $t$ и любого  $i : p(M^i(t)) = 1$
  \item Предикат $p$ конечен, если $p(t) = 0$ для всех бесконечных деревьев
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{\sout{Главная теорема} Терминируемость АПП}

  Пусть АПП $M : T(E) \to T(E)$ сохраняет предикат $p: T_{\infty}(E) \to \{ 1, 0 \}$. Если 

  \begin{itemize}
    \item $M$ является АПП Коши и 
    \item $p$ конечен и непрерывен, 
  \end{itemize}

  тогда $M$ терминируется 

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Доказательство теоремы }
Пусть $t$ --- дерево из одного узла, рассмотрим последовательность $t_0, t_1, \dots$, где $t_i = M^i(t)$. По предположению она --- последовательность Коши. 

От противного: предполагаем, что последовательность не ограничена, тогда $|t_i| > k$. Значит, ее предел $\hat{t}$ бесконечен и $p(\hat{t}) = 0$. По непрывности $\exists N : \forall n \geq N : p(t_n) = 0$. Это противоречит сохранению предиката. Значит, последовательность ограничена: $\exists k, I: \forall i \geq I: |t_i| \leq k$

Последовательность Коши, следовательно $\exists J: \forall j \geq J: t_j[k] = t_{j+1}[k]$. Возьмем $N = max\{I, J\}$, тогда  $\forall n \geq N$: 

\begin{align*}
  t_n &= t_n[k]     &(|t_n| \leq k) \\ 
      &= t_{n+1}[k] &(t_n[k] = t_{n+1}[k]) \\ 
      &= t_{n+1}    &(|t_{n+1}| \leq k)
\end{align*}

То есть последовательность сходится, а $M$ терминируется
\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Послабления: слабое сохранение}

  АПП слабо сохраняет предикат, если $p(M^i(t)) = 0$ только для конечного числа $i$

\vfill

  В Главной теореме можно использовать слабое сохранение
\end{frame} 


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Терминируемость АПП суперкомпиляции}

\begin{itemize}
  \item АПП Коши: только конечное число обобщений
  \item Предикат: только конечное число шагов прогонки
\end{itemize}
\end{frame} 


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{ АПП Коши  }

  \begin{itemize}
    \item $(E, \leq)$ --- предпорядок, если он рефлексивен и транзитивен
    \item $(E, \leq)$ --- well-founded, если нет бесконечных строгоупорядоченных последовательностей $e_0 > e_1 > \dots$
    \item $(E, \leq)$ --- well-quasi-order, если в любой последовательности $e_0, e_1, \dots \exists i < j: e_i \leq e_j$ 

  \end{itemize} 

  \vfill 

  АПП является АПП Коши, если он либо добавляет потомков к листу, либо заменяет поддерево на новое, корень которого строго меньше листа. 

  \begin{itemize}
    \item $\gamma \in leaf(t) \ \& \ t(\gamma) = t'(\varepsilon)$
    \item $t(\gamma) > t'(\varepsilon)$
  \end{itemize}
\end{frame} 

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Непрерывность предиката}

  \begin{itemize}
    \item Предикат имеет конечный характер (finite character), если $p(t) = 1 \iff \forall k : p(t[k]) = 1$
    \item Предикат непрерывен, если он конечный и имеет конечный характер 
  \end{itemize}

\vfill
  
  Если $p$ конечный и непрерывный предикат, то предикат $q(t) = p(s_1) \wedge \dots \wedge p(s_n)$, где $\{ s_1 \dots s_n \}$ --- непосредственные потомки $t$, является конечным и непрерывным 
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Важность wqo и wfqo}
$(E, \leq)$ --- wqo, тогда предикат $p$ является конечным и непрерывным:

\begin{itemize}
  \item $p(t) = 0,$ если  $\exists \alpha, \alpha i \beta \in dom(t): t(\alpha) \leq t(\alpha i \beta)$
  \item $p(t) = 1,$ иначе
\end{itemize}

\vfill 

$(E, \leq)$ --- wfqo, тогда предикат $p$ является конечным и непрерывным:

\begin{itemize}
  \item $p(t) = 0,$ если  $\exists \alpha, \alpha i \in dom(t): t(\alpha) \ngtr t(\alpha i)$
  \item $p(t) = 1,$ иначе
\end{itemize}

\vfill 

Все узлы в деревьях можно разбить на классы и на каждом классе применять или wqo, или wfqo 

\vfill 

Можно игнорировать листья 

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{АПП в суперкомпиляции: АПП Коши}

  Используем теорему про добавление в листья или замену на нечто строго меньшее

  \vfill 

  Используем wfqo $e \succcurlyeq e' \iff e$ --- выражение $\wedge e'$ --- let-выражение 

  \vfill 

  Прогонка добавляет предок к листу, а любое из трех видов обобщения заменяет выражение некоторым let-выражением. 
\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Предикат в суперкомпиляции: конечность и непрерывность}

Рассматриваем предикат $q(t) = p(s_1) \wedge \dots p(s_n)$, где  $\{ s_1, \dots, s_n \}$ --- непосредственные потомки $t$

\begin{itemize}
  \item $p(t) = 0, if \ \exists \alpha, \alpha i \beta \in dom(t): t(\alpha), t(\alpha i \beta)$ --- нетривиальны\footnote{не тривиальны} $\wedge t(\alpha) \trianglelefteq t(\alpha i \beta )$
  \item $p(t) = 0, if \ \exists \alpha, \alpha i \in dom(t): t(\alpha), t(\alpha i)$ --- тривиальны\footnote{либо конструктор, либо let-выражение} $\wedge not (t(\alpha) \sqsupset t(\alpha i))$
  \item $p(t) = 1$ иначе 
\end{itemize}

\vfill 

$sub(let \ x_1 = e_1 \dots x_n = e_n \ in \ e) = e\{x_1 := e_1 \dots x_n := e_n \}$

\vfill 

$e \sqsupseteq e' \iff |sub(e)| > |sub(e')| \vee (|sub(e)| = |sub(e')| \wedge sub(e) = sub(e') \theta)$

\end{frame}

\end{document}
