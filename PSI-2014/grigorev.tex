% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
%\usepackage[T2A]{fontenc} 
%\usepackage[utf8]{inputenc}
%\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{verbatim}
%
\begin{document}

\sloppy
%
%\frontmatter          % for the preliminaries
%
%\pagestyle{headings}  % switches on printing of running heads
%\addtocmark{Hamiltonian Mechanics} % additional mark in the TOC
%
%
%\tableofcontents
%
%\mainmatter              % start of the contributions
%
\title{From Abstract Parsing to Abstract Translation}
%
%\titlerunning{Hamiltonian Mechanics}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Semyon Grigorev\inst{1} 
\and Iakov Kirilenko\inst{2}
}
%
%\authorrunning{Ivar Ekeland et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Semyon Grigorev
, Iakov Kirilenko
}


\institute{St. Petersburg State University \\
198504, Universitetsky prospekt 28, Peterhof, St. Petersburg, Russia. \\
\email{rsdpisuy@gmail.com}
\and
St. Petersburg State University \\
198504, Universitetsky prospekt 28, Peterhof, St. Petersburg, Russia. \\
\email{jake@math.spbu.ru}
}

\maketitle              % typeset the title of the contribution

\begin{abstract}
String-embedded language transformation is one of the problems which can be faced during 
database and information system migration. The conventional solution which
is provided by a number of tools is based on run-time translation. We present a static 
\emph{abstract translation} approach which orignates from the \emph{abstract parsing} 
technique~\cite{AbstrParsing} initially developed for syntax analysis of string-embedded 
languages. We present abstract translation algorithm and some optimization techniques, and
discuss the results of its evaluation on a real-world industrial application.

%There are two approaches to 
%solve this problem: static translation or translation at run time. Our research deals 
%with the first one since solution for embedded language static translation problem do 
%not still exists. There is an abstract parsing algorithm~\cite{} for parsing of 
%string-embedded language. Parsing is close problem and in this article we propose abstract 
%parsing algorithm modification for application to string-embedded language translation. 
%We describe modifications of the basic algorithm which allow to translate embedded languages. 
%An algorithm of parsing forest minimization is also presented. We discuss some issues of 
%real-world dynamic SQL queries static translation and provide possible solutions. Finally, 
%we present results of implemented algorithm evaluation.

\keywords{Embedded languages, two-staged languages, string-embedded languages, abstract 
parsing,  abstract translation, LALR, dynamic SQL}
\end{abstract}

\input{introduction}
\input{dags}

\section{Abstract translation}
\label{sec:AbstractTranslation}

To solve a problem of dynamic queries translation we should calculate new values for all variables used 
for queries construction. If we want to create static translator then result of translation should not 
require any changes after translation is finished. Basic idea is that we should try to apply classical 
translation techniques to each possible value of dynamic query. So we should build parsing forest and 
translate each of trees, and calculate new string values based on translation result.

Semantic equivalent constructions of source and target languages should have similar syntax in order to 
abstract translation could be applied. If this constraint is not satisfied then solution could not be
 reduced to new values calculation for existing variables. New variable creation may be required and 
this fact can significantly increase complexity of solution and corresponded analysis.

Also we suppose that input data structure for parser is direct acyclic graph (DAG) with one source and 
one sink vertices. Our experience of dynamic SQL translation for real information system shows that DAG 
is a good approximation of the dynamically constructed expressions set for practical use. We should replace 
all cycles with single repetition during approximation to get such graph. This way we can process all vertices 
in the topological order and avoid the problem with cycles processing previously discussed.

We propose to modify basic LALR-based algorithm of abstract parsing to solve the problem of abstract 
translation. The original parsing algorithm targeted to recognition, not translation, and it does not 
support semantics calculation. This fact allows to operate only with tokens type, not tokens values. 
It is possible to merge states like in GLR-algorithm\footnote{Generalized Left-to-right Rightmost 
derivation -- LR-based parsing algorithm for arbitrary (ambiguous) context-free grammars 
processing~\cite{Grune}.}. This way we can avoid problems with size of states set and parsing result.
 If we want to translate input expression to another language then we should keep all information 
about tokens values. 

One of the possible solution of translation is abstract parsing algorithm with mechanism of stack 
splitting for semantic calculation support. It disallow to merge states and we should create new 
copies of stack on each branch in input graph and get exponential memory usage in worst case. 
Note that there is a big number of dynamic expressions which require exponential resources to 
analyze in the real world information systems. 

For example parser states for vertex $V_3$ in picture~\ref{pic4} should be equal for 2 input edges
but if we want to calculate semantics, then we get two different states because identifiers has 
different values.

\begin{figure}
    \begin{center}
        \includegraphics[width=11cm,height=1.4cm]{graphs/states_example.eps}
        \caption{Graph with states possible to merge.}
        \label{pic4}
    \end{center}
\end{figure}

Queries which contains a huge number of branches is a big problem. The number of states is an 
exponential function of the Nnumber of branches because for each branch we should produce $n*k$ 
states where $n$ is a number of states in root of fork vertex and $k$ is a number of branches. 
One of the most frequent example of queries with big number of branches is \verb|select| query. 
Each of fields to select can be calculated with if-statement or case-statement. Example of such 
graph presented in picture~\ref{pic5}.

\begin{figure}
    \begin{center}
        \includegraphics[width=11cm,height=2cm]{graphs/big_res.eps}
        \caption{Graph which require an exponential resources for translation.}
        \label{pic5}
    \end{center}
\end{figure}

If we use only sequentially concatenated if-statements then the number of parsing trees is $2^n$ 
where $n$ is a number of if-statements (or number of branches). In the real-world systems we 
have faced the queries which contains more than 100 branches. Full forest calculation by naive 
adaptation of abstract parsing is impossible for such queries. The set of states to be processed
 minimization is an actual problem for real-world systems.

\subsection{Optimization of the abstract translation algorithm}
\label{sec:Optimizations}

We propose the following solution of forest size minimization problem. We have previously discussed 
that the result of translation is new values for all variables which were used for queries construction. 
It is sufficient to construct not the full forest but only the minimal set of trees such that after 
translation every variable gets new value.This way, we can process not all paths in the input graph 
but only minimal set which contains all edges. Note that we cannot calculate this set before parsing 
because we cannot be sure that every path produces syntax correct values. If some path contains 
error than the tree is not constructed and we lose information about variables. For example let
we try to process the graph presented in picture~\ref{pic6}.

\begin{figure}
    \begin{center}
        \includegraphics[width=11cm,height=2cm]{graphs/paths.eps}
        \caption{Graph for minimal paths set selection.}
        \label{pic6}
    \end{center}
\end{figure}

One possible set of paths which we can be calculated before syntax analysis is $\{(L_1; M_1); (L_2; M_2)\}$. 
But every path contains syntax errors and the result forest is empty instead of containing 2 trees. 
We should choose another set (for example $\{(L_1; M_2); (L_2; M_1)\}$) to get correct result. So, 
path calculation is iterative process. We should perform states filtering during syntax analysis 
for each vertex with multiple input edges. Let we describe steps of the process.

\begin{itemize}
    \item \textbf{Initial state.} Set of states for vertex is empty. 
    \item \textbf{Step.} For each step if the current vertex has multiple input edges then we should add new state to states set for current vertex if any of the next conditions is true.
    \begin{itemize}
        \item New state corresponds with path which contains edges which are not contained in any of paths corresponded with states in the currently processed set. 
        \item New state corresponds with parser state which is not presented in the currently processed set.
    \end{itemize}

\end{itemize}

Described algorithm pseudo code is presented below.
\begin{verbatim}
/*
V – list of input graph vertices in the topological order.
v_s – start vertex of input graph.
*/

let filterStates v =
    let groupedByParserState =
        v.States.GroupBy (fun state -> state.Item)

    v.States = Set.empty

    for group in groupedByParserState do
        /* Each state corresponds with path from v_s to v.
         Set of paths specify set of edges of graph E_s.
         We should construct minimal set of paths which
         contains all edges of E_s. The next greedy algorithm
         can be applied to solve this problem.
         1) Order paths by length ascent.
         2) While current path contains edges not in
         the result set add this path in the result set.*/
        let ordered = 
            group.OrderBy (fun s -> -1 * s.Path.Lenght)
        for s in ordered do
            if (s.Path contains edges which 
                not in any path from result set) 
            then v.States.Add s

for v in V do
    v.States <- … /*step of syntax analysis*/
    /*If input degree of the vertex v more 
      then 1 then try to filter states.*/
    if v.InEdges.Count > 1 then filterStates v

\end{verbatim}

This way we can get states set which contains all parser states from input set but is not greater 
than it. Corresponded paths contains all possible edges in processed subgraph. Described algorithm
of filtration allows to increase performance of parsing by decreasing a number of parsing trees.

\input{evaluation}
\input{conclusion}

%
% ---- Bibliography ----
%
\begin{thebibliography}{}
  
\bibitem{RelaxedLALR}
Ефимов А.А., Кириленко Я.А. Построение ослабленного LALR-транслятора на основе анализа грамматики на избыточность // Системное программирование. Т. 4, вып. 1, 2009. С. 79–103.  

\bibitem{mart}
Мартыненко Б.К. Языки и трансляции. Издательство Санкт-Петербургского университета, 2008. 257 с. 

\bibitem{TiunovaUIInt}
Мосиенко М.А., Тиунова А.Е. Интеграция программной логики с пользовательским интерфейсом при реинжиниринге приложений // Системное программирование. Т. 1, вып. 1, 2004. С. 199–224.

\bibitem{NetDbTransform}
Трошин С.Л. Преобразование сетевых баз данных в реляционные: задачи и подходы // Системное программирование. Т. 1, вып. 1. 2004. С. 282–310.

\bibitem{OpenSystemsDBMS}
Shapot M., Popov E. Database reengineeing // Open Systems.DBMS. Number 4. 2004.    

\bibitem{ALVOR1}
Annamaa A., Breslav A., Kabanov J. e.a. An interactive tool for analyzing embedded SQL queries. Programming Languages and Systems. LNCS, vol. 6461. Springer: Berlin; Heidelberg. 2010. P. 131–138.

\bibitem{ALVOR2}
Annamaa A., Breslav A., Vene V. Using abstract lexical analysis and parsing to detect errors in string-embedded DSL statements // Proceedings of the 22nd Nordic Workshop on Programming Theory. Marina Walden and Luigia Petre, editors. 2010. P. 20-22.

\bibitem{StringExpr}
Aske Simon Christensen, Mller A., Michael I. Schwartzbach. Precise analysis of string expressions // Proc. 10th International Static Analysis Symposium (SAS), Vol. 2694 of LNCS. Springer-Verlag: Berlin; Heidelberg, June, 2003. P. 1–18.

\bibitem{Grune}
Grune D., Ceriel J. H. Jacobs. Parsing techniques: a practical guide. Ellis Horwood, Upper Saddle River, NJ, USA, 1990. P. 322.

\bibitem{SAofStrVal}
Costantini G., Ferrara P., Cortesi F. Static analysis of string values // Proceedings of the 13th international conference on Formal methods and software engineering, ICFEM’11. Springer-Verlag: Berlin; Heidelberg, 2011. P. 505–521.

\bibitem{ISO}
ISO. ISO/IEC 9075:1992: Title: Information technology — Database languages — SQL. 1992. P. 668.

\bibitem{JSA}
Java String Analyzer. URL: \href{http://www.brics.dk/JSA/}{http://www.brics.dk/JSA/}

\bibitem{AbstrParsing}
Kyung-Goo Doh, Hyunha Kim, David A. Schmidt. Abstract parsing: Static analysis of dynamically generated string output using LR-parsing technology // Proceedings of the 16th International Symposium on Static Analysis, SAS’09. Springer-Verlag: Berlin; Heidelberg, 2009. P. 256–272.

\bibitem{PHPSA}
PHP String Analyzer. URL: \href{http://www.score.is.tsukuba.ac.jp/~minamide/phpsa/}{http://www.score.is.tsukuba.ac.jp/$\sim$minamide/phpsa/}

\bibitem{PLSQL}
PL/SQL Developer. URL: \href{http://www.allroundautomations.com/plsqldev.html}{http://www.allroundautomations.com/plsqldev.html}

\bibitem{SQLWays}
SQL Ways. URL: \href{http://www.ispirer.com/products}{http://www.ispirer.com/products}

\bibitem{SwissSQL}
SwissSQL. URL: \href{http://www.swissql.com/}{http://www.swissql.com/}

\bibitem{SAForInject}
Xiang Fu, Xin Lu, Peltsverger B. e.a. A static analysis framework for detecting SQL injection vulnerabilities // Proceedings of the 31st Annual International Computer Software and Applications Conference. Vol. 01, COMPSAC’07, Washington, DC, USA, IEEE Computer Society, 2007. P. 87–96.

\end{thebibliography}


%\clearpage
%\addtocmark[2]{Author Index} % additional numbered TOC entry
%\renewcommand{\indexname}{Author Index}
%\printindex
%\clearpage
%\addtocmark[2]{Subject Index} % additional numbered TOC entry
%\markboth{Subject Index}{Subject Index}
%\renewcommand{\indexname}{Subject Index}
%\input{subjidx.ind}
\end{document}
