\section{Реализация}
 
\input{solution_review.tex}


\subsection{Алгоритм анализа. Основные функции}

Рекурсивно-восходящий алгоритм позволяет с помощью набора взаимно-рекурсивных функций эмулировать поведение LR-автомата. Его можно рассматривать, как аналог рекурсивного спуска, но для LR грамматики. Действительно, стек автомата естественным образом заменяется на стек вызова функций, а вызовы функций заменяют переходы автомата.

При таком подходе возникает проблема с объёмом кода целевого инструмента. Связана она с тем, что количество функций, которые необходимо построить, сравнимо с размером таблицы переходов LR-автомата, которые на практике бывают очень большими.

Для решения этой проблемы можно воспользоваться подходом, предложенным в работе~\cite{RecursiveAscentParsing}. Основная идея предложенного подхода -- реализовать всего две взаимно-рекурсивные функции, но оперирующие при этом уже не одним состоянием, а множеством состояний. Важно, что при такой реализации можно получить недетерминированный анализ. При этом ветвление реализуется, как ветвление в одной из функций, а механизм для переиспользования результатов вычисления, слияние, можно реализовать, как запоминание результатов вычисления функций. Для этого можно воспользоваться такой конструкции функционального программирования, как замыкание. 

В основе этого алгоритма лежат две взаимно-рекурсивные функции $parse$ и $climb$, которые можно определить следующим образом:
\begin{itemize}
	\item parse  q i =$\{(A\stackrel{}{\rightarrow}a. , i) | A\stackrel{}{\rightarrow} a. \in q\}\bigcup$
  
  \hspace{1,9cm}       $\{(A\stackrel{}{\rightarrow}a.b , k) | i = xj ,(A\stackrel{}{\rightarrow}a.b, k) \in climb$ q x j$  \}
  \bigcup$
  
  \hspace{1,9cm}       $\{(A\stackrel{}{\rightarrow}a.b , k) | B\stackrel{}{\rightarrow}e , (A\stackrel{}{\rightarrow}a.b, k) \in climb$ q B j $\}$
  \item climb q X  i = $\{(A\stackrel{}{\rightarrow}a.Xb , k) | (A\stackrel{}{\rightarrow}aX.b, k)\in parse($goto q X$) i , a\neq e, A\stackrel{}{\rightarrow}a.Xb \in q\}\bigcup$
  
  \hspace{2,5cm}          $\{(A\stackrel{}{\rightarrow}a.b , l) | (C\stackrel{}{\rightarrow}X.c,j)\in parse($goto q X$) i, (A\stackrel{}{\rightarrow}a.b ,l)\in climb$ q C j$\} $
\end{itemize}

Где:
\begin{itemize}
  \item $G=(V_T,V_N,P,S)$: контекстно-свободная грамматика;
  \item $V = V_T \cup V_N$;  
  \item $x,y \in V_T$
  \item $i,j \in V_T^*$
  \item $X,Y \in V$
  \item $A,B,C \in V_N$
  \item $a,b,c \in V^*$ 
  \item $q$: LR-состояние (core) 
	\item $goto \ q \ X $ = $\{A\stackrel{}{\rightarrow}aX.b | A\rightarrow a.Xb \in $q*$\}, $
  \item \textit{q*}: замыкание. q* $= q \bigcup \{B\rightarrow.c | A \rightarrow a.Bb \in $q*$\} \bigcup \{x\stackrel{}{\rightarrow}.x | A\stackrel{}{\rightarrow} a.xb \in $q*$\}$~\cite{DrgBook}
\end{itemize}

Далее, на основе этого алгоритма надо получить алгоритм, реализующий:
\begin{enumerate}
 	\item непосредственную поддержку EBNF-грамматик;
 	\item построение леса вывода.
 \end{enumerate} 

Для того в него необходимо внести некоторые изменения, описанные далее.

\subsubsection{Поддержка расширенных контекстно-свободных грамматик}

Поддержка регулярных выражений в правых частях правил (EBNF-грамматики) получается естественным образом. Для этого правая часть правила представляется как детерминированный конечный автомат. LR-ситуация в таком случае может быть представлена парой: правило (нетерминал+КА) и номер состояния (соответствует позиции маркера в классическом определении).

Действительно, в правой части правила всегда находится регулярное выражение. В простом случае, когда это последовательность терминалов и нетерминалов, позиция маркера из классического определения LR-ситуации тривиальным образом соответствует состоянию конечного автомата, построенного по этой последовательности, а перемещение маркера -- переход КА из одного состояния в другое. В общем случае по  регулярному выражению из правой части правила по алгоритму Томпсона~\cite{DrgBook} строится недетерминированный конечный автомат (НКА). Заметим, что в полученном НКА много $\varepsilon$-переходов. Например, каждая альтернатива вносит два дополнительных состояния и 4 $\varepsilon$-перехода. Чтобы уменьшить количество переходов в результирующем LR-автомате можно преобразовать НКА в детерминированный конечный автомат(ДКА). Для этого применим стандартный алгоритм преобразования НКА в ДКА~\cite{DrgBook}. После этого заменим позицию маркера номером состояния полученного ДКА.
 
Таким образом, мы можем строить LR-ситуации для EBNF-грамматик. Для каждой, построенной LR-ситуации, для дальнейшей работы необходимо хранить следующую информацию:
\begin{itemize}
  \item номер правила;
  \item левую часть правила(нетерминал);
  \item номер текущего состояния ДКА;
  \item символ принимаемый ДКА в данном состоянии;
  \item номер состояния ДКА, в которое он перейдёт приняв данный символ;
  \item номер начального состояния ДКА;
  \item номера конечных состояний ДКА;
\end{itemize}

Функция $goto$ для работы с новыми LR-ситуациями основана на стандартном алгоритме вычисления GOTO при LR анализе~\cite{DrgBook}. Его необходимо лишь изменить таким образом, чтобы он мог работать с LR-ситуациями, определённого нами вида. 

\subsubsection{Построение леса вывода}

Для того, чтобы построить лес вывода, необходимо добавить в функции механизм конструирования очередного узла дерева и предусмотреть сохранение леса.

В функции $parse$ необходимо производить конструирование нового листа, в случае, когда происходит чтение очередного символа из входной цепочки.

В функции $climb$ необходимо конструировать новый внутренний узел из поддеревьев, в случае, когда нужно произвести свёртку по текущему правилу, и объединять множества поддеревьев, в случае, если работа с текущем правилом ещё не закончена (сместился маркер в правой части).

Введём следующие обозначения:
\begin{itemize}
  \item $A \rightarrow R$ -- правило грамматики, где $A$ -- нетерминал, $R$ -- ДКА, построенный по регулярному выражению; 
  \item $(A \rightarrow R,i)$ -- LR-ситуация, где $i$ -- состояние ДКА;
  \item $is-final \ R \ i$ -- функция , осуществляющая проверку, что $i$ -- конечное состояние $R$;
  \item $exists \ elem \ set $ -- функция, проверяющая наличие элемента $elem$ в множестве $set$;
  \item $(leaf:a)$, $(A->...)$ -- конструкции дерева разбора;
\end{itemize} 

Тогда сигнатуры функции будут иметь следующий вид:

$parse$ $ q $ $ \{ u | A \rightarrow a.b, u = vx, b \rightarrow v \} \rightarrow (A \rightarrow a.b) x \{узлы синтаксического дерева для b \})$

$climb$ $q$ $X$ $\{ u | A \rightarrow aX.b, u = vx, b \rightarrow v \} (tree $: синтаксическое дерево для X$) \rightarrow (A \rightarrow a.Xb) x \{узлы синтаксического дерева для Xb\}$

А сами функции будут выглядеть так:

\verb|parse q u =|

\ \ \ \ \ \  \verb|if exists (A| $\rightarrow$ \verb|R,i) q| \ $\&$ \ \verb|is-final(R,i)| 
  
\ \ \ \ \ \  \verb|then (A| $\rightarrow$ \verb|R,i;u;[])|

\ \ \ \ \ \  \verb|else|

\ \ \ \ \ \ \ \ \ \verb|if u=av| $\&$ \verb|exists ( A| $\rightarrow$ \verb| R,i) q* | $\&$ \verb| R(i,a)=j| 
     
\ \ \ \ \ \ \ \ \ \verb|then climb q a v (leaf:a)|
     
\ \ \ \ \ \  \verb|else|
     
\ \ \ \ \ \  \verb|if exists (A| $\rightarrow$ \verb|R,0) q*| \ $\&$ \ \verb|is-final(R,0)| 
        
        
\ \ \ \ \ \  \verb|then climb q A v (A| $\rightarrow$ \verb|[])|
        
\verb|climb q X u h = |

  \ \ \ \ \ \ \verb| let (A| $\rightarrow$ \verb|R,j;w;s) = parse (goto q* X) u in|
  
  \ \ \ \ \ \ \verb| if R(i,X)=j| \ $\&$ \ \verb|exists (A|$\rightarrow$ \verb| R,i) q| 
  
  \ \ \ \ \ \ \verb| then (A| $\rightarrow$ \verb| R,i;w;h::s)|
   
  \ \ \ \ \ \ \verb| else climb q A w (A| $\rightarrow$ \verb| h::s)|


\subsection{Вычисление атрибутов}

На практике для задания семантических действий применяются наследуемые (l-атрибутные грамматики) и вычислимые (s-атрибутные грамматики) атрибуты. В рамках данной работы была поставлена задача поддержать работу с s-атрибутными грамматиками.

Далее будут подробнее описаны особенности вычисления атрибутов при непосредственной поддержке EBNF-грамматик и алгоритм вычисления атрибутов.


\subsubsection{Задание семантических атрибутов в YARD}

Грамматика YARD-а~\cite{Diploma} позволяет определять атрибуты для любой части продукции, которая является последовательностью. На практике это означает, что атрибут может быть ассоциирован не только с правилом целиком, а с любой его частью, которая является последовательностью. Например:

\begin{verbatim}
  someRule : val1 = (a {action1} | b {action2}) 
             val2 = c  {someFunc val1 val2};
\end{verbatim}

Здесь альтернатива \verb| ( a |\verb|b )| возвращает некоторое значение (\verb|action1| или \verb|action2|), которое сохраняется в переменной \verb|val1|, значение нетерминала сохраняется в переменной \verb|val2|, и далее обе эти переменные передаются в качестве аргументов в пользовательскую функцию \verb|someFunc|.

Возможность таким способом задавать атрибуты вызывает сложности при интерпретации дерева вывода. Связаны они с тем, что для вычисления атрибутов становится недостаточно информации только о дереве вывода входного выражения. 

Рассмотрим эту проблему более подробно. Допустим, в грамматике есть правило:

\begin{verbatim}
  someRule : val1 = (a {action1})* val2 = c  {someFunc val1 val2};
\end{verbatim}

Узел дерева вывода, соответствующий правилу, приведённому выше, может выглядеть следующим образом:

\begin{centering}
  \begin{dot2tex}[dot,autosize]

  digraph string_of_child
  {
          a1[label = "a"];
          a2[label = "a"];
          a3[label = "a"];
          c[label = "c"];
          S[label = "someRule"]
            
          S -> a1;
          S -> a2;
          S -> a3;
          S -> c;                            
  }
  \end{dot2tex}

\end{centering} 

Для вычисления атрибутов в этом узле необходимо знать,  что первые три сына были порождены из замыкания, их необходимо объединить в список и уже его передать в функцию \verb|someFun| в качестве первого параметра.

В общем случае можно  рассматривать непосредственных сыновей узла как строку, принадлежащую языку, задаваемому регулярным выражением в правой части правила.  Тогда можно сказать, что для вычисления атрибутов нам необходимо дерево разбора этой строки.

Для нашего примера:

\begin{centering}
  \begin{dot2tex}[dot,autosize]

  digraph string_of_child
  {
            S[label = "someRule"]

            c[label = "c"]; 
            a1[label = "a"];
            a2[label = "a"];
            a3[label = "a"];           
              
            S -> c;                            
            S -> a1;
            S -> a2;
            S -> a3;

          subgraph cluster_STR
          {                                                
                  bgcolor = grey;
                  str[label = "1",texlbl = "$Str:$",shape = plaintext]
                  c
                  a1;
                  a2;
                  a3;
                  
          };
  }
  \end{dot2tex}
%\captionof{figure}{ntcn}
%	\label{fig:rr}

\end{centering}
 
Где $Str$ -- строка, принадлежащая языку, задаваемому регулярным выражением в правой части правила. Дерево разбора этой строки будет выглядеть так:

\begin{centering}
  \begin{dot2tex}[dot,autosize]

  digraph string_diriv_tree
  {

            Seq[label = "Seq"]
            Cls[label = "Cls"]
            a1[label = "a"];
            a2[label = "a"];
            a3[label = "a"];
            c[label = "c"];                        
                                   
            Seq -> Cls;            
            Seq -> c; 
            Cls -> a1;
            Cls -> a2; 
            Cls -> a3;                           

  }
  \end{dot2tex}
  %\captionof{figure}{ntcn}
  %	\label{fig:rr}

\end{centering}

Таким образом, для того, чтобы вычислять атрибуты, нам необходимо во время интерпретации дерева вывода входного выражения построить дерево разбора строки из сыновей узла, для которого непосредственно производятся вычисления. Для этого необходимо во время анализа поучить и сохранить информацию о выводе этой строки. 

Удобным механизмом для решения этой проблемы оказался конечный автомат с помеченными переходами (далее будем для простоты будем называть их LFA -- Labelled Finite Automaton). Общая схема решения такова: 
\begin{enumerate}
	\item строится недетерминированный конечный автомат с помеченными переходами (LNFA), в котором в качестве меток сохраняется информация о начале и завершении конструкций регулярного выражения, по которому строится этот LNFA;
  \item по LNFA строится детерминированный конечный автомат с помеченными переходами (LDFA);
  \item в процессе анализа собираются и сохраняются метки с совершённых переходов и на основе этой информации строится дерево разбора.
\end{enumerate}

Подробнее все эти шаги будут описаны далее.



\subsubsection{Построение LNFA по регулярному выражению}

Определим LNFA как шестёрку $(Q$, $\Sigma$, $L$, $T$, $q_0$, $F)$, состоящая из:
\begin{itemize}
	\item конечного множества состояний $Q$ 
	\item конечного множества входных символов $\Sigma$ 
	\item конечного множества меток $L$ 
	\item функции перехода $T: \; Q \times (\Sigma \cup{ \varepsilon })\rightarrow 2^{Q \times L}$
	\item начального состояния $q_0 \in Q$
	\item конечного множества финальных состояний $F \subseteq Q$ 
\end{itemize}

Таким образом переходы автомата снабжаются метками. При изображении автомата в виде графа переходам соответствуют рёбра. Будем записывать метки через знак "/" \; после символа, принимаемого автоматом при данном переходе. 

Пример LNFA:

\begin{dot2tex}[dot]
digraph G
{
        rankdir = LR
        F [shape = doublecircle]
        S -> F [  label="a/l"
                , texlbl = "$a/someLbl$" ]
}
\end{dot2tex}


Где $a$ -- принимаемый символ, $someLbl$ -- метка.

Чтобы решить задачу вычисления атрибутов необходимо знать, когда началось и когда закончилось распознавание той или иной конструкции регулярного выражения. Для этого определим  метки специального типа:
\begin{itemize}
	\item для обозначения начала и конца конструкции
		\begin{itemize}
			\item лист: $LeafS,$ $LeafE$;
			\item последовательность: $SeqS,$ $SeqE$;
			\item замыкание: $ClsS,$ $ClsE$;
			\item альтернатива: $Alt1S,$ $Alt1E,$ $Alt2S,$ $Alt2E$ - пара меток для каждой ветви;
		\end{itemize}
			\item $\omega$ -- "`пустая"' метка;
\end{itemize}

Метка для конкретного ребра будет состоять из типа метки и уникального идентификатора, который совпадает у меток начала и конца одной и той же конструкции. Таким образом, множество меток $L$ можно определить так:

\begin{eqnarray}
     \label{def:L}
	   &L = \left\{ \right. t*k\; | \; t \in \left\{ \right.  LeafS,\; LeafE,\; SeqS,\; SeqE,\; ClsS,\; ClsE, & \nonumber \\
	   & \qquad Alt1S,\; Alt1E,\; Alt2S,\; Alt2E,\; \omega \; \left. \right\},\; k \in N \left.\right\} &
\end{eqnarray}

Для построения LNFA по регулярному выражению необходимо модернизировать алгоритм Томпсона. Его необходимо дополнить механизмом расстановки меток.

Будем рассматривать алгоритм, который работает с деревом вывода регулярного выражения, которое мы можем получить из YARD-а. Это дерево может содержать следующие конструкции:
\begin{itemize}
  \item Leaf(a) -- лист дерева. Соответствует символу в регулярном выражении.
  \item Seq(lst) -- последовательность. lst -- список элементов последовательности.
  \item Alt(L,R) -- альтернатива.
  \item Cls(T) -- замыкание.
\end{itemize}

Определим ряд функций:
\begin{itemize}
  \item $\mathop{buildL\!N\!F\!A:} \; 'Tree \rightarrow {'L\!N\!F\!A}$ -- строит LNFA по дереву вывода регулярного выражения.

  \item $map: \; ('T \rightarrow {'U}) \rightarrow {'T}  \; list \rightarrow {'U} \; list$ -- применяет функцию, переданную в качестве первого аргумента, к каждому элементу списка, перданного вторым аргументом.

  \item $concat: \; 'L\!N\!F\!A \; list \rightarrow {'L\!N\!F\!A}$ -- конкатенирует автоматы из списка, добавляя $\varepsilon/\omega$-переходы.  
\end{itemize}

Так же предположим, что у нас есть функция для генерации уникального индекса $k$ для нумерации меток.

Модернизированный алгоритм будет выглядеть следующим образом:
  \begin{itemize}
    \item
      Лист : Leaf(a) \
      \begin{flushleft}
        \input{TNFACreateLeaf.tex}
      \end{flushleft}
    \item 
      Последовательность : Seq(lst) \
      \begin{flushleft}
        \input{TNFACreateSeq.tex}
      \end{flushleft}
    \item 
      Альтернатива : Alt(L,R) \
      \begin{flushleft}
        \input{TNFACreateAlt.tex}
      \end{flushleft}
    \item 
      Замыкание : Cls(T) \
      \begin{flushleft}
        \input{TNFACreateCls.tex}
      \end{flushleft}
  \end{itemize}

Таким образом, теперь мы можем по регулярному выражению построить LNFA с метками, соответствующими началу и концу каждой конструкции регулярного выражения.


\subsubsection{Построение LDFA по LNFA}

Для дальнейшего использования необходимо преобразовать недетерминированный автомат в детерминированный автомат. Для этого можно использовать стандартный алгоритм построения DFA по NFA~\cite{DrgBook}, расширенный для работы с метками.

Определим детерминированный конечный автомат с метками (LDFA), как как шестёрку $(Q$, $\Sigma$, $L'$, $T$, $q_0$, $F)$, состоящая из:
\begin{itemize}
	\item конечного множества состояний $Q$ 
	\item конечного множества входных символов $\Sigma$ 
	\item конечного множества меток $L$ 
	\item функции перехода $T: \; Q \times \Sigma \rightarrow Q \times L'$
	\item начального состояния $q_0 \in Q$
	\item конечного множества финальных состояний $F \subseteq Q$ 
\end{itemize}

В нашем случае $L' = 2^{(2^L)}$, где $L$ -- множество меток LNFA $\eqref{def:L}$ и подмножества $L$ являются упорядоченными.

Процесс построения детерминированного автомата с помеченными переходами можно разбить на 2 этапа:
\begin{enumerate}
	\item построение детерминированного автомата с помощью стандартного алгоритма;
	\item вычисление и расстановка новых меток.
\end{enumerate}

Рассмотрим второй этап более подробно. Сперва необходимо разбить состояния DFA, построенного на первом шаге, на два множества: $F$ -- множество конечных состояний и $I = Q/F$ -- остальные (не конечные) состояния. 

Для дальнейшей работы нам понадобится функция $calculateN\!ewLabel:\; {'\!state} \rightarrow '\!l$, где $'\!l \in L'$. Она будет по состоянию автомата вычислять метку перехода из этого состояния. Определим эту функцию следующим образом:
\\
$calculateN\!ewLabel \; state \; = $\\
$\phantom \qquad let \; e = \text{множество всех } \varepsilon\text{-цепочек, заканчивающихся в state} $ \\
$\phantom \qquad let \; l = map \ (fun \ eLine \rightarrow \text{ пройти по } eLine \text{ из начала в конец}$ \\
$\phantom \qquad \qquad \quad \text{ и собрать по порядку все метки}) \; e \\$
$\phantom \qquad l$\\
Основная функция для вычисления и расстановки новых меток: \\
$setN\!ewLabel = $\\
$ \phantom \qquad \text{Для каждого состояния } f \in F \text{ добавить новое "`висячее"' \ ребро с началом в } f$ \\
$ \phantom \qquad \text{и установить ему метку равную } (calculateN\!ewLabel \ f)$\\
$ \phantom \qquad \text{Для каждого состояния } i \in I \text{, для каждого ребра, выходящего из } i$ \\
$ \phantom \qquad \text{установить метку равную } (calculateN\!ewLabel \ i)$

Рассмотрим работу данного алгоритма на примере. Пусть дано правило грамматики: $S \rightarrow a|b$. Необходимо построить ДКА с помеченными переходами для этого правила. По регулярному выражению в правой части ,применив алгоритм, описанный выше, построим НКА. В результате мы получим следующий автомат:
 
\begin{centering}

  \begin{dot2tex}[dot]
  digraph G
  {
          1 [label = "1"]
          2 [label = "2"]
          3 [label = "3"]
          4 [label = "4"]
          5 [label = "9"]
          6 [label = "10", shape = doublecircle]
          15 [label = "5"]
          16 [label = "6"]
          17 [label = "7"]
          18 [label = "8"]


          5 -> 15[label = "1234567", texlbl = "$\varepsilon/(Alt1S,1)$"]
          5 -> 17[label = "1234567", texlbl = "$\varepsilon/(Alt2S,1)$"]
          15 -> 1[label = "1234567", texlbl = "$\varepsilon/(LeafS,1)$"]
          1 -> 2 [label = "123", texlbl = "$a/\omega$"]
          2 -> 16[label = "1234567", texlbl = "$\varepsilon/(LeafE,1)$"]
          17 -> 3[label = "1234567", texlbl = "$\varepsilon/(LeafS,2)$"]
          3 -> 4 [label = "123", texlbl = "$b/\omega$"]
          4 -> 18[label = "1234567", texlbl = "$\varepsilon/(LeafE,2)$"]
          16 -> 6[label = "1234567", texlbl = "$\varepsilon/(Alt1E,1)$"]
          18 -> 6[label = "1234567", texlbl = "$\varepsilon/(Alt2E,1)$"]
  }
  \end{dot2tex}

\end{centering}

Далее, по этому автомату строится ДКА. Для построения применяется стандартный алгоритм Томпсона. Метки на рёбрах можно опустить, они будут вычислены на следующем шаге. Результирующий автомат будет выглядеть следующим образом:

\begin{centering}

  \begin{dot2tex}[dot]
  digraph G 
  {
    1 
    2 [shape = doublecircle]
    3 [shape = doublecircle]
    1 -> 2[ label = "a"]
    1 -> 3[ label = "b"]
  }
  \end{dot2tex}

\end{centering}

После этого можно вычислить новые метки, способом описанным выше. Автомат изменится -- в нём появятся две "`висячие"' \ дуги -- для каждого из финальных состояний. Выглядеть результирующий автомат будет следующим образом: 

\begin{centering}

  \begin{dot2tex}[dot]
  digraph G 
  {
    1 
    2 [shape = doublecircle]
    3 [shape = doublecircle]
    4 [shape = none, label = ""]
    5 [shape = none, label = ""]
    1 -> 2[ label = "01234567901234", texlbl = "$a/[[(Alt1S,1); \ (LeafS,1)]]$"]
    1 -> 3[ label = "01234567901234", texlbl = "$b/[[(Alt2S,1); \ (LeafS,2)]]$"]
    2 -> 4[ label = "01234567901234", texlbl = "$\varepsilon/[[(LeafE,1); \ (Alt1E,1)]]$"]
    3 -> 5[ label = "01234567901234", texlbl = "$\varepsilon/[[(LeafE,2); \ (Alt2E,1)]]$"]
  }
  \end{dot2tex}

\end{centering}

Видно, что метками в полученном детерминированном автомате являются множества списков меток недетерминированного автомата. 

Теперь рассмотрим алгоритм, с помощью которого по построенному LDFA можно получить нужные нам данные о выводе входной строки.
\begin{enumerate}
   	\item $let \ L\!D\!F\!A = $ LDFA, построенный по регулярному выражению, как описано выше.
   	\item $let \ labelsList = []$ (*список для хранения меток, полученных в процессе работы автомата*)
    \item $let \ trace = []$ (*трасса работы автомата*)    
   	\item Запускаем $L\!D\!F\!A$ над входной строкой. При каждом переходе добавляем метку $l_i$ в начало $labelsList$.
   	\item (*После завершения работы $L\!D\!F\!A$ в $labelsList$ хранится инвертированная последовательность меток.*)
   	\item $if \ \text{строка принята}$
   	\item $then$ 
   	\item $\phantom \qquad$Просматриваем $labelsList$ из начала в конец.
   	\item $\phantom \qquad let \ l_i  = $ текущий элемент $labelsList$
   	\item $\phantom \qquad let \ l_{i+1}  = $ следующий элемент $labelsList$
    \item $\phantom \qquad$Добавляем в $trace \ (k \ | \ k \ \in \ l_i: \exists p \in l_{i+1}: \\ \text{первый} \text{ элемент из } p \text{  является закрывающим для последнего элемента из } k)$
   	\item $else$ 
   	\item $\phantom \qquad Error$
   	\item $reverse \ trace$
\end{enumerate}

Таким образом, мы построили детерминированный конечный автомат с помеченными переходами, с помощью которого можно получить необходимую для дальнейшей работы информацию о выводе входной строки.


\subsubsection{Генерация кода для семантических действий пользователя}

При задании грамматики пользователь может, пользуясь атрибутами, указывать семантические действия. Необходимо на основе этих атрибутов построить код, который будет производить необходимые вычисления.

Для вычисления атрибутов был выбран подход интерпретации дерева (леса) вывода. Основная идея этого алгоритма -- обход заранее построенного дерева вывода и вычисление необходимых функций в его узлах.

В нашем случае дерево будет обходиться снизу вверх, так на данном этапе было решено поддержать только s-атрибутные грамматики. 

При интерпретации дерева вывода оно обходится снизу-вверх и в каждом узле вычисляется некоторая функция, основанная на атрибутах из пользовательской грамматики. Каждый внутренний узел в дереве вывода выражения в данной грамматике соответствует правилу из этой грамматики. Поэтому для интерпретации дерева достаточно построить функцию, соответствующую правилу грамматики и основанную на атрибутах, заданных в этом правиле. При обходе дерева в каждом его узле будет вычисляться соответствующая ему функция.

Функция всегда принимает один аргумент -- дерево разбора строки из сыновей узла, в котором она вычисляется, и является интерпретатором этого дерева. Результат вычислений помещается в узел, для которого функция вычислялась.

Параллельно с генерацией кода строится таблица соответствий между функцией и правилом, для которого она построена. Эта таблица будет применяться при интерпретации дерева вывода для поиска функции, соответствующей текущему узлу дерева. 


\subsubsection{Интерпретация дерева вывода}

Чтобы вычислить семантические действия, заданные пользователем, необходимо выполнить интерпретацию дерева вывода. Для этого нужно обойти дерево снизу вверх и в каждом внутреннем узле вычислить соответствующую функцию, которая ищется с помощью таблицы соответствий между правилом и функцией.

Общая схема интерпретации дерева выглядит следующим образом:
\begin{itemize}
  \item построенное дерево разбора обходится снизу вверх;
  \item для очередного внутреннего узла, на основе трассы, хранимой в нём, строится дерево разбора строки из сыновей;
  \item с помощью таблицы, построенной на этапе генерации, ищется функция, соответствующая данному узлу;
  \item найденная функция применяется к построенному дереву разбора;
  \item результат сохраняется в текущем узле;
\end{itemize} 

В процессе анализа в узлах дерева вывода накапливается информация, необходимая для построения дерева разбора строки из его сыновей в виде трасс вычислений соответствующих автоматов.

Полученная трасса является, по сути своей, правильной скобочной структурой, которую надо наложить на строку из сыновей. Сделать это не сложно, так как каждый символ строки окружён скобками. После этого становится возможным построить дерево разбора строки сыновей. Для этого скобочная пара сворачивается в узел дерева, а все элементы, лежащие внутри скобок, превращаются в сыновей этого узла.

Дерево разбора будет содержать четыре типа узлов:\\
$type \ aTree< \ '\!value> \ = \\
\phantom \qquad |\ ASeq \ of \ List<\!aTree\!>\\
\phantom \qquad |\ AAlt \ of \ Option<\!aTree\!> * Option<\!aTree\!>\\
\phantom \qquad |\ ACls \ of \ List<\!aTree\!>\\
\phantom \qquad |\ ALeaf \ of \ 'value\\
$

Алгоритм построения дерева выглядит следующим образом:
\\
$buildTree \ line = \\
\phantom \qquad let \ group = \ \text{первая скобочная пара из line}\\ 
\phantom \qquad let \ end = \ \text{line без group} \\
\phantom \qquad let \ tree = match \ \text{тип внешних скобок group} \ with\\
\phantom \qquad \qquad |\ Seq \rightarrow    ASeq( buildTree \ \text{значение внутри скобок group})\\
\phantom \qquad \qquad |\ Alt1 \rightarrow   AAlt( (buildTree \ \text{значение внутри скобок group}),N\!one)\\
\phantom \qquad \qquad |\ Alt2 \rightarrow   AAlt( N\!one, (buildrTree \ \text{значение внутри скобок group}))\\
\phantom \qquad \qquad |\ Cls \rightarrow    ACls( buildTree \ \text{значение внутри скобок group})\\
\phantom \qquad \qquad |\ Leaf \rightarrow ALeaf(\text{ значение внутри скобок group)}   \\
\phantom \qquad if \ end \ \text{пусто} \\
\phantom \qquad then \ [tree] \\
\phantom \qquad else \ tree::(buildTree \ end)\\
$

Предложенный выше алгоритм, позволяет вычислять пользовательские атрибуты, обеспечивая при этом непосредственную поддержку EBNF-грамматик. 

\subsection{Архитектура}
\input{architecture.tex}
