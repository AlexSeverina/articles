\section{Обзор}


\subsection{Алгоритм анализа}

Одно из основных требований к инструментам автоматической генерации анализаторов, применяемым при решении задач реинжиниринга -- возможность работать с неоднозначными грамматиками, так как с их помощью часто описываются устаревшие языки.

Существует несколько подходов к реализации алгоритма, позволяющего работать с грамматиками, содержащими неоднозначности:
\begin{itemize}
  \item {\bfseries алгоритм Томиты} (GLR-алгоритм)~\cite{Practical Guide}, основанный на организованном в виде графа стеке, что позволяет переиспользовать результаты вычислений и добиться хорошей производительности: $O(n)$ для однозначных грамматик и $O(n^3)$  в худшем случае;
  \item {\bfseries алгоритм Эрли} (Early)~\cite{Practical Guide}, основа которого -- итеративное повторение операций $ prediction,\; scanning, \; completion$ над специальным образом определённым состоянием. Пусть $S(k)$ множество состояний при  позиции во входной строке $k$. Работа начинается с $S(0)$, состоящего только из начального правила. Операции  $ prediction,\; scanning, \; completion$ можно определить следующим образом:
\begin{itemize}
	\item $prediction$: для каждого состояния из $S(k)$ вида $(X \rightarrow \alpha.Y\beta , j)$ добавить $(Y \rightarrow .y,k)$, для каждой продукции вида $(Y \rightarrow y)$
	\item $scanning$: если $a$ -- следующий символ входной строки, то для каждого состояния из $S(k)$ вида $(X \rightarrow \alpha.a\beta , j)$ добавить $(X \rightarrow \alpha a.\beta,j)$ в $S(k+1)$
	\item $completion$: для каждого состояния из $S(k)$ вида $(X \rightarrow y., j)$ найти $S(j)$ вида $(Y \rightarrow \alpha. X \beta, i)$ и добавить $(Y \rightarrow \alpha X.\beta, i)$ в $S(k)$.
\end{itemize}
Имеет квадратичную сложность для однозначных грамматик и кубическую в общем случае.
  \item {\bfseries рекурсивно-восходящий алгоритм} (recursive-ascent)~\cite{RECURSIVE-ASCENT PARSING}~\cite{RecursiveAscentParsing}, основанный на наборе взаимно-рекурсивных функций, эмулирующих переходы между состояниями, и механизме запоминания результатов предыдущих вычислений;
  \item {\bfseries CYK}~\cite{Practical Guide}, основанный на возможности использовать ранее построенные структуры и результаты.
  \item {\bfseries Unger}~\cite{Practical Guide}, основную идею которого рассмотрим на простом примере. Пусть есть правило $S \rightarrow AB $ и строка $abc$. Надо решить задачу вывода этой строки из $S$. Для этого существует несколько возможностей: 
\begin{itemize}
  	\item из $A$ выводится $ab$ и из $B$ выводится $с$;
  	\item из $A$ выводится $a$ и из $B$ выводится $bс$; 
  \end{itemize}
Для каждой из этих возможностей надо аналогичным образом решить вопрос о выводимости.
\end{itemize}
 
Наиболее широко на практике применяется алгоритм Томиты. Алгоритм Эрли менее распространён. Алгоритмы CYK и Unger мало используются в основном из-за плохой с производительности~\cite{Practical Guide}. 

В настоящее время наиболее популярным в практическом применении является алгоритм Томиты. Существует ряд инструментов, основанных на этом алгоритме:
\begin{itemize}
	\item
	 ASF+SDF~\cite{ASF+SDF} (Algebraic Specification Formalism + Syntax Definition Formalism) -- генератор с широкими возможностями, но достаточно сложным входным языком. Является SGLR-инструментом (Scannerless, Generalized-LR).
	
	\item
	 Bison~\cite{Bison} -- развитие инструмента YACC. Все грамматики, созданные 	для оригинального YACC, будут работать и в Bison. Является одним 	из самых популярных и совершенных "`потомков"' \ YACC. При включении 	соответствующей опции использует GLR-алгоритм (по умолчанию LALR).
	
	\item
	Elkhound~\cite{Elkhound} -- позиционируется как быстрый и удобный GLR-инструмент, созданный в университете Беркли (США), однако обладает достаточно 	"`бедным"' \ входным языком.

  \item 
  DMS~\cite{DMS} -- инструментарий "`DMS Software Reengineering Toolkit"' \ включает в себя парсер генератор, основанный на GLR алгоритме.

	\item
  Happy~\cite{Happy} -- парсер генератор с целевым языком Haskell~\cite{Haskell}. Формат описания входной грамматики очень похож на формат классического YACC.

	\item
  Dypgen~\cite{Dypgen} -- GLR-инструмент, обладающий такими особенностями как возможность удалять и добавлять правила во время синтаксического анализа, специфический способ задания приоритетов операций.

\end{itemize}

Все вышеперечисленные инструменты реализуют механизм анализа "`сдвиг-свёртка"'. Так же существует ряд других инструментов, основанных на том же алгоритме: 
APaGeD~\cite{APaGeD}, 
DParser~\cite{DParser}, 
eu.h8me.Parsing~\cite{h8me}, 
GDK~\cite{GDK}, 
SmaCC~\cite{SmaCC}, 
Tom~\cite{Tom}, 
UltraGram~\cite{UltraGram}, 
Wormhole~\cite{Wormhole}. Все они реализуют GLR или SGLR алгоритм и ни один из них не реализует непосредственной поддержки EBNF-грамматик.

Интересующий нас рекурсивно-восходящий алгоритм реализуется на текущий момент только одним инструментом: Jade~\cite{Jade}. Jade -- это генератор рекурсивно-восходящих LALR(1) парсеров с целевым языком С. При реализации данного инструмента возникла серьёзная проблема, связанная с большим объёмом кода целевого парсера. Так как при построении детерминированного парсера необходимо генерировать процедуры для каждого состояния, то объём кода быстро растёт с ростом количества правил в грамматике. Так, например, для языка Java объём кода составляет примерно 4 мегабайта~\cite{Jade}. В Jade  эта проблема решается путём создания глобальной структуры(массива состояний), где хранится информация, позволяющая переиспользовать процедуры.

Однако существует подход к реализации рекурсивно-восходящего алгоритма, позволяющий решить проблему объёма кода~\cite{Non-det-rec-asc}. С использованием этого подхода можно получить алгоритм для недетерминированного анализа, основанный всего на двух взаимно-рекурсивных функциях и позволяющий реализовать непосредственную поддержку EBNF-грамматик. Ещё одной особенностью является то, что проблемы определения левой границы отрезка в стеке, соответствующего текущему правилу, в данном подходе не существует, так как стек вызовов рекурсивных функций хранит информацию о начале анализа по правилу~\cite{Practical Guide}.

%Таким образом, выяснено, что на текущий момент нет реализаций недетерминированного рекурсивно-восходящего алгоритма, реализующего непосредственную поддержку EBNF-грамматик. Единственная реализация рекурсивно-восходящего алгоритма имеет проблемы с объёмом целевого инструмента, но существует решение этой проблемы.


\subsection{Атрибутные грамматики. Подходы к вычислению атрибутов}

При работе с неоднозначными грамматиками выдвигаются особые требования к алгоритму вычисления атрибутов. Это связано с тем, что в качестве атрибута пользователь может указать действие, обладающее побочным эффектом (например, печать на экран). При наличии таких атрибутов нельзя проводить вычисления непосредственно в процессе анализа, так как в момент разбора не возможно определить, завершиться ли текущая ветвь удачно. В ситуациях, когда при непосредственном вычислении ветвь завершилась неудачно, могут быть совершены лишние действия (например, лишняя печать на экран).

Были рассмотрены два подхода к решению этой проблемы: 
\begin{itemize}

	\item {\bfseries Отложенные вычисления} (continuation passing style, CPS~\cite{CPS}). Непосредственно во время разбора атрибуты не вычисляются. Вычисления откладываются. Строится функция, которая вычисляется только один раз, после удачного завершения разбора.
	
	\item {\bfseries Интерпретация леса вывода} - построение леса вывода и последующее вычисление атрибутов над ним. Первым шагом строится лес вывода, который содержит только деревья, соответствующие успешным вариантам разбора. Следующим шагом над полученным лесом производятся вычисления, соответствующие заданным атрибутам. При корректном задании пользовательских атрибутов (это должны быть s-атрибуты) деревья обходятся снизу-вверх и этот обход конечен.
Данный подход является классическим, однако на практике во многих инструментах (например Bison) дерево вывода непосредственно не строится, а пользовательские атрибуты связываются с действиями LR-автомата.
	
\end{itemize}

Оба этих подхода гарантируют, что будут выполнены действия, соответствующие только успешным вариантам разбора. Однако второй подход является более удобным для конечного пользователя, так как позволяет явно получить дерево вывода, что упрощает отладку. Именно он и был выбран для реализации.
