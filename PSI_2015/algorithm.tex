\section{Algorithm}
Input of the algorithm is a reference grammar $G$ with alphabeth of terminal symbols $T$ 
and a finite automaton with sigle start and single final state and with no $\epsilon$-transitions $(Q, \Sigma, \delta, q_0, f_0)$, where 
$\Sigma \subseteq T$. RNGLR parser tables and some accessory information (we call it $parserSource$ 
in pseudocode~\ref{parsing}) are generated by reference grammar $G$. 
Likewise RNGLR-algorithm, we associate GSS vertices with the position in the input,
and in our case the position is a state of the input automaton. We construct the inner 
data structure by copying input automaton graph and extending vertex type with 
the following collections: 
\begin{itemize}
  \item \emph{processed}: GSS vertices, all the pushes for which are processed. 
                             This set aggregates all GSS vertices associated with inner graph vertex.
  \item \emph{unprocessed}: GSS vertices, pushes for which are to be processed. 
                               This set is analogous to $\mathcal{Q}$ from classic RNGLR-algorithm.
  \item \emph{reductions}: Queue which is analogous to $\mathcal{R}$ from classic RNGLR-algorithm: 
                              stores reductions to be processed.
  \item \emph{passingReductionsToHandle}: Pairs of GSS vertex and GSS edge to apply passing reductions along them.
\end{itemize}
Besides parser $state$ and $level$ (which is equal to the input automaton state), 
we store collection of passing reductions in GSS vertex. Passing reduction is a 
three-tuple $(startV, N, l)$, representing reductions whose path passed through 
the GSS vertex. This three-tuple is very similar to the one describing reductions, 
but in this case $l$ is a remaining length of the path. Passing reductions are 
stored in all vertices of the path (except the first and the last) during path 
searching in makeReductions function (see Algorithm~\ref{processVertex}).

The general idea of the algorithm is to traverse input graph and sequentially construct GSS
in the similar manner as RNGLR does. When deal with graph instead of linear stream,
the next symbol means the set of terminals on outgoing edges of current vertex.
This leads to slightly different process of push and reduce calculation: 
see line 9 in Algorithm~\ref{processVertex} and lines 7 and 22 in Algorithm~\ref{gss_construction}. 
We use queue $Q$ to control the order of input graph vertices processing. 
Every time new GSS vertex is added, zero reductions should be processed 
and then new tokens could be shifted, so corresponging graph vertex should be 
enqueueed for further processing. Adding of new GSS edge could produce reductions 
to handle, so input graph vertex with which tail of the added edge is associated should 
also be enqueueed. See details of GSS construction in Algorithm~\ref{gss_construction}. 
Reductions are applied along the paths in GSS, and if new edge 
which tail vertex have been in the graph before is added, then new paths will possibly 
be added which means some reductions would be lost. So it is necessary to recalculate 
those passing reductions: see applyPassingReductions function in Algorithm~\ref{processVertex}.

The number of paths in the input automaton graph is exponential and could be infinite,
thus, to be able to use parse forest in practice, some finite representation should 
be constructed. RNGLR algorithm use Shared Packed Parse Forest to compress the set 
of trees of possible derivations of input string. We inherit SPPF construction from 
RNGLR algorithm, and, in our case, it merges derivation trees for strings accumulated 
along the paths in the input graph. The example of SPPF constucted by our algorithm is
presented in the Appendix section~\ref{example}.
\begin{algorithm}[!ht]
\begin{algorithmic}[1]
\caption{Parsing algorithm}
\label{parsing}
\Function{parse}{$grammar, automaton$}
  \State{$inputGraph \gets$ construct inner graph representation of $automaton$}
  \State{$parserSource \gets$ generate RNGLR parser tables by $grammar$}
  \State{\Return{\Call{analyse}{$inputGraph, parserSource$}}}
\EndFunction

\Function{analyse}{$inputGraph, parserSource$}
  \If{$inputGraph$ contains no edges}
    \If{$parserSource$ accepts empty input} {report success}
    \Else { report failure}
    \EndIf
  \Else
    \State{\Call{addVertex}{$inputGraph.startVertex, startState$}}
    \State{$Q.Enqueue(inputGraph.startVertex)$}
    \While{$Q$ is not empty}
      \State{$v \gets Q.Dequeue()$}
      \State{\Call{makeReductions}{$v$}}
      \State{\Call{push}{$v$}}
      \State{\Call{applyPassingReductions}{$v$}}
    \EndWhile
    \If{$v_f$ is the vertex in the last level of GSS and its state is accepting}
      \State{report success}
    \Else { report failure}
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
\begin{algorithmic}[1]
\caption{Single vertex processing}
\label{processVertex}

%\Function{processVertex}{$v$}
%  \State{\Call{makeReductions}{$v$}}
%  \State{\Call{push}{$v$}}
%  \State{\Call{applyPassingReductions}{$v$}}
%\EndFunction

\Function{push}{$innerGraphV$}
  \State{$\mathcal{U} \gets$ copy $innerGraphV.unprocessed$}
  \State{clear $innerGraphV.unprocessed$}
  \ForAll{$v_{h}$ in $\mathcal{U}$}  
    \ForAll{edge $e$ in outgoing edges of $innerGraphV$}
      \State{$push \gets$ calculate next state by $v_{h}.state$ and the token on $e$}
      \State{\Call{addEdge}{$v_{h}, e.Target, push, false$}}
      \State{add $v_{h}$ in $innerGraphV.processed$}
    \EndFor
  \EndFor
\EndFunction

\Function{makeReductions}{$innerGraphV$}
  \While{$innerGraphV.reductions$ is not empty}
    \State{$(startV, N, l) \gets innerGraphV.reductions.Dequeue()$}
    \State{find the set of vertices $\mathcal{X}$ reachable from $startV$ along the path of length ($l-1$), or $0$ if $l=0$; add $(startV, N, l-i)$ in $v.passingReductions$ where v is an i-th vertex of the path}
    \ForAll{$v_{h}$ in $\mathcal{X}$}
      \State{$state_{t} \gets$ calculate new state by $v_{h}.state$ and nonterminal $N$}
      \State{\Call{addEdge}{$v_{h}, startV, state_{t}, (l=0)$}}
    \EndFor
  \EndWhile
\EndFunction

\Function{applyPassingReductions}{$innerGraphV$}
  \ForAll{$(v, edge)$ in $innerGraphV.passingReductionsToHandle$}
    \ForAll{$(startV, N, l) \gets v.passingReductions.Dequeue()$}
      \State{find the set of vertices $\mathcal{X}$ reachable from $edge$ along the path of length ($l-1$)}
      \ForAll{$v_{h}$ in $\mathcal{X}$}
        \State{$state_{t} \gets$ calculate new state by $v_{h}.state$ and nonterminal $N$}
        \State{\Call{addEdge}{$v_{h}, startV, state_{t}, false$}}
      \EndFor
    \EndFor
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}
 
\begin{algorithm}[!ht]
\begin{algorithmic}[1]
\caption{Construction of GSS}
\label{gss_construction}
\Function{addVertex}{$innerGraphV, state$}
  \If{$innerGraphV.processed$ or $innerGraphV.unprocessed$ contains vertex $v$ which state = $state$ }
    \State{\Return{($v, false$)}}
  \Else
    \State{$v \gets$ create new vertex for $innerGraphV$ with state $state$}
    \State{add $v$ in $innerGraphV.unprocessed$}
    \ForAll{$e$ in outgoing edges of $innerGraphV$}
      \State{calculate the set of zero-reductions by $v$ and the token on $e$ and add them in $innerGraphV.reductions$}
    \EndFor
    \State{\Return{$(v, true$)}}
  \EndIf
\EndFunction

\Function{addEdge}{$v_{h}, innerGraphV, state_{t}, isZeroReduction$}
  \State{$(v_{t}, isNew) \gets$ \Call{addVertex}{$innerGraphV, state_{t}$}}
  \If{GSS does not contain edge from $v_{t}$ to $v_{h}$}
    \State{$edge \gets$ create new edge from $v_{t}$ to $v_{h}$}
    \State{$Q.Enqueue(innerGraphV)$}
    \If{not $isNew$ and $v_{t}.passingReductions.Count>0$}
      \State{add $(v_{t}, edge)$ in $innerGraphV.passingReductionsToHandle$}
    \EndIf
    \If{not $isZeroReduction$}
      \ForAll{$e$ in outgoing edges of $innerGraphV$}
        \State{calculate the set of reductions by $v$ and the token on $e$ and add them in $innerGraphV.reductions$}
      \EndFor
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
