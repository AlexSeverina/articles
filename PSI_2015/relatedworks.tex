\section{Related Works}

Our approach for syntax analysis of string-embedded languages borrows some common principles
from existing techniques in this area. In addition, we reuse RNGLR syntax analysis algorithm 
and some accompanying constructs. In this section we provide a review and recollect some important
notions which will be referred to later on. 

The analysis of string-embedded languages as a rule requires a set of \emph{hot-spots} to
be indicated in the host application source code. Hot spot is considered as some ``point 
of interest'', where the analysis of the set of possible string values is desirable. This task can be
performed either in a user-assisted manner or automatically using some pragmatic 
considerations or knowledge of the framework being analyzed. The following logical steps 
include static analysis to construct an approximation for the set of all possible string values,
lexical, syntax, and, perhaps, some kind of semantic analysis. These steps not
necessarily performed separatedly; some of them may be omitted.

A rather natural idea of \emph{regular approximation} is to approximate the set of all possible 
strings by a regular expression. In recognition-centric formulation this approach boils down to
the problem of inclusion of approximating regular language into context-free reference language, which
is decidable for a number of practically significant cases~\cite{LangInclusion}.
Many approaches follow this route. In~\cite{Stranger} forward reachability analysis is used to compute regular 
approximation for all string values in the program. Further analysis is based on patterns detection in approximation 
set or generation of some finite subset of strings for analysis by standalone tools. Regular approximation in~\cite{JSA} 
is acquired by widening context-free approximation, initially built as a result of program analysis. 
Our approach is partially inspired by Alvor~\cite{Alvor,ALVOR2}, which utilizes GLR-based technique for syntax 
analysis of regular approximation; this framework implements abstract lexical analysis to convert a
regular language over characters into regular language over tokens, which simplifies syntax analysis.

Kyung-Goo Doh et al. in a series of papers~\cite{AbstrParsing,LRAbstrParsing,LRAbstrParsingSema} introduced an
approach, based on implicit representation of the set of potential strings as a system of data-flow equations. 
Conventional LALR(1) is chosen for the basis of parsing algorithm; original control tables are reused. 
Syntax analysis is performed as the system of dataflow equations is being solved iteratively in the space of abstract stacks.
The problem of infinite stack growth, which appears in general case, is handled using abstract 
interpretation~\cite{AbstractInterpretation}. This approach later evolved to a certain kind of semantic processing
in terms of attribute grammars which made it possible to analyze a wider class of languages, than
LALR(1).

\subsection{RNGLR}
Generalized LR parsing algorithm was presented by Masaru Tomita~\cite{Tomita}
as a solution for natural language processing and was intended to handle ambiguous
context-free grammars. Ambiguities of grammar produce Shift/Reduce and 
Reduce/Reduce conflicts. The algorithm uses parser tables similar to classical LR-tables,
each cell of which can contain multiple actions in case of conflicts. The general approach of 
the algorithm is to carry out all possible actions in these situations. 

However, Tomita's algorithm failed to process general context-free grammars.  
Elizabeth Scott and Adrian Johnstone presented Right-Nulled Generalized LR algorithm~\cite{RNGLR}
which extends and corrects Tomita's GLR parsing methods by
specific way of handling \emph{right nullable} rules (i.e. rules of the form 
$\mathrm{A} \rightarrow \alpha \beta$, where $\beta$ reduces to the empty string). 
That is, not only reductions for items $\mathrm{A} \rightarrow \alpha \cdot$ are 
applied, but also for the items of the form  $\mathrm{A} \rightarrow \alpha \cdot 
\beta$, where $\beta \Rightarrow \epsilon$. Thus, reduction length -- the number of 
symbols to be reduced to a nonterminal -- may be less than or equal to the length 
of righthand side of the rule. There are also possible reductions of 0-length, 
also called as $\epsilon$-reductions, corresponding to items of the form $\mathrm{A} 
\rightarrow \cdot$. 

To represent the set of stacks produced during conflict processing efficiently,
RNGLR algorithm uses Graph Structured Stack. GSS is an ordered graph, 
vertices of which corresponds to elements of classical stack and edges link sequential 
elements together. Each vertex can have multiple incoming edges and by means of 
it be shared between several stacks. Vertex is a pair $(s, l)$, where $s$ is a 
parser state and $l$ is a level -- position in an input string. Vertices in GSS 
are unique and there is no multiple edges. GSS construction routine is illustrated with 
\emph{addVertex} and \emph{addEdge} functions in Algorithm~\ref{rnglr}.

RNGLR-algorithm reads an input from left to right, one token at a time, and 
constructs levels of GSS sequentially for each position in the input. In the 
main loop (see \emph{parse} function in Algorithm~\ref{RNGLRMain}) of the algorithm for each token from the input, firstly, all possible 
reductions are applied (see \emph{reduce} function in Algorithm~\ref{rnglr}), and then the next token 
is shifted (see \emph{push} function in Algorithm~\ref{rnglr}).
\begin{algorithm}[!ht]
\begin{algorithmic}[1]
\caption{RNGLR algorithm}
\label{rnglr}
  
\Function{addVertex}{$i, level, state$}
  \If{GSS does not contain vertex $v = (level, state)$}
    \State{add new vertex $v = (level, state)$ to GSS}
    \State{calculate the set of shifts by $v$ and the $input[i+1]$ and add them to $\mathcal{Q}$}
    \State{calculate the set of zero-reductions by $v$ and the $input[i+1]$ and}
    \State{add them to $\mathcal{R}$}
  \EndIf
  \State{\Return{$v$}}
\EndFunction

\Function{addEdge}{$i, v_{h}, level_{t}, state_{t}, isZeroReduction$}
  \State{$v_{t} \gets$ \Call{addVertex}{$i, level_{t}, state_{t}$}}
  \If{GSS does not contain edge from $v_{t}$ to $v_{h}$}
    \State{add new edge from $v_{t}$ to $v_{h}$ to GSS}
    \If{not $isZeroReduction$}
      \State{calculate the set of reductions by $v$ and the $input[i+1]$ and}
      \State{add them to $\mathcal{R}$}
    \EndIf
  \EndIf
\EndFunction

\Function{reduce}{$i$}
  \While{$\mathcal{R}$ is not empty}
    \State{$(v, N, l) \gets \mathcal{R}.Dequeue()$}
    \State{find the set $\mathcal{X}$ of vertices reachable from $v$ along the path of length $(l-1)$}
    \State{or length $0$ if $l=0$}
    \ForAll{$v_{h} = (level_{h}, state_{h})$ in $\mathcal{X}$}
      \State{$state_{t} \gets$ calculate new state by $state_{h}$ and nonterminal $N$}
      \State{\Call{addEdge}{$i, v_{h}, v.level, state_{tail}, (l=0)$}}
    \EndFor
  \EndWhile
\EndFunction

\Function{push}{$i$}
  \State{$\mathcal{Q^{'}} \gets$ copy $\mathcal{Q}$}
  \While{$\mathcal{Q^{'}}$ is not empty}
    \State{$(v, state) \gets \mathcal{Q}.Dequeue()$}
    \State{\Call{addEdge}{$i, v, v.level + 1, state, false$}}
  \EndWhile
\EndFunction

\end{algorithmic}
\end{algorithm}

\begin{algorithm}[!ht]
\begin{algorithmic}[1]
\caption{RNGLR main function}
\label{RNGLRMain}
\Function{parse}{$grammar, input$}
  \State{$\mathcal{Q} \gets \emptyset$} \Comment{Queue of tuples of GSS vertex, nonterminal, and reduction length}
  \State{$\mathcal{R} \gets \emptyset$} \Comment{Collection of pairs of GSS vertex and parser state}
  \If{$input = \epsilon$}
    \If{$grammar$ accepts empty input} {report success}
    \Else { report failure}
    \EndIf
  \Else
    \ForAll{$i$ in $0..input.Length-1$}
      \State{\Call{reduce}{$i$}}
      \State{\Call{push}{$i$}}
    \EndFor
    \If{$i=input.Length-1$ and there is a vertex in the last level of GSS which state is accepting}
      \State{report success}
    \Else { report failure}
    \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

