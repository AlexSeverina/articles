\section{Correctness of the Algorithm}
In this section we prove the correctness of the algorithm proposed, namely its termination 
and correctness of parse forest construction.

~\\
\textsc{Theorem 1.}
\textit{For any given deterministic context-free grammar and any given nondeterministic
finite automaton with single start and single final state and with no $\epsilon$-transitions,
the algorithm terminates.}
~\\
\textsc{Proof.}
Each vertex of inner representation of the input finite automaton contains, at most, 
$N$ GSS vertices, where $N$ is a number of parser states, so for the inner graph which contains $n$
vertices, the total number of GSS vertices is, at most, $Nn$. GSS has no multi-edges,  
meaning, the number of edges is $\mathcal{O}((Nn)^2)$. 
The algorithm dequeues vertex to be processed from the queue $Q$ at each iteration of the 
main loop. Vertices are enqueued to $Q$ only if a new edge is added to GSS. Since the number of 
GSS edges is finite, the algorithm always terminates. 
~\\

We slightly redefine classical notion of correct parse tree to better suit our problem.

~\\
\textsc{Definition.} 
\emph{Correct tree} is an ordered, rooted tree with the following properties:
\begin{enumerate}
  \item The root is the start nonterminal of the grammar $G$.
  \item The leaf nodes are the terminals of $G$. The sequence of the leaf nodes 
        corresponds to a path in the inner graph. 
  \item The interior nodes are the nonterminals of $G$. The children of nonterminal 
        $N$ correspond to the symbols on the right-hand side of some production for $N$ in $G$.
\end{enumerate}

To prove the correctness of parse tree construction we would need the following Lemma.

~\\
\textsc{Lemma 1.}
For every GSS edge $(v_{t}, v_{h})$, $v_{t} \in V_{t}.processed$, $v_{h} \in V_{h}.processed$, 
the terminals of the associated subtree corresponds to some path in the inner graph $p$ from $V_{h}$ to $V_{t}$
~\\
\textsc{Proof.}
The proof is by induction on the height of derivation tree. 
A tree of 0-height may be either an $\epsilon$-tree or a tree of a single leaf.
An $\epsilon$-tree corresponds to a path of 0-lenght; the tail and the head of the edge associated with 
$\epsilon$-tree are identical, thus the statement is true. A tree of a single leaf corresponds to a single 
terminal read from an edge ($V_{h}$, $V_{t}$) of the inner graph, thus the statement is true.

A tree which has height $k$ has a nonterminal $N$ as a root. By third item in the definition of correct tree, 
there is a production $N \rightarrow A_{0}, A_{1} \dots A_{n}$ for children of the root $A_{0}, A_{1} \dots A_{n}$. 
Subtree $A_{i}$ is associated with the GSS edge $(v_{t}^{i}, v_{h}^{i})$ and as its height is $k-1$, by induction,
there is a path in the inner graph from $V_{h}^{i}$ to $V_{t}^{i}$. $V_{t}^i = V_{h}^{i+1}$, as $v_{t}^i = v_{h}^{i+1}$, 
thus there is a path in the inner graph from $V_{h}^{0}$ to $V_{t}^{n}$ corresponding to the tree under consideration.
~\\

The following theorems prove the correctness of parse forest construction. SPPF construction is inherited from 
RNGLR-algorithm, so the proofs are presented in terms of GSS construction correctness.

~\\
\textsc{Theorem 2.} 
\textit{Every tree generated from SPPF is a correct tree.}
~\\
\textsc{Proof.} Let us consider some tree generated from SPPF and proof it is coorect. 
The first and the third items of the definition are true by consequence of SPPF definition.
\textsc{Lemma 1} proofs the second item of the definition by consideration of all the edges from the GSS vertex
on the last level having accepting state to the vertex on the 0-level with the start parser state.

~\\
\textsc{Theorem 3.} 
\textit{For every path $p$ in the inner graph, a correct tree corresponding to the $p$ could be generated from SPPF.}
~\\
\textsc{Proof.}
Consider a correct tree and show it could be generated from SPPF. The proof mimics the proof of correctness for RNGLR-algorithm,
except the following moment. RNGLR-algorithm constructs GSS layer-by-layer: it is guaranteed that $j$-th level of the GSS 
$\forall j \in [0..i-1]$ would be fixed by the time of $i$-th level is processed. In our case, this property is incorrect 
which leads to possible generation of the paths for reductions already been applied. The only possible way to actually 
add new path is to add an edge $(v_{t}, v_{h})$, where $v_{t}$ is in the GSS already and has incoming edges.
Since the algorithm store which reductions have passed through each vertex, it is sufficient to continue passing 
reductions stored in $v_{t}$ to overcome this problem, and it is exactly what \emph{applyPassingReductions} function does. 