\section{Preliminaries}
\label{sec:prel}
\label{preliminaries}
\paragraph{Formal languages} 
A \textit{context-free grammar} is a triple $G = (\Sigma, N, P)$, where $\Sigma$ is a finite set of alphabet symbols,  $N$ is a set of nonterminal symbols, $P$ is a set of production rules. $L(G)$ is a context-free language generated by context-free grammar $G$. Notice that usually context-free grammar is defined with a fixed start nonterminal. $G_A$ denotes a context-free grammar with fixed start nonterminal $A  \in N$, $L(G_A)$ is a language generated by a grammar $G_A$, respectively. We use the notation $A \stackrel {*}{\Rightarrow } w$  to denote that the string $w \in \Sigma^*$ can be derived from a non-terminal $A$ by sequence of applying the production rules from $P$. A \textit{parse tree} is an entity which represents the structure of the derivation of a terminal string from some nonterminal.


A grammar $G$ is said to be is in the \textit{Chomsky normal form}, if all production rules of $P$ are of the form:
$A \rightarrow BC$ or $A \rightarrow a$, where $A, B, C \in N$ and $a \in \Sigma$.


Notice that the rules of the form $A \rightarrow \varepsilon$, where $\varepsilon$ denotes an empty string, are omitted. This is because it is trivial to find an empty string in the case of graph input. 


Context-free languages are accepted by pushdown automata (PDA). \textit{Pushdown automaton} is a 7-tuple $M = (Q, \Sigma, \Gamma, \delta, q_0, Z, F)$, where $Q$ is a finite set of states, $\Sigma$ is a input alphabet, $\Gamma$ is a finite set which is called the stack alphabet, $\delta$ is a finite subset of $Q \times (\Sigma \cap \{\varepsilon\}) \times \Gamma \times Q \times \Gamma^*$,
$q_{0}\in Q$ is the start state, $Z \in \Gamma$ is the initial stack symbol and
$F\subseteq Q$ is the set of accepting states.


Some operations on languages will be mentioned during this paper.


A \textit{homomorphism} is a function $h: \Sigma^* \rightarrow \Delta^*$ defined as follows: 
\begin{itemize}
\item $h(\varepsilon) = \varepsilon$ and for $a \in \Sigma$, $h(a)$ is any string in $\Delta^*$,
\item for $a = a_1a_2 ... a_k \in \Sigma^*$ $(k \ge 2)$, $h(a) = h(a_1)h(a_2)... h(a_k)$.
\end{itemize}
Given a homomorphism $h: \Sigma^* \rightarrow \Delta^*$ and a language $L$ define $h(L)= \{h(w)$ | $w \in L\} \subseteq \Delta^*$.
\\
\textit{Insertion} of a class of a language $K$ into a language $L$ is a language $L' = \{uxv$ $|$ $x \in K, u, v \in L\}$ 


A \textit{full trio} is a family of languges is closed under arbitrary homomorphism and intersection with regular language. A \textit{full AFL (abstract family of languages)} is a full trio closed under union, concatenation and the Kleene plus. 


A \textit{regular language} is a language that can be expressed with a regular expression or a deterministic or non-deterministic finite automata.
An \textit{nondeterministic finite automata} (NFA) is represented by a 5-tuple, $(Q,\Sigma ,\Delta ,q_{0},F)$, where $Q$ is a finite set of states, $\Sigma$ is a finite set of input symbols, $\Delta:Q\times \Sigma \rightarrow 2^{|Q|}$ is a transition function, $q_0 \in Q$ is a start state, $F \subseteq Q$ is a set of accepting (final) states. \textit{Deterministic fininite automaton} is NFA with the following restrictions: each of its transitions is uniquely determined by its source state and input symbol, and reading an input symbol is required for each state transition.


 For a language $L$ over an alphabet $\Sigma$, its rational index $\rho_L$ is a function defined as follows:
\begin{equation}
\rho_L(n) = \max\{\min\{|w|:w \in L \cap K\}, K \in {Rat}_n, L \cap K \neq \emptyset\},
\end{equation} where $|w|$ is the length of a word $w$ and ${Rat}_n$ denotes the set of regular languages on an alphabet $\Sigma$, recognized by a finite nondeterministic automation with at most $n$ states. $w(\rho_L(n))$ denotes word $w$, whose length is the value of rational index of $L$.
\paragraph{Context-free language reachability} 
A \textit{directed labelled graph} is a triple $D = (Q, \Sigma, \delta)$, where $Q$ is a finite set of nodes, $\Sigma$ is a finite set of alphabet symbols,
and $\delta \subseteq Q \times \Sigma \times Q$ is a finite set of labeled edges. 


Let $i\pi j$ denote a unique path between nodes $i$ and $j$ of the input graph and $l(\pi)$ denote a unique string which is obtained from concatenation of edge labels along the path $\pi$. Then the general formulation of CFL-reachability can be stated as follows.
\begin{definition}
Let $G = (\Sigma, N, P)$ be a context-free grammar and $D = (Q, \Sigma, \delta)$ be a directed labelled graph. Given two nodes $i$ and $j$ we say that $j$ is \textit{reachable} from $i$ if there exists a path $i \pi j$, such that $l(i \pi j) \in L(G)$. 
\end{definition}


When this problem is restricted to some language $L$ (not necessary context-free), it is called \textit{L-reachability}. There are four varieties of CFL-reachability problems: all-pairs problem, single-source problem, single-target problem and single-source/single-target problem \cite{RepsBasic}. In this paper we consider all-pairs problem. The \textit{all-pairs problem} is to determine all pairs of nodes $i$ and $j$ such that $j$ is reachable from $i$. Notice that our definition of context-free grammar doesn't include a start nonterminal: one may be interested in reachability for every $L(G_A)$, where $A \in N$. In other words, we need to find all triples $(A, i, j)$ for which $j$ is reachable from $i$ via path labelled from a string from $L(G_A)$.


