\section{Languages with poly-slender storage languages}
\label{sec:poly}
In previous section restriction in terms of variability of stack height of PDA was described. But it is not the case for $D_1$, which is a $k$-oscillating CFL for no $k$. In this section another kind of stack restriction is considered --- poly-slenderness of a pushdown storage language as a measure of how variable is stack contents along accepting computations of PDA.


For PDA $M$, its \textit{pushdown store language} $P(M)$ consists of all words
occurring on the pushdown store along accepting computations of $M$. It is well-known that store language of any PDA is a regular language. $D_1$ is a one-counter language, so its pushdown store language is obviously $Z^*Z_0$, where $Z$ is a single pushdown symbol and $Z_0$ is a bottom-of-pushdown symbol $Z_0$.


Afrati et. al in \cite{ChainQ} give a notion of \textit{polynomial stack property} and show that if a PDA has polynomial stack property, then corresponding query has polynomial fringe property (and hence, lies in NC complexity class). PDA has polynomial stack property iff the largest possible number of different contents of the same height $k$ along the accepting computations of PDA $M$ is bounded by polynomial $O(k^d)$ for $d \ge 0$.  For, example PDA for $D_1$ has polynomial stack property, because there is the only one possible variant of contents for every height of stack.


Notice that for PDA polynomial stack property is equivalent to having \textit{poly-slender} pushdown store language (or storge language with polynomial density). Density of a language shows the number of words of length $n$ in language. Language $L \subseteq \Sigma^*$ is called \textit{poly-slender language (or language with polynomial density)} if function $|L \cap \Sigma^n|$ is bounded by $O(n^k)$ for some $k \ge 0$. For example, the language $Z^*Z_0$ is of polynomial density (even of a constant density), whereas the language ${(Z_1 + Z_2)}^*Z_0$ is of exponential density.


Thus we can reformulate The Polynomial Stack Lemma from \cite{ChainQ} as follows:
\begin{lemma}
Let $L$ be a context-free language and $M$ be a PDA recognising it. If pushdown storage language $P(M)$ is a poly-slender regular language, then CFL-reachability problem for $L$ and arbitrary graph is in NC complexity class.
\end{lemma}
While deciding whether a query has the polynomial fringe property is undecidable \cite{Ullman}, it is decidable in polynomial time whether a given PDA has a poly-slender storage language and hence polynomial stack property. 


At first we show how to use Ufnarovskii's criterion for the growth of directed graphs \cite{Ufnarovskii} to decide in polynomial time whether a given NFA recognizes poly-slender language. 


Let $H = (V,  E)$ be a directed graph, then \textit{growth function of graph} $r_H(n)$ defines the number of all paths of length at most $n$ in $H$. Vertex is called \textit{cyclic} if it occurs in some cycle, \textit{double cyclic} if at least two distinct cycles pass through it (these cycles should form distinct graphs, not paths). Graph $H$ is \textit{cyclically simple} if it has no doubly cyclic vertices (hence, any distinct cycles have no common vertices).
\begin{lemma}[Ufnarovskii's criterion.]
\label{Ufnar}
For a directed graph $H$ growth function $r_H(n)$ is either polynomial or exponential. More precisely:
\begin{itemize}
\item $r_H(n)$ is exponential iff $H$ has a double cyclic vertex
\item $r_H(n)$ is polynomial iff $H$ is cyclically simple
\end{itemize}
\end{lemma}
\begin{theorem}
\label{lemconstr}
Given an NFA $F$ it is decidable in polynomial time whether $F$ recognizes poly-slender language.
\end{theorem}
\begin{proof}
Consider a directed graph $H = (V, E)$ corresponding to the given NFA $F$. Cyclicical simplicity of $H$ can be easily checked by running DFS from each vertex of the graph. Then using Ufnarovskii's criterion (Lemma \ref{Ufnar}), one defines is $r_H(n)$ exponential or polynomial. $F$ recognizes poly-slender language if number of all accepting computatation paths of length $n$ is bounded by some polynomial $O(n^k)$. Let $a_H(n)$ be the number of accepting paths of length at most $n$ in $F$. It is left to show that if $r_H(n)$ is polynomial (exponential) then $a_H(n)$ is polynomial (exponential).
\\
It is easy to see that $a_H(n) \le r_H(n)$, because $r_H(n)$ counts all paths in graph and not every path is accepting. Clearly, if $r_H(n)$ is polynomial then $a_H(n)$ is polynomial. 
Every non-accepting path is a subpath of an accepting path (otherwise it can be deleted from NFA). An accepting path of length $n$ has at most $\binom{n+1}{2} -1 = \frac{(n+1)n}{2} -1$ distinct subpaths. The length of any subpath is bounded by $n$. So we have
$$
r_H(n) \le a_H(n) (\frac{(n+1)n}{2} -1) n \le (n^3 + n^2) a_H(n)
$$
Thus if $r_H(n)$ is exponential then $a_H(n)$ is exponential. This completes the proof.
\end{proof}

\begin{example}[Ufnarovskii's criterion and a polynomial density.]
NFAs recognising poly-slender language $Z^*Z_0$ and a regular language with an exponential density ${(Z_1+Z_2)}^*Z_0$ are presented on Figure~\ref{graphufn}. The graph of the first automotion is cyclically simple and the graph of the second automotion has a double cycled vertex $q_0$. 
\\It is well-known result that regular language is poly-slender if and only if it can be represented as a finite union of the regular expressions of the form $xy^*_1z_1... y^*_tz_t$, where $t \ge 0$ and $x, y_1, z_1, ... , y_t, z_t$ are words in $\Sigma^*$ \cite{poldens}. NFA for every such expression is clearly cyclically simple. 
\end{example}
Using the fact that for a given PDA $M$, NFA for $P(M)$ can be constructed in deterministic polynomial time (size of NFA is quadratic in the number of states and linear in the number of pushdown symbols of $M$) \cite*{Geffert, Malcher} and Theorem~\ref{lemconstr} we immediatly deduce the following.
\begin{corollary}
Given a pushdown automotion $M$, it can be decided whether $P(M)$ is poly-slender in polynomial time.
\end{corollary}

\begin{figure}
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state](q01) [initial]  {$q_0$}; 
   \node[state, accepting](q11) [right=of q01] {$q_1$}; 
 \node [] (empty)  [right=of q11] { };
   \node[state, initial] (q02) [right=of empty]  {$q_0$}; 
     \node[state, accepting](q21) [right=of q02] {$q_1$}; 
\path[->]          
    (q01) edge [loop above] node {$Z$} (q01)
    (q01) edge node {$Z_0$} (q11)

    (q02) edge [loop above] node {$Z_1$} (q02)
  (q02) edge [loop below] node {$Z_2$} (q02)
    (q02) edge node {$Z_0$} (q21);

    
\end{tikzpicture}
\\
	\caption{NFAs for languages $Z^*Z_0$ (left) and ${(Z_1+Z_2)}^*Z_0$ (right).}
\label{graphufn}
\end{figure}

