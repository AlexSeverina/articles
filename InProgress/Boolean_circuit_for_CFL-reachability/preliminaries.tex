\section{Preliminaries}
\label{sec:prel}
\label{preliminaries}
\paragraph{Formal languages} 
A \textit{context-free grammar} is a triple $G = (\Sigma, N, P)$, where $\Sigma$ is a finite set of alphabet symbols,  $N$ is a set of nonterminal symbols, $P$ is a set of production rules. $L(G)$ is a context-free language generated by context-free grammar $G$. Notice that usually context-free grammar is defined with a fixed start nonterminal. $G_A$ denotes a context-free grammar with fixed start nonterminal $A  \in N$, $L(G_A)$ is a language generated by a grammar $G_A$, respectively. We use the notation $A \stackrel {*}{\Rightarrow } w$  to denote that the string $w \in \Sigma^*$ can be derived from a non-terminal $A$ by sequence of applying the production rules from $P$. A \textit{parse tree} is an entity which represents the structure of the derivation of a terminal string from some nonterminal.


A grammar $G$ is said to be is in the \textit{Chomsky normal form}, if all production rules of $P$ are of the form:
$A \rightarrow BC$ or $A \rightarrow a$, where $A, B, C \in N$ and $a \in \Sigma$.


A context-free grammar is in the \textit{Greibach normal form}, if all production rules are of the form: $A \rightarrow aA_1A_2...A_k$, where $A$ is a nonterminal symbol, $a$ is a terminal symbol, $A_1A_2...A_k$ is a (possibly empty) sequence of nonterminal symbols.

Notice that the rules of the form $A \rightarrow \varepsilon$, where $\varepsilon$ denotes an empty string, are omitted. This is because it is trivial to find an empty string in the case of graph input. 


Context-free languages are accepted by pushdown automata (PDA). \textit{Pushdown automaton} is a 7-tuple $M = (Q, \Sigma, \Gamma, \delta, q_0, Z, F)$, where $Q$ is a finite set of states, $\Sigma$ is a input alphabet, $\Gamma$ is a finite set which is called the stack alphabet, $\delta$ is a finite subset of $Q \times (\Sigma \cap \{\varepsilon\}) \times \Gamma \times Q \times \Gamma^*$,
$q_{0}\in Q$ is the start state, $Z \in \Gamma$ is the initial stack symbol and
$F\subseteq Q$ is the set of accepting states.


Some operations on languages will be mentioned during this paper.
\\
A \textit{homomorphism} is a function $h: \Sigma^* \rightarrow \Delta^*$ defined as follows: 
\begin{itemize}
\item $h(\varepsilon) = \varepsilon$ and for $a \in \Sigma$, $h(a)$ is any string in $\Delta^*$,
\item for $a = a_1a_2 ... a_k \in \Sigma^*$ $(k \ge 2)$, $h(a) = h(a_1)h(a_2)... h(a_k)$.
\end{itemize}
Given a homomorphism $h: \Sigma^* \rightarrow \Delta^*$ and a language $L$ define $h(L)= \{h(w)$ | $w \in L\} \subseteq \Delta^*$.
\\
\textit{Substitution closure} of a class of languages $L$ is the least class containing all substitutions of languages from $L$ to the languages from $L$.


A \textit{regular language} is a language that can be expressed with a regular expression or a deterministic or non-deterministic finite automata.
An \textit{nondeterministic finite automata} (NFA) is represented by a 5-tuple, $(Q,\Sigma ,\Delta ,q_{0},F)$, where $Q$ is a finite set of states, $\Sigma$ is a finite set of input symbols, $\Delta:Q\times \Sigma \rightarrow 2^{|Q|}$ is a transition function, $q_0 \in Q$ is a start state, $F \subseteq Q$ is a set of accepting (final) states. \textit{Deterministic fininite automaton} is NFA with the following restrictions: each of its transitions is uniquely determined by its source state and input symbol, and reading an input symbol is required for each state transition.


A rational transducer $M$ is a 6-tuple $(Q, \Sigma, \Delta, \tau, q_0, F)$ where $Q$ is a finite set of states, $\Sigma$ and $\Delta$ are the input and output alphabets respectively, and $Ï„$ is as a finite subset of $S \times \Sigma^* \times S \times \Delta^*$, $q_0 \in Q$ is initial state and $F \subseteq Q$ is non-empty set of finite states.


Given a rational transducer $M$, for every input word $w$, \textit{rational trunsduction} $RT_M$ is a function defined as follows:
$RT_M(w) =$ \{$v \in \Delta^*|(t, v) \in \tau(q_0, w)$ is a final output configuration\}.
\paragraph{CFL-reachability} 
A \textit{directed labelled graph} is a triple $D = (Q, \Sigma, \delta)$, where $Q$ is a finite set of nodes, $\Sigma$ is a finite set of alphabet symbols,
and $\delta \subseteq Q \times \Sigma \times Q$ is a finite set of labeled edges. 


Let $i\pi j$ denote a unique path between nodes $i$ and $j$ of the input graph and $l(\pi)$ denote a unique string which is obtained from concatenation of edge labels along the path $\pi$. Then the general formulation of CFL-reachability can be stated as follows.
\begin{definition}
Let $G = (\Sigma, N, P)$ be a context-free grammar and $D = (Q, \Sigma, \delta)$ be a directed labelled graph. Given two nodes $i$ and $j$ we say that $j$ is \textit{reachable} from $i$ if there exists a path $i \pi j$, such that $l(i \pi j) \in L(G)$. 
\end{definition}
When this problem is restricted to some language $L$ (not necessary context-free), it is called \textit{L-reachability}. There are four varieties of CFL-reachability problems: all-pairs problem, single-source problem, single-target problem and single-source/single-target problem \cite{RepsBasic}. In this paper we consider all-pairs problem. The \textit{all-pairs problem} is to determine all pairs of nodes $i$ and $j$ such that $j$ is reachable from $i$. Notice that our definition of context-free grammar doesn't include a start nonterminal: therefore we are interested in reachability for every $L(G_A)$, where $A \in N$. In other words, we need to find all triples $(A, i, j)$ for which $j$ is reachable from $i$ via path labelled from a string from $L(G_A)$.

\paragraph{Boolean circuits and complexity classes} 
\textit{Boolean circuit} is a directed acyclic graph, along with various labels associated with its nodes, satisfying the following constraints:
\begin{itemize}
\item There are set of \textit{input nodes} with $n$ members, labelled $x_1, . . . ,x_n$. Each input node and must have in-degree 0.
\item There are set of  \textit{gate nodes (gates)}. Each gate node of the circuit is labelled by an element of the set $\{\lor, \land, \neg \}$. 
\item There are set of \textit{output nodes} with $m$ members, labelled $y_1, . . . ,y_m$.
\item All three sets above are disjoint.
\end{itemize}
A Boolean circuit having $n$ inputs and $m$ outputs computes a Boolean function of the form: $f:{\{0, 1\}}^n \rightarrow {\{0, 1\}}^m$.


Two important characteristics of the Boolean circuit are its size and depth. \textit{Size} of the Boolean circuit is number of its elements, and \textit{depth} is the length of the longest path in the circuit from an input to an output node.


$NC^i$ is the complexity class of decision problems decidable by uniform Boolean circuits with a polynomial number of gate nodes of at most two inputs and depth $O(\log^i n)$, or the class of decision problems solvable in time $O(\log^i n)$ on a parallel computer with a polynomial number of processors. NC is the union of all $NC^i$.


A decision problem is P-complete (complete for the complexity class P) if it is in P and every problem in P can be reduced to it by an appropriate reduction. Practically,  P-complete problems are problems, which are difficult to parallelize effectively.