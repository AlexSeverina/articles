\section{\bf Scientific Background}

\subsection{\bf \it Preliminaries}

An alphabet $\Sigma$ is a finite nonempty set of symbols. $\Sigma^{*}$ is a set of all finite strings over $\Sigma$.
A grammar is a quadruple $(\Sigma, N, R, S)$, where $\Sigma$ is a finite set of terminals, $N$ is a finite set of nonterminals, $R$ is a finite set of productions of the form $\alpha \rightarrow \gamma$, where $\alpha \in V^{*}NV^{*}$, $\gamma \in V^{*}$, $V = \Sigma \cup N$ and $S \in N$ is a start symbol.

Grammar $G = (\Sigma, N, R, S)$ is called context-free, if $\space\forall r \in R$ are of the form $A \rightarrow \beta$, where $A \in N, \beta \in V^{*}$.

Context-free grammar $G = (\Sigma, N, R, S)$ is said to be in Chomsky normal form if all productions in R are of the form:
\begin{itemize}[noitemsep, nolistsep]
    \item[$-$] $A \rightarrow BC$,
    \item[$-$] $A \rightarrow a$,
    \item[$-$] $S \rightarrow \varepsilon$, where $A, B, C \in N, a \in \Sigma, \varepsilon$ is an empty string.
\end{itemize}

$L_{G}(A)$ is a language of the grammar $G_{A} = (\Sigma, N, R, A)$, which means all the sentences that can be derived in a finite number of rules applications from the start symbol $A$.

\subsection{\bf \it Parsing by matrix multiplication}

The main problem of parsing is to verify if the input string belongs to the language of some given grammar $G$.

This work is based on parsing algorithm presented by Valiant[].
Main idea of all tabular parsing methods is to construct a parsing table $T$ of size $(n + 1) \times (n + 1)$ for an input string $a_{1}a_{2} \dots a_{n}$ and context-free grammar $G = (\Sigma, N, R, S)$ which is in Chomsky normal form, where

\begin{equation}
T_{i, j} =  \{ A | A \in N, a_{i + 1} \dots a_{j} \in L_{G}(A)\} \quad \forall i < j.
\end{equation}

The elements of $T$ are filled successively beginning with
\begin{equation}
T_{i - 1, i} = \{ A | A \rightarrow a_{i} \in R\}
\end{equation}
Then, 
\begin{equation}
T_{i, j} = f(P_{i, j}),
\end{equation}
where
\begin{equation}
P_{i, j} = \bigcup\limits_{k = i + 1}^{j - 1} T_{i,k} \times T_{k, j}
\end{equation}
\begin{equation}
f(P) = \{A | \exists A \rightarrow BC \in R : (B, C) \in P\} 
\end{equation}

The input string $a_{1}a_{2} \dots a_{n}$ belongs to $L_{G}(S)$ if and only if $S \in T_{0, n}$.

If all elements are filled sequentially, the time complexity of this algorithm is $O(n^3)$. Valiant proposed to offload the most intensive computations to the Boolean matrix multiplication. As the most time-consuming is computing $\bigcup\limits_{k = i + 1}^{j - 1} T_{i, k} \times T_{k, j}$, Valiant rearranged computation of $T_{i, j}$, in order to use multiplication of submatrices of $T$.

Firstly, define multiplication of two submatrices of parsing table T. Let $X \in (2^N)^{m \times l}$ and $Y \in (2^N)^{l \times n}$ be two submatrices of parsing table $T$. Then, $X \times Y = Z$, where $Z \in (2^{N \times N})^{m \times n}$ and $Z_{i, j} = \bigcup\limits_{k = 1}^{l} X_{i, k} \times Y_{k, j}$.

And next, $X \times Y = Z$  can be replaced by multiplication of $|N|^2$ Boolean matrices (for each nonterminal pair). Denote matrix corresponding to pair $(B, C) \in N \times N$ as $Z^{(B, C)}$, then $Z_{i, j}^{(B, C)} = 1$ if and only if $(B, C) \in Z_{i, j}$. It should also be noted that $Z^{(B, C)} = X^{B} \times Y^{C}$. Each Boolean matrix multiplication can be computed independently. Following these changes, time complexity of this algorithm is $O(|G|BMM(n)log(n))$ for an input string of length $n$, where $BMM(n)$ is the number of operations needed to multiply two Boolean matrices of size $n \times n$.

In listing~\ref{algo:valiant} full pseudo-code of Valiant's algorithm is written in the terms proposed by Okhotin, is presented. All elements of $T$ and $P$ are initialized by empty sets. Then, the elements of these two table are successively filled by two recursive procedures. 

% Algorithm1
\begin{algorithm}[h]
\SetAlgoNoLine
\KwIn{Grammar $G = (\Sigma, N, R, S), w = a_{1} \dots a_{n}, n \geq 1, a_{i} \in \Sigma$, where  n + 1 is a power of two}
\underline{main()}{:}{

 \textit{compute(0, n + 1)\;}
 accept if and only if $S \in T_{0, n}$
 \linebreak
 }

\underline{compute(\textit{l, m})}{:}{

 \If {$m - l \geq 4$}{
     \textit{compute(l, $\frac{l+m}{2}$)\;
     compute($\frac{l+m}{2}$, m)}}
 \textit{complete(l, $\frac{l+m}{2}$, $\frac{l+m}{2}$, m)}
 \linebreak
 }

\underline{complete(\textit{l, m}, $l^\prime$, $m^\prime$)}{:}{

 \If {$m - l = 4$ and $m = l^\prime$}{$T_{l, l + 1} = \{A | A \rightarrow a_{l+ 1} \in R\}$\;}
 \ElseIf{$m - l = 1$ and $m < l^\prime$}{ $T_{l, l'} = f(P_{l, l'})$\;}
 \ElseIf{$m - l > 1$}{
    $leftgrounded = (l, \frac{l+m}{2}, \frac{l+m}{2}, m), rightgrounded = (l', \frac{l'+m'}{2}, \frac{l'+m'}{2}, m')$,

    $bottom = (\frac{l+m}{2}, m, l', \frac{l'+m'}{2}), left = (l, \frac{l+m}{2}, l', \frac{l'+m'}{2})$,

    $right = (\frac{l+m}{2}, m, \frac{l'+m'}{2}, m'), top = (l, \frac{l+m}{2}, \frac{l'+m'}{2}, m')$\;
    complete(bottom)\;
    $P_{left} = P_{left} \cup (T_{leftgrounded} \times T_{bottom})$\;
    complete(left)\;
    $P_{right} = P_{right} \cup (T_{bottom} \times T_{rightgrounded})$\;
    complete(right)\;
    $P_{top} = P_{top} \cup (T_{leftgrounded} \times T_{right})$\;
    $P_{top} = P_{top} \cup (T_{left} \times T_{rightgrounded})$\;
    complete(top)
    }
 }
\caption{Parsing by matrix multiplication: Valiant's Version}
\label{algo:valiant}
\end{algorithm}

The procedure $compute(l, m)$ constructs the correct values of $T_{i,j}$ for all $l \le i < j < m$.

The procedure $complete(l, m, l', m')$ constructs the submatrix $T_{i, j}$ for all $l \le i < m$, $l' \le j < m'$. This procedure assumes $T_{i, j}$ for all $l \leq i < j < m,  l' \leq i < j < m'$ are already constructed and the current value of  $P[i, j] =  \{ (B, C) |\exists k, (m \le k < l'), a_{i + 1} \dots a_{k} \in L(B), a_{k + 1} \dots a_{j} \in L(C)\}$ for all $l \leq i < m,  l' \leq j < m'$. The submatrix division during the procedure call is shown in figure~\ref{fig2}.


\begin{figure}[h]
\vspace{3mm}
 \begin{center}
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=6cm]{pictures/splitting_with_grounded.pdf}
        \caption{Matrix partition used in \textit{complete(l, m, l', m')} procedure.}
        \label{fig1}
    \end{minipage}\hfill
    \begin{minipage}{0.48\textwidth}
        \centering
        \includegraphics[width=6cm]{pictures/layers.pdf}
        \caption{Matrix partition on V-shaped layers used in modification.}
        \label{fig2}
    \end{minipage}
 \end{center}
\vspace{-8mm}
\end{figure}

In figure~\ref{fig3} is presented a simple example of Valiant's algorithm. Only the beginning of the work is shown, because later we point out at this version and our approach differences. 

\begin{figure}[h]
\vspace{3mm}
 \begin{center}
 \includegraphics[width=12cm]{pictures/valbeg2.pdf}
    \caption{An example of beginning of Valiant's algorithm}
    \label{fig3}
\end{center}
\vspace{-8mm}
\end{figure}