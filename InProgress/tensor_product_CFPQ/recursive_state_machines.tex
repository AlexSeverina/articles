\section{Recursive State Machines}

% Links to some papers about RSM 
% DFA with recursive calls https://www.cis.upenn.edu/~jean/recdfa.pdf
% RSM Analisys https://link.springer.com/content/pdf/10.1007%2F3-540-44585-4_18.pdf
% Algos for RSM https://arxiv.org/pdf/1701.04914.pdf
% Minimisation on RSM and VPA https://core.ac.uk/download/pdf/4820448.pdf

% The primary notation is set of boxes

In this section, we introduce the notation of recursive state machine (or RSM), with its definition and semantic description. This kind of computational machines extends the definition of finite state machines and increases the computational capabilities of this formalism.

From conceptual point of view, RSM behaves as set of finite state machines (or FSM), so called \textit{boxes} or \textit{component state machines}~\cite{rsm:analysis:10.1007/3-540-44585-4_18}, which are executed in classical definition of  FSM with additional \textit{recursive calls} and implicit \textit{call stack}, what allows to \textit{call} some component state machine $f_2$ from $f_1$, and then return execution flow from $f_2$ to $f_1$.

Formally, a recursive state machine $R$ over a finite alphabet $\Sigma$ is defined as tuple of elements $(M,m,\{C_i\}_{i \in M})$, where:

\begin{itemize}
    \item M is a finite set of boxes' labels
    \item m is an initial box label
    \item Set of \textit{component state machines} or \textit{boxes}, 
          where $C_i=(\Sigma \cup M, Q_i,q_i^0,F_i,\delta_i)$:
    \begin{itemize}
        \item $\Sigma \cup M$ is set of symbols, $\Sigma \cap M = \emptyset$
        \item $Q_i$ is finite set of states, 
              where $Q_i \cap Q_j = \emptyset, \forall i \neq j$
        \item $q_i^0$ is an initial state for component state machine $C_i$
        \item $F_i$ is set of final states for $C_i$, where $F_i \subseteq Q_i$
        \item $\delta_i$ is transition function for $C_i$, 
              where $\delta_i: Q_i \times (\Sigma \cup M) 
              \to Q_i$
    \end{itemize}
\end{itemize}

As an example of RSM, consider the following machine $R$ with single box $S$ for a language $\{a^n b^n~|~n \geq 1\}$, depicted in Figure~\ref{example:automata};

Semantic of the execution of such automata $R$ involves a pair of objects $(q,S)$, where $S$ is global stack of \textit{return states} from $\bigcup_{i \in M}Q_i$ such as $S=\langle ...q_r \rangle$, and $q$ is some current state of the machine, where $q \in \bigcup_{i \in M}Q_i$. The execution process starts from box $m$ initial state $q_m^0$ and empty stack as follows $(q_m^0,\langle \rangle)$. Transitions for a given global machine state $(q,S)$ to some new state $(q',S')$ are defined as follows:

Accordingly to~\cite{rsm:analysis:10.1007/3-540-44585-4_18}, recursive state machines are equivalent in the general computational capacity to pushdown systems. Since pushdown systems are capable of accepting context-free languages~\cite{automata:theory:10.5555/1177300}, it is clear to use a recursive state machine to encode some grammar $G$. 

For the sake of simplicity, we escape detailed discussion of the conversion of a context free grammar $G$ to a RSM $R$. In the basic case, an algorithm for constructing such RSM could be composed from several stages, where each stage involves building of finite state machine for each non-terminal $N$ from grammar $G$.

Since $R$ is composed from set of FSMs, it could be useful for computational tasks to represent such $R$ as a adjacency matrix, where vertices are states from $\bigcup_{i \in M}Q_i$ and edges are transitions between $q_i^a$ and $q_i^b$ with label $l \in \Sigma \cup M$, if $\delta_i (q_i^a, l) = q_i^b$. An example of such adjacency matrix $M_R$ for our machine $R$ will be provided in section~ \ref{example:section}.

\begin{itemize}
    \item $q':=q_b', S':=S$, 
    where $\delta_b (q_b,s) \to q_b', s \in \Sigma, 
    q=q_b, S = \langle ...q_r \rangle$
    \item $q':=q_t^0, S':=\langle ...q_r,q_b'\rangle$, 
    where $\delta_b (q_b,t) \to q_b', t \in M, q=q_b, S = \langle ...q_r \rangle$
    \item $q':=q_b', S':=\langle ...q_r \rangle$, 
    where $q=q_t^i, q_t^i \in F_t, S=\langle ...q_r,q_b' \rangle$
\end{itemize}

\begin{figure}[h]
    \begin{tikzpicture}[shorten >=1pt,auto]
        \node[state, initial] (q_0)   {$q_S^0$};
        \node[state] (q_1) [right=of q_0] {$q_S^1$};
        \node[state] (q_2) [right=of q_1] {$q_S^2$};
        \node[state, accepting] (q_3) [right=of q_2] {$q_S^3$};
        \path[->]
            (q_0) edge node {a} (q_1)
            (q_1) edge node {S} (q_2)
            (q_2) edge node {b} (q_3)
            (q_1) edge [bend left, above]  node {b} (q_3);
        \node[draw=black, fit= (q_0) (q_1) (q_2) (q_3), xshift=-4.5ex,inner sep=0.75cm, label=Box S] {};
    \end{tikzpicture}
    \centering
    \caption{The recursive state machine $R$ for grammar $G$}
    \label{example:automata}
\end{figure}

