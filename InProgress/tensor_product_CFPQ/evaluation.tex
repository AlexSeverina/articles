\section{Evaluation}

We implement the proposed algorithm by using SuitSparse: the \verb|C| implementation of GraphBlas API\footnote{http://graphblas.org}. GraphBlas API specifies a set of linear algenbra promitives aand operation which allows one to formulate graph algorithms using linear algebra. This tool is so flexible that it allows to change built-in operations by creating custom types and actions on them.

% To load graphs dataset,use RedisGraph \footnote{https://redislabs.com}. RedisGraph is graph database that uses GraphBlas, which allows us to combine them to obtain effective results.

We compare our implementation with results provided in~\cite{10.1145/3327964.3328503}, accordingly we use dataset described in this article. First type of graphs is RDF. This set contains real-world graphs. The second type is Worst case. The theoretical worst case for CFPQ. And last type is Full graph. The set of sparse graph, where the result is a full graph. We exclude the time required to load data from file. The time required for data transfer and its conversion is included.

For evaluation, we use a PC with Ubuntu 18.04 installed. It has Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz CPU, DDR4 32 Gb RAM.



The results of the evaluation are summarized in the table~\ref{tbl:tableRDF}.
Time is measured in seconds. The result for algorithm is averaged over 10 runs.

{\setlength{\tabcolsep}{0.4em}
\begin{table}[ht]
\centering
\caption{Evaluation results}
\label{tbl:tableRDF}
%\rowcolors{1}{}{lightgray}
\begin{tabular}{| c | p{1.6cm} | c | c | c | c || c | p{0.8cm} | c | c | c | c |}
    \hline
      &  Graph              & \#V & \#E  & $t_1$  & $t_2$ &  & Graph & \#V & \#E     & $t_1$    & $t_2$ \\
       \hline
       \hline
    \parbox[t]{2mm}{\multirow{11}{*}{\rotatebox[origin=c]{90}{RDF}}}
      & \small{atm-prim}                    & 291 & 685     & 0.24   & 0.02 & 
     \parbox[t]{2mm}{\multirow{2}{*}{\rotatebox[origin=c]{90}{RDF}}} & \small{core}                        & 1323 & 8684   & 0.28  &  0.12   \\
      & \small{biomed}                      & 341 & 711     & 0.24  & 0.05 & & \small{wine}                        & 733 & 2450    & 1.71  & 0.06      \\\cline{7-12}
      & \small{foaf}                        & 256 & 815     & 0.07  & 0.02 & 
      \parbox[t]{2mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{Worst case}}} & $WC_1$& 64 & 65 & 0.03 & 0.04      \\
      & \small{funding}                     & 778 & 1480    & 0.43  & 0.07 & & $WC_2$ & 128 & 129 & 0.16 & 0.23      \\
      & \small{generations}                 & 129 & 351     & 0.04  & 0.03 & & $WC_3$ & 256 & 257 & 0.96 & 1.94    \\
      & \small{people\_pets}                & 337 & 834     & 0.18  & 0.03 & & $WC_4$ & 512 & 513 & 7.14 & 23.21      \\
      & \small{pizza}                       & 671 & 2604    & 1.14  & 0.08 & & $WC_5$ & 1024& 1025&  121.99 & 528.52      \\ \cline{7-12}
      & \small{skos}                        & 144 & 323     & 0.02  & 0.04 & 
      \parbox[t]{2mm}{\multirow{4}{*}{\rotatebox[origin=c]{90}{Full}}} & $F_1$ & 100 & 100 & 0.17 &  0.02     \\
      & \small{travel}                      & 131 & 397     & 0.05  & 0.05 & & $F_2$ & 200 & 200 & 1.04 & 0.03        \\
      & \small{unv-bnch}                    & 179 & 413     & 0.05  & 0.04 & & $F_3$ & 500 & 500 & 18.86  & 0.03   \\
      & \small{pathways}                    & 6238 & 37196  & 4.88 &   0.18 & & $F_4$ & 1000 & 1000& 554.22 & 0.07       \\
      \hline
  \end{tabular}
\end{table}
}

The results of the first dataset \textbf{RDF} are presented in table~\ref{tbl:tableRDF}. We can see, that in this case the running time of implementation of our algorithm is bigger than of the reference implementations of matrix-based algorithm except for one implementation. At the same time, the worst result for all types of graphs in the reference article is 8 milliseconds.

Results of the theoretical worst case \textbf{Worst} are presented in table~\ref{tbl:tableWorst}. We can see, that the running time of implementation is much less than reference implementations of another algorithm on CPU-based. For example, for a graph of 1024 vertices, our algorithm shows an improvement in time of more than 4 times compared to the best CPU-based result even in the first implementation.

The last dataset is \textbf{Full}, and results are shown in table~\ref{tbl:tableFull}. As can be seen from the results, the running time increases significantly with an increase in the number of vertices, this is especially noticeable between 500 and 1000, while the worst result for a graph of 1000 vertices in the reference article is 13.071.

To sum up, our first implementation of the described algorithm outperformed implementations matrix-based algorithm in only one type of graph. Other types of graphs require implementation rework.
