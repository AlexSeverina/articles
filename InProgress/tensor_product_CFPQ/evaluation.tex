\section{Evaluation}


In this section, we introduce evaluation of implementation of described algorithm. We compare our implementation with \cite{10.1145/3327964.3328503} CPU-based results, accordingly we use dataset described in this article. First type of graphs is RDF. This set contains real-world graphs. The second type is Worst case. The theoretical worst case for CFPQ. And last type is Full graph. The set of sparse graph, where the result is a full graph. We exclude the time required to load data from file. The time required for data transfer and its conversion is included.

For evaluation, we use a PC with Ubuntu 18.04 installed. It has Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz CPU, DDR4 32 Gb RAM.

We use SuitSparse:GraphBlas \footnote{http://graphblas.org} to implement. GraphBlas is API for graph algorithms using linear algebra, respectively, using parallelism for matrix operations. This tool is so flexible that it allows to change built-in operations by creating custom types and actions on them. To load graphs dataset,use RedisGraph \footnote{https://redislabs.com}. RedisGraph is graph database that uses GraphBlas, which allows us to combine them to obtain effective results.

The results of the evaluation are summarized in the tables below.
Time is measured in seconds. The result for algorithm is averaged over 10 runs.

\begin{minipage}[t]{52mm}
{\setlength{\tabcolsep}{0.4em}
\begin{table}[H]
\centering
\caption{RDF results}
\label{tbl:tableRDF}
\rowcolors{1}{}{lightgray}
\begin{tabular}{| p{1.6cm} | c | c | c |}
    \hline
    Name                                & \#V & \#E     & Time \\
    \hline
    \hline
    \small{atm-prim}                    & 291 & 685     & 0.239425 \\
    \small{biomed}                      & 341 & 711     & 0.240378 \\
    \small{foaf}                        & 256 & 815     & 0.073081 \\
    \small{funding}                     & 778 & 1480    & 0.431305 \\
    \small{generations}                 & 129 & 351     & 0.041165 \\
    \small{people\_pets}                & 337 & 834     & 0.178783 \\
    \small{pizza}                       & 671 & 2604    & 1.137291 \\
    \small{skos}                        & 144 & 323     & 0.019502 \\
    \small{travel}                      & 131 & 397     & 0.046559 \\
    \small{unv-bnch}                    & 179 & 413     & 0.048634 \\
    \small{wine}                        & 733 & 2450    & 1.707681 \\
    \small{core}                        & 1323 & 8684   & 0.281461 \\
    \small{pathways}                    & 6238 & 37196  & 4.88529  \\
    \hline
  \end{tabular}
\end{table}
}

\end{minipage}
\hfill
\begin{minipage}[t]{27mm}

{
\begin{table}[H]
\centering
\caption{Worst case}
\label{tbl:tableWorst}
\rowcolors{1}{}{lightgray}
\begin{tabular}{| l | | c |}
    \hline
    \#V  & Time       \\
    \hline
    \hline
    
    32   & 0.010328   \\
    64   & 0.032295   \\
    128  & 0.159227   \\
    256  & 0.96474    \\
    512  & 7.13957    \\
    1024 & 121.987482 \\
    \hline
  \end{tabular}
\end{table}
}

\end{minipage}
\hfill
\begin{minipage}[t]{27mm}

\begin{table}[H]
\centering
\caption{Full graph}
\label{tbl:tableFull}
\rowcolors{1}{}{lightgray}
\begin{tabular}{| l | | c |}
    \hline
    \#V                & Time        \\
    \hline
    \hline
    100                 & 0.171031   \\
    200                 & 1.043202   \\
    500                 & 18.863558  \\
    1000                & 554.223892 \\
    \hline
  \end{tabular}
\end{table}

\end{minipage}

The results of the first dataset \textbf{RDF} are presented in table~\ref{tbl:tableRDF}. We can see, that in this case the running time of implementation of our algorithm is bigger than of the reference implementations of matrix-based algorithm except for one implementation. At the same time, the worst result for all types of graphs in the reference article is 8 milliseconds.

Results of the theoretical worst case \textbf{Worst} are presented in table~\ref{tbl:tableWorst}. We can see, that the running time of implementation is much less than reference implementations of another algorithm on CPU-based. For example, for a graph of 1024 vertices, our algorithm shows an improvement in time of more than 4 times compared to the best CPU-based result even in the first implementation.

The last dataset is \textbf{Full}, and results are shown in table~\ref{tbl:tableFull}. As can be seen from the results, the running time increases significantly with an increase in the number of vertices, this is especially noticeable between 500 and 1000, while the worst result for a graph of 1000 vertices in the reference article is 13.071.

To sum up, our first implementation of the described algorithm outperformed implementations matrix-based algorithm in only one type of graph. Other types of graphs require implementation rework.
