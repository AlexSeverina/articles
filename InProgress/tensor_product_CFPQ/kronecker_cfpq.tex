\section{Kronecker Product Based CFPQ Algorithm}

% 1. Описать вычисление тензерного произведения для булевых матриц?
% 2. Расписать определение грамматики и графа?
% 3. Kronecker = tensor product в контексте нашей задачи?
% 4. Стоит ли рассмотреть еще примеры (выигрыш, различные автоматы)?

The idea of the algorithm is based on generalisation of the finite-state machine intersection for a recursive automata, created from input grammar, and an input graph. The result of the intersection is evaluated as a tensor product of the corresponding adjacency matrices for automata and graph. To solve reachability problem it is enough to represent intersection result as a Boolean matrix, what simplifies algorithm implementation and allows to express it in terms of basic matrix operations. Listing \ref{tensor:cfpq}. shows main steps of the solution.

As an input algorithm accepts context-free grammar $G=(\Sigma,N,P$) and graph $\mathcal{G}=(V,E,L)$. Recursive automata $R$ is created from $G$. The process of the creation is out of the scope of this article. $M_1$ and $M_2$ are the adjacency matrices for automata $R$ and graph $\mathcal{G}$ correspondingly. Cell values of this matrices could be represented as sets of elements from $L \cup N \cup \Sigma$. 

The algorithm is executed while matrix $M_2$ is changing. For each iteration tensor product of matrices $M_1$ and $M_2$ is evaluated.  The result is saved in $M_3$ as a Boolean matrix. For given $M_3$ evaluated $tC_3$ matrix via $transitiveClosure()$ function call. The $M_3$ could be interpreted as an adjacency matrix for an oriented graph without labels, used to evaluate transitive closure in terms of classical graph definition of this operation. Then the algorithm iterates over cells of the $tC_3$. For pair of indices $(i,j)$ computes $s$ and $f$ - initial and final states in recursive automata $R$ which relate to the concrete $tC_3[i,j]$ of the tensor matrix. Function $hasPathForNonterminals()$ checks whether for given $s$ and $f$ states automata has at least one non-terminal path. If the conditional statement is $true$ then algorithm adds non-terminals of that path via $getNonterminals()$ to the concrete cell of the adjacency matrix $M_2$ of the graph.

As an result the algorithm returns updated matrix $M_2$ which contains initial graph $\mathcal{G}$ data and non-terminals from $N$. If a cell $M_2[i,j]$ for any valid indices $i$ and $j$ contains symbol $S \in N$, therefore, vertex $j$ is reachable from vertex $i$ in grammar $G$ for non-terminal $S$. 

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Kronecker product based CFPQ}
\label{tensor:cfpq}
\Function{contextFreePathQuerying}{G, $\mathcal{G}$}
    \State{$R \gets$ Recursive automata for $G$}
    \State{$M_1 \gets$ Adjacency matrix for $R$}
    \State{$M_2 \gets$ Adjacency matrix for $\mathcal{G}$}
    \While{Matrix $M_2$ is changing}
        \State{$M_3 \gets M_1 \otimes M_2$}
        \Comment{Evaluate tensor product}
        \State{$tC_3 \gets \textit{transitiveClosure}(M_3)$}
        \State{$n \gets$ Matrix $M_3$ dimension}
        \Comment{Matrix $M_3$ size = $n \times n$}
        \For{$i \in 0..n-1$}
           \For{$j \in 0..n-1$}
                \If{$tC_3[i,j]$}
                    \State{$s \gets$ initial vertex of the edge $tC_3[i,j]$}
                    \State{$f \gets$ final vertex of the edge $tC_3[i,j]$}
                    \If{$hasPathForNonterminals(R,s,f)$}
                        \State{$x, y \gets getCoordinates(tC_3,i,j)$}
                        \State{$M_2[x,y] \gets M_2[x,y] \cup getNonterminals(R,s,f)$}
                    \EndIf
                \EndIf
           \EndFor
        \EndFor
    \EndWhile
\State \Return $M_2$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Remarks}
\label{section:remarks}

% Про eps обязательно надо написать, так как это весьма болезненная тема?
% Здесь стоит посмотреть еще раз, не бред ли получился?
% Почему алгоритм завершается - надо написать? Про сложность надо пояснить?

\begin{itemize}
    \item Mentioned above algorithm description does not take into account the use of $\epsilon$-transitions in the automata $R$. This transitions might appear in the automata if the grammar allows to derive $\epsilon$-word for some non-terminal. In this case there is required additional step for matrix $M_2$ before the $while$ loop is entered. For each $i \in 0..dim(M_2)-1$ symbol $\epsilon$ must be explicitly added for $M_2[i,i]$ as follows: $M_2[i,i] \gets M_2[i,i] \cup \{\epsilon\}$. Here the rule is implied: each vertex of the graph $\mathcal{G}$ is reachable by itself through $\epsilon$-transition. 
    \item The performance-critical part of the algorithm is transitive closure computation. Generally this step requires $O(n^{3})$ operations and $O(n^{2})$ memory where $n$ is dimension of $M_3$ what equals $dim(M_1) \times dim(M_2)$.
\end{itemize}{}

\subsection{Example}

This section is intended to provide step-by-step demonstration of the proposed algorithm. As an example query consider the following context-free grammar $G=(\Sigma,N,P)$ for a language $\{a^n b^n | n \geq 1\}$ where:

\begin{itemize}
    \item Set of terminals $\Sigma = \{a, b\}$.
    \item Set of non-terminals $V = \{ S \}$.
    \item Set of production rules $P = \{ S \to a S b, S \to a b\}$.
\end{itemize}

Since the proposed algorithm processes grammar in form of recursive automata, we first provide automata $R$ in Figure \ref{input:automata}. The initial state of the automata is $(0)$, the final state is $(3)$. The notation $\{S\}$ denotes here that non-terminal $S$ could be derived in automata path from vertex $(0)$ to $(3)$.

% Proper alignment for figures?

\begin{figure}[h]
     \begin{tikzpicture}[shorten >=1pt,auto] 
           \node[state, initial] (q_0)   {$0 \{S\}$}; 
           \node[state] (q_1) [right=of q_0] {$1$}; 
           \node[state] (q_2) [right=of q_1] {$2$}; 
           \node[state, accepting] (q_3) [right=of q_2] {$3\{S\}$};
            \path[->] 
            (q_0) edge node {a} (q_1)          
            (q_1) edge node {S} (q_2)
            (q_2) edge node {b} (q_3)
            (q_1) edge [bend left, above]  node {b} (q_3);
    \end{tikzpicture}
    \centering
    \caption{The recursive automata $R$ of grammar $G$ for example query}
    \label{input:automata}
\end{figure}

For this example we run query on graph $\mathcal{G}$ presented in Figure \ref{input:graph}. This graph consists of 4 vertices and 5 edges with labels.

\begin{figure}[h]
        \centering
        \begin{tikzpicture}[shorten >=1pt,auto] 
           \node[state] (q_0)                      {$0$}; 
           \node[state] (q_1) [above right=of q_0] {$1$}; 
           \node[state] (q_2) [right=of q_0]       {$2$}; 
           \node[state] (q_3) [right=of q_2]       {$3$};
            \path[->] 
            (q_0) edge  node {a} (q_1)          
            (q_1) edge  node {a} (q_2)
            (q_2) edge  node {a} (q_0)
            (q_2) edge[bend left, above]  node {b} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
        \end{tikzpicture}
        \caption{The input graph $\mathcal{G}$ for example query}
        \label{input:graph}
\end{figure}

Adjacency matrices for automata $R$ and graph $\mathcal{G}$ are initialised as depicted in Figure \ref{example:init}.

\begin{figure}
    \centering
    $$
    M_1 =
    \begin{pmatrix}
    . & . & \{a\} & .     \\
    . & . & \{S\} & \{b\} \\
    . & . & . & \{b\}     \\
    . & . & . & . 
    \end{pmatrix}
    M_2^0 =
    \begin{pmatrix}
    . & \{a\} & . & .     \\
    . & . & \{a\} & .     \\
    \{a\} & . & . & \{b\} \\
    . & . & \{b\} & . 
    \end{pmatrix}
    $$
    \caption{Adjacency matrices $M_1$ for $R$ and $M_2$ for $\mathcal{G}$}
    \label{example:init}
\end{figure}

Because automata $R$ does not have $\epsilon$-transitions and $\epsilon$-word is not included in grammar $G$ language, we can skip additional step for matrix $M_2$ mentioned in section \ref{section:remarks}.

After all the data is initialised in lines \textbf{2-4} of the algorithm, it enters while loop and iterates as long as matrix $M_2$ is changing. We provide step-by-step evaluation of matrices $M_3$, $tC_3$ and updating of matrix $M_2$. All the matrices are denoted with upper index of the current loop iteration. The first loop iteration is indexed as 1.
    
For the first while loop iteration the tensor product $M_3^1 = M_1 \otimes M_2^0$ and transitive closure $tC_3^1$ are evaluated as shown in Figure \ref{example:iteration1eval}. The dimension $n$ of the matrix $M_3$ equals 16, and this value is constant in time of the algorithm execution. 
    
\begin{figure}
    \centering
    $$
    M_3^1 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & .   \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    tC_3^1 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & \textbf{1} \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    $$
    \caption{The first iteration tensor product and transitive closure evaluation for example query}
    \label{example:iteration1eval}
\end{figure}

After the transitive closure evaluation matrix $tC_3^1$ cell $(1,15)$ contains non-zero value. It means that vertex with index $15$ is accessible from vertex with index $1$ in a graph, represented by adjacency matrix $M_3^1$.

Then the algorithm lines \textbf{9-16} are executed. In that section algorithm adds non-terminals to the graph matrix $M_2^1$. Because this step is additive we are only interested in newly appeared values in matrix $tC_3^1$ such as value $tC_3^1[1,15]$.
    
For the value $tC_3^1[1,15]$:
\begin{itemize}
    \item Indices of the automata vertices $s = 0$ and $f = 3$, because value $tC_3^1[1,15]$ located in upper right matrix block $(0,3)$.
    \item Indices of the graph vertices $x = 1$ and $y = 3$ are evaluated as 
    value $tC_3^1[1,15]$ indices relatively to its block $(0,3)$.
    \item Function call $hasPathForNonterminals()$ returns \textbf{true} since the automata $R$ has path for non-terminal $S$ from vertex $0$ to $3$.
    \item Function call $getNonterminals()$ returns $\{S\}$ since this is the only non-terminal which could be derived in path from vertex $0$ to $3$. 
\end{itemize}{}

\begin{figure}[h]
    \begin{subfigure}[]{0.5\textwidth}
    \centering
    $$
    M_2^1 =
    \begin{pmatrix}
    . & \{a\} & . & .     \\
    . & . & \{a\} & \{S\} \\
    \{a\} & . & . & \{b\} \\
    . & . & \{b\} & . 
    \end{pmatrix}
    $$
    \end{subfigure}
    \begin{subfigure}[]{0.4\textwidth}
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto] 
           \node[state] (q_0)                      {$0$}; 
           \node[state] (q_1) [above right=of q_0] {$1$}; 
           \node[state] (q_2) [right=of q_0]       {$2$}; 
           \node[state] (q_3) [right=of q_2]       {$3$};
            \path[->] 
            (q_0) edge  node {a} (q_1)          
            (q_1) edge  node {a} (q_2)
            (q_1) edge[bend left, above]  node {\textbf{S}} (q_3)
            (q_2) edge  node {a} (q_0)
            (q_2) edge[bend left, above]  node {b} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    \end{subfigure}
    \caption{The updated matrix $M_2^1$ and graph $\mathcal{G}$ after first loop iteration for example query}
    \label{example:iteration1res}
\end{figure}

After the first loop iteration matrix symbol $S$ is added to the cell $M_2^1[1,3]$. It is relevant data, because initial graph has path $1 \to 2 \to 3$ which could be derived for $S$. The updated matrix and graph are depicted in figure \ref{example:iteration1res}.

For the second loop iteration matrices $M_3^2$ and $tC_3^2$ are evaluated as listed in figure \ref{example:iteration2eval}. For this iteration in the matrix $tC_3^2$ appeared new non-zero values in cells with indices $[0,11]$, $[0,14]$ and $[5,14]$. Because only the cell value with index $[0,14]$ corresponds to the automata path with not empty non-terminal set $\{S\}$
its data affects adjacency matrix $M_2$. The update matrix and graph $\mathcal{G}$ are depicted in figure~\ref{example:iteration2res}. 

\begin{figure}
    \centering
    $$
    M_3^2 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .           &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & \textbf{1}  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .           &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .           &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & .   \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    tC_3^2 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & \textbf{1}  &  . & . & \textbf{1} & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & \textbf{1} & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    $$
    \caption{The second iteration tensor product and transitive closure evaluation for example query}
    \label{example:iteration2eval}
\end{figure}

\begin{figure}
    \begin{subfigure}[]{0.5\textwidth}
    \centering
    $$
    M_2^2 =
    \begin{pmatrix}
    .     & \{a\} & \{S\} & .     \\
    .     & .     & \{a\} & \{S\} \\
    \{a\} & .     & .     & \{b\} \\
    .     & .     & \{b\} & . 
    \end{pmatrix}
    $$
    \end{subfigure}
    \begin{subfigure}[]{0.4\textwidth}
    \centering
    \begin{tikzpicture}[shorten >=1pt,auto] 
           \node[state] (q_0)                      {$0$}; 
           \node[state] (q_1) [above right=of q_0] {$1$}; 
           \node[state] (q_2) [right=of q_0]       {$2$}; 
           \node[state] (q_3) [right=of q_2]       {$3$};
            \path[->] 
            (q_0) edge  node {a} (q_1)          
            (q_1) edge  node {a} (q_2)
            (q_1) edge[bend left, above]  node {S} (q_3)
            (q_2) edge  node {a} (q_0)
            (q_0) edge[bend right, below]  node {\textbf{S}} (q_2)
            (q_2) edge[bend left, above]  node {b} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    \end{subfigure}
    \caption{The updated matrix $M_2^2$ and graph $\mathcal{G}$ after second loop iteration for example query}
    \label{example:iteration2res}
\end{figure}

The remaining matrices $tC_3$ and $M_2$ for the algorithm main loop execution are listed in the figure~\ref{example:iteration3to6eval} and figure~\ref{example:iteration3to6res} correspondingly. For the sake of simplicity evaluated matrices $M_3$ are not included because its computation is a straightforward process. The last loop iteration is $7$. Although the matrix $M_2^6$ is updated with new non-terminal $S$ for the cell $[2,2]$ after transitive closure evaluation the new values to the matrix $M_2$ is not added. Therefore matrix $M_2$ has stopped changing and the algorithm is successfully finished. 

For the example query algorithm takes $7$ iterations for the $while-loop$. The updated graph $\mathcal{G}$ is depicted in the figure~\ref{example:result}.

\begin{figure}
    \centering
    $$
    tC_3^3 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & \textbf{1} & .  &  . & . & . & \textbf{1} \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & .  &  . & . & . & \textbf{1} \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    tC_3^4 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & \textbf{1}  &  . & . & \textbf{1} & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & \textbf{1} & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    $$
    $$
    tC_3^5 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & \textbf{1} & 1  &  . & . & 1 & \textbf{1} \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & 1  &  . & . & 1 & \textbf{1} \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    tC_3^6 = 
    \left(
    \begin{array}{c c c c | c c c c | c c c c | c c c c } 
    . & . & . & .  &  . & 1 & . & .  &  . & . & 1 & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & 1 & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  1 & . & . & .  &  . & . & 1 & \textbf{1}  &  . & . & \textbf{1} & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & 1  &  . & . & \textbf{1} & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & 1 & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & 1  &  . & . & 1 & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & 1 \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & 1 & . \\
    \hline
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . \\
    . & . & . & .  &  . & . & . & .  &  . & . & . & .  &  . & . & . & . 
    \end{array}
    \right)
    $$
    \caption{Transitive closure for $3-6$ loop iterations for example query}
    \label{example:iteration3to6eval}
\end{figure}{}

\begin{figure}
    \centering
    $$
    M_2^3 =
    \begin{pmatrix}
    .     & \{a\} & \{S\} & .       \\
    .     & .     & \{a\} & \{S\}   \\
    \{a\} & .     & .     & \{b,S\} \\
    .     & .     & \{b\} & . 
    \end{pmatrix}
    M_2^4 =
    \begin{pmatrix}
    .     & \{a\} & \{S\}   & .       \\
    .     & .     & \{a,S\} & \{S\}   \\
    \{a\} & .     & .       & \{b,S\} \\
    .     & .     & \{b\}   & . 
    \end{pmatrix}
    $$
    $$
    M_2^5 =
    \begin{pmatrix}
    .     & \{a\} & \{S\}   & \{S\}   \\
    .     & .     & \{a,S\} & \{S\}   \\
    \{a\} & .     & .       & \{b,S\} \\
    .     & .     & \{b\}   & . 
    \end{pmatrix}
    M_2^6 =
    \begin{pmatrix}
    .     & \{a\} & \{S\}   & \{S\}   \\
    .     & .     & \{a,S\} & \{S\}   \\
    \{a\} & .     & \{S\}   & \{b,S\} \\
    .     & .     & \{b\}   & . 
    \end{pmatrix}
    $$
    \caption{The updated matrix $M_2$ for $3-6$ loop iterations for example query}
    \label{example:iteration3to6res}
\end{figure}{}

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[shorten >=1pt,auto] 
        \node[state] (q_0)                      {$0$}; 
        \node[state] (q_1) [above right=of q_0] {$1$}; 
        \node[state] (q_2) [right=of q_0]       {$2$}; 
        \node[state] (q_3) [right=of q_2]       {$3$};
          \path[->] 
            (q_0) edge  node {a} (q_1)          
            (q_1) edge  node {a,S} (q_2)
            (q_2) edge[bend right, above]  node {a} (q_0)
            (q_2) edge[loop right]  node {S} (q_2)
            (q_1) edge[bend left, above]  node {S} (q_3)
            (q_0) edge[bend right, above]  node {S} (q_2)
            (q_2) edge[bend left, above]  node {b,S} (q_3)
            (q_0) edge[bend right, below]  node {S} (q_3)
            (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    \end{center}{}
    \caption{The result graph $\mathcal{G}$ for example query}
    \label{example:result}
\end{figure}{}
