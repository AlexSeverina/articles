\section{Introduction}

% CFPQ is popular and widely used for !!!.
% Matrices~\cite{Azimov:2018:CPQ:3210259.3210264} --- algorithm is fast, but grammar size is problem.
% Moreover, bad for regualr queryes.
% In adition, Kuipers says that existing algorithms are not applicable for real-world problems. So we should develop new ones.

Language-constrained querying, and particularly context-free path querying, allows one to express path constraints for a graph in terms of context-free grammars: path in graph from some vertex to another included to result query only if concatenated set o labels along this path belongs to the language, generated by query grammar. CFPQ is widely used in bioinformatics, graph databases, RDF and network analysis. 

The algorithm, proposed by Rustam Azimov \cite{Azimov:2018:CPQ:3210259.3210264}, 
allows to solve this kind of problem in terms of \textit{relational query semantics} \cite{Hellings2014ConjunctiveCP} and \textit{single-path query semantics} \cite{hellings2015querying}. Although this algorithm has significant computational performance, a number of production rules for a grammar is still a problem, since it is processed in form of Chomsky Normal Form (CNF). Also this algorithm does not take into account regular queries, since they must be expressed as CNF.

In this work, we address the problem of creating a new algorithm, expressed in terms of matrix operations, which can utilise expressive power of regular expressions as well as accept context-free queries, and also provide some space for future query optimisations.

Main contribution of this paper could be summarised as follows:

\begin{enumerate}
\item We introduce an algorithm, applicable for both context-free and regular queries, which is based on recursive state machines intersection, Kronecker product and transitive closure evaluation.
\item We provide an example of the algorithm computation.
\item We provide an evaluation results of the algorithm implementation and its comparison with matrix based algorithm. 
\end{enumerate}

