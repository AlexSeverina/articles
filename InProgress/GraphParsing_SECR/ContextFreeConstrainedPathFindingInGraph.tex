\documentclass[sigconf]{acmart}

\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{mathtools}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{textcomp}



%\usepackage{booktabs} % For formal tables


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[SECR'17]{Software Engineering Conference Russia}{October 2017}{St. Petersburg, Russia} 
\acmYear{2017}
\copyrightyear{2017}

%\acmPrice{15.00}


\begin{document}

\newtheorem{mytheorem}{Theorem}

\algrenewcommand\algorithmicindent{0.5em}
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}

\algtext*{EndSwitch}
\algtext*{EndCase}
\algtext*{EndWhile}% Remove "end while" text
\algtext*{EndIf}% Remove "end if" text
\algtext*{EndFor}% Remove "end for" text
\algtext*{EndFunction}% Remove "end function" text

\newif\ifboldnumber
\newcommand{\boldnext}{\global\boldnumbertrue}

% Default definition is \footnotesize#1:
\algrenewcommand\alglinenumber[1]{%
  \footnotesize\ifboldnumber\bfseries\fi\global\boldnumberfalse#1:}


\title{Context-Free Path Querying with Structural Representation of Result}
%\titlenote{Produces the permission block, and
%  copyright information}
%\subtitle{Extended Abstract}
%\subtitlenote{The full version of the author's guide is available as
%  \texttt{acmart.pdf} document}


\author{Semyon Grigorev}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7/9 Universitetskaya nab.}
  \city{St. Petersburg} 
  \state{Russia} 
  \postcode{199034}
}
\email{semen.grigorev@jetbrains.com}

\author{Anastasiya Ragozina}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7/9 Universitetskaya nab.}
  \city{St. Petersburg} 
  \state{Russia} 
  \postcode{199034}
}
\email{ragozina.anastasiya@gmail.com}


% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
Graph data model and graph databases are popular in such areas as bioinformatics, semantic web, and social networks.
One specific problem in the area is a path querying with constraints formulated in terms of formal grammars.
The query in this approach is written as a grammar and paths querying is graph parsing with respect to the grammar.
There are several solutions to it, but they are based mostly on CYK or Earley algorithms which impose some restrictions in comparison with other parsing techniques, and employing of advanced parsing techniques for graph parsing is still an open problem.
In this paper we propose a graph parsing technique which is based on generalized top-down parsing algorithm (GLL) and allows one to build finite structural query result representation with respect to the given grammar in polynomial time and space for arbitrary context-free grammar and graph.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10002951.10002952.10002953.10010146</concept_id>
<concept_desc>Information systems~Graph-based database models</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10002951.10002952.10003197.10010825</concept_id>
<concept_desc>Information systems~Query languages for non-relational engines</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10003766.10003771</concept_id>
<concept_desc>Theory of computation~Grammars and context-free languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011041.10011688</concept_id>
<concept_desc>Software and its engineering~Parsers</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Graph-based database models}
\ccsdesc[500]{Information systems~Query languages for non-relational engines}
\ccsdesc[300]{Theory of computation~Grammars and context-free languages}
\ccsdesc[300]{Software and its engineering~Parsers}

\keywords{Graph database, path query, graph parsing, context-free grammar, top-down parsing, GLL, LL}

%\acmBadgeR{artifacts_available}

\maketitle

\section{Introduction}
Graph data model and graph data bases are very popular in such areas as bioinformatics, semantic web, and social networks.
Hence, different graph structured data analysis problems are stated and appropriate solutions for these problems are required.
%Extraction of paths which satisfy specific constraints may be useful for investigation of graph structured data and for detection of relations between data items.
One specific problem---path querying with constraints---is usually formulated in terms of formal grammars and is called formal language constrained path problem~\cite{FLCpathProblem}.

Classical parsing techniques can be used to solve formal language constrained path problem and thus the more common problem---graph parsing. 
Graph parsing may be required in graph data base querying, formal verification, string-embedded language processing, and any other areas where graph structured data is used. 

%Though constrains formulated in terms of regular languages is widely used, using of more powerful context-free grammars for graph querying is in active research: recent results is context-free extension for SPARQL~\cite{CFGonRDF} and research of Jelle Hellings~(\cite{Hellings16,ConjCFPathQuery}).

Existing solutions in context-free graph querying field usually employ such parsing algorithms as CYK or Earley~(for example~\cite{ConjCFPathQuery,CFGonRDF,GraphQueryWithEarley}). 
These algorithms are simple, but impose restrictions.
For example, CYK algorithm demands the input grammar to be transformed into Chomsky normal form causing performance issues, since parsing time depends on grammar size which significantly increases during the transformation.
Such algorithms as GLR and GLL process arbitrary context-free grammars, thus performance may be improved by employing them for graph parsing problem.
%Moreover, Earley-based graph parsing algorithm, which proposed in~\cite{GraphQueryWithEarley}, has restrictions on processing graphs with cycles: it is required to specify maximal length of path for parsing termination.
Other properties of parsing algorithms also affect performance: for example, in~\cite{Hellings16} author expects that it is possible to improve evaluation of queries for a given pair of nodes by using top-down directed parsing algorithm.
Both CYK and Earley parsing algorithms are bottom-up, CYK is undirected, and Earley-based implementation~\cite{GraphQueryWithEarley} is known to have issues with cycles processing. 
In this paper we show this assumption is true.
We also provide a positive answer to the question of applicability of advanced parsing techniques stated in~\cite{Hellings16}.
%The applicability of advanced parsing techniques~\cite{Grune} for path querying is stated as an open question in~\cite{Hellings16} and we provide positive answer to it.

Even though a set of path querying solutions has been developed~\cite{GraphQueryWithEarley,ConjCFPathQuery,QueryGraphWithData,RegularDBQuery}, query result exploration is still a challenge~\cite{hofman2015separabilityForRegQueryDebugging}, as also there is a need for simplification of complex query debugging, especially for context-free queries.
In~\cite{Hellings16}, annotated grammars are proposed as a possible solution: this representation is finite for any input data and contains information necessary for detailed result exploration.
In the paper we propose the representation more native for grammar based analysis, provided by classical parsing techniques---derivation tree---which contains exhaustive information about parsed sentence structure in terms of specified grammar.

We make the following contributions in this paper.
\begin{enumerate}
\item We propose the graph parsing algorithm based on the generalized top-down parsing algorithm---GLL~\cite{scott2010gll}---and provide its time and space complexity estimations. 
For graph $M=(V,E,L)$, space complexity is $O(|V|^3 + |E|)$ and time complexity is $O\left(|V|^3*\max\limits_{v \in V}\left(deg^+\left(v\right)\right)\right)$.
\item We answer some questions on advanced parsing techniques applicability for graph processing stated in~\cite{Hellings16}.
%Questions on possibility of advanced parsing techniques application for graph processing, and on possibility of top-down algorithms utilization for  answering queries for a given pair of nodes are stated in~\cite{Hellings16}.
%We show that all of these are possible.
%Thus we answer on first and second questions which are stated in~\cite{Hellings16}: yes, we can use advanced parsing techniques for graph parsing, and we can use top-down parsing algorithm for goal-oriented queries evaluation.
\item Proposed graph parsing algorithm constructs finite representation of parse forest containing derivation trees for all matched paths in graph. We show how this representation can be used for realistic problems solving.
\item We have implemented the proposed algorithm and our evaluation shows that advanced parsing techniques increase performance (up to 1000 times in some cases) as compared to CYK-based implementation, proposed in~\cite{CFGonRDF}.
\end{enumerate}

\input{Preliminaries.tex}
\input{Gll.tex}
\input{Complexity.tex}
\input{MotivExample.tex}
\input{Evaluation.tex}
\input{Conclusion.tex}
\input{Acknowledgments.tex}


\bibliographystyle{ACM-Reference-Format}
\bibliography{ContextFreeConstrainedPathFindingInGraph} 

\end{document}
