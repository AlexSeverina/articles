% Use:
% pdflatex conj_path_querying
% biber conj_path_querying
% pdflatex conj_path_querying
\documentclass [a4paper] {article}

% ----------------------------------------------------------------
% Required packages

\usepackage [T2A] {fontenc}
\usepackage [utf8] {inputenc}
\usepackage [english, russian] {babel}
\usepackage{mathtools}

\usepackage {url}
\usepackage [style = gost-numeric,backend=biber] {biblatex}

% ----------------------------------------------------------------
% Optional packages

\usepackage {lipsum}

\addbibresource {conj_path_querying.bib}

\begin{document}
	\title{Синтаксический анализ графов с использованием конъюнктивных грамматик}
	\author{
		Азимов~Р.\,Ш., \\ \url {rustam.azimov19021995@gmail.com}, \\
		Санкт-Петербургский государственный университет, \\
		Лаборатория языковых инструментов JetBrains 
	}
	
	\maketitle
	
	\begin{abstract}
		Графы используются в качестве структуры данных во многих областях, например, биоинформатика, графовые базы данных. В этих областях часто необходимо вычислять некоторые запросы к большим графам. Ответом на такие запросы обычно является множество всех троек $(A, m, n)$, для которых существует путь в графе от вершины $m$ до вершины $n$ такой, что метки на ребрах этого пути образуют строку, выводимою из нетерминала данной контекстно-свободной грамматики $A$. Говорят, что такой тип запросов вычислен с использованием \textit{реляционной семантики запросов}. Кроме того, существуют \textit{конъюнктивные грамматики}, образующие более широкий класс грамматик, чем контекстно-свободные. Использование конъюнктивных грамматик в задаче синтаксического анализа графов позволит формулировать более сложные запросы к графу и решать более широкий круг задач. Известно, что задача вычисления запросов к графу с использованием реляционной семантики и конъюнктивных грамматик --- неразрешима. В данной работе будет предложен алгоритм, вычисляющий приближенное решение данной задачи, а именно аппроксимацию сверху множества троек $(A, m, n)$. Предложенный алгоритм основан на матричных операциях, что позволяет повысить производительность, используя вычисления на графическом процессоре.
		
		\vspace{1em}
		\textbf{Ключевые слова: синтаксический анализ графов, конъюнктивные грамматики, транзитивное замыкание, матричные операции, вычисления на GPU}  
	\end{abstract}
	
	\section{Введение}
	Графы используются в качестве структуры данных во многих областях, например, биоинформатика~\cite{Bio}, графовые базы данных~\cite{graphDB}. В этих областях часто необходимо вычислять некоторые запросы к большим графам. Одними из наиболее распространенных запросов к графам являются навигационные запросы. Результатом вычисления таких запросов является множество неявных отношений между вершинами графа, то есть путей в графе. Естественно выделять такие отношения --- пометив ребра графа символами из некоторого конечного алфавита и выделив необходимые пути в графе с помощью формальных грамматик (регулярные выражения, контекстно-свободные грамматики) над тем же алфавитом. Наиболее популярны запросы, использующие контекстно-свободные грамматики, так как КС-языки обладают большей выразительной мощностью, чем регулярные.
	
		
	Также существуют \textit{конъюнктивные грамматики}~\cite{okhotin2001conjunctive}, образующие более широкий класс грамматик, чем контекстно-свободные. Использование конъюнктивных грамматик в задаче синтаксического анализа графов позволит формулировать более сложные запросы к графу и решать более широкий круг задач. Известно, что задача вычисления запросов к графу с использованием реляционной семантики и конъюнктивных грамматик --- неразрешима~\cite{hellingsRelational}. Один из распространенных способов найти приближенное решение неразрешимой задачи --- найти аппроксимацию решения (сверху или снизу).
	
	В данной работе будет предложен алгоритм, вычисляющий приближенное решение задачи синтаксического анализа графов с использованием реляционной семантики запросов и конъюнктивных грамматик, а именно аппроксимацию сверху множества троек $(A, m, n)$. Предложенный алгоритм основан на матричных операциях, что позволяет повысить производительность, используя для вычислений графический процессор.
	
	\section{Обзор}
	В этом разделе мы определим задачу синтаксического анализа графов и обсудим основные подходы, применяемые для ее решения.
	
	Пусть $\Sigma$ --- конечное множество терминальных символов. \textit{Помеченным графом} будем называть пару $D = (V, E)$, где $V$ является множеством вершин, а $E \subseteq V \times \Sigma \times V$ --- множеством ребер с метками из алфавита $\Sigma$. Для пути $\pi$ в графе $D$ мы будем использовать $l(\pi)$ для обозначения слова, полученного конкатенацией меток на ребрах данного пути. Кроме того, мы будем писать $m \pi n$, чтобы указать, что существует путь из вершины $m \in V$ в вершину $n \in V$.
	
	Результатом работы алгоритма синтаксического анализа графов с использованием формальной грамматики $G$ обычно является множество всех троек $(A, m, n)$, для которых $m \pi n$ такой, что строка $l(\pi)$ выводима из нетерминала $A$ грамматики $G$. Говорят, что такой тип запросов вычислен с использованием \textit{реляционной семантики запросов}~\cite{hellingsRelational}. 
	
	Традиционно использовали регулярные выражения в качестве грамматики $G$. Но в последнее время стало популярным использовать КС-грамматики, так как некоторые полезные запросы не могут быть описаны с помощью регулярных грамматик. Примером таких запросов являются классические запросы поиска всех вершин в графе, находящихся на одном уровне иерархии~\cite{FndDB}. Рассмотренные алгоритмы синтаксического анализа графов принимают на вход КС-грамматики в \textit{нормальной форме Хомского}~\cite{chomsky}.
	
	Существует ряд алгоритмов синтаксического анализа графов с использованием реляционной семантики запросов и КС-грамматик~\cite{hellingsRelational, RDF, GraphQueryWithEarley}, которые основаны на методе динамического программирования. Данные алгоритмы обобщают такие алгоритмы синтаксического анализа, как CYK~\cite{kasami, younger} и Earley~\cite{Grune}. В работе~\cite{hellingsRelational} для заданного графа $D = (V, E)$ и КС-грамматики $G = (N, \Sigma, P)$, определяются \textit{контекстно-свободные отношения} $R_A \subseteq V \times V$ для каждого $A \in N$ следующим образом: $$R_A = \{(n,m)~|~\exists n \pi m~(l(\pi) \in L(G_A))\}.$$
	
	Вся работа алгоритма~\cite{hellingsRelational} сводится к вычислению контекстно-свободных отношений $R_A$ для каждого $A \in N$. Кроме того, существует алгоритм синтаксического анализа графов с использование реляционной семантики запросов и КС-грамматик, вычисляющий данные контекстно-свободные отношения $R_A$ используя матричное транзитивное замыкание~\cite{azimov2018context}. Данный алгоритм обобщает алгоритм Вэлианта~\cite{valiant} и сводится к ряду умножений Булевых матриц.
	
	Также существуют \textit{конъюнктивные грамматики}~\cite{okhotin2001conjunctive}, образующие более широкий класс грамматик, чем контекстно-свободные. Как и в случае КС-грамматик мы рассматриваем только конъюнктивные грамматики в бинарной нормальной форме~\cite{okhotinConjAndBool}. Мы не выделяем стартовый нетерминал, так как его можно будет определить во время синтаксического анализа графа. Так как для каждой конъюнктивной грамматики можно построить эквивалентную ей грамматику в бинарной нормальной форме, то достаточно рассмотреть только грамматики следующего вида.
	
	\textit{Конъюнктивная грамматика} --- это тройка $G = (N, \Sigma, P)$, где $N$ --- конечное множество нетерминальных символов, $\Sigma$ --- конечное множество терминальных символов и $P$ --- конечное множество правил следующего типа:
	
	\begin{itemize}
		\item $A \rightarrow B_1 C_1~\& \ldots \&~B_m C_m$, for $m \geq 1$, $A,B_i,C_i \in N$,
		\item $A \rightarrow x$, for $A \in N$ and $x \in \Sigma$.   
	\end{itemize}

	Мы будем использовать запись $A \xrightarrow{*} w$, чтобы указать, что строка $w \in \Sigma^*$ может быть получена из нетерминала $A$ некоторой последовательностью применений правил конъюнктивной грамматики, где отношение $\rightarrow$ определено следующим образом:
	\begin{itemize}
		\item При применении правила $A \rightarrow B_1 C_1~\& \ldots \&~B_m C_m \in P$, любой подтерм $A$ любого терма может быть перезаписан подтермом $(B_1 C_1 ~\& \ldots \&~ B_m C_m)$:
		\begin{center}
			$\ldots A \ldots \rightarrow \ldots (B_1 C_1~\& \ldots \&~B_m C_m) \ldots$
		\end{center}
		\item Конъюнкция нескольких одинаковых строк из $\Sigma^*$ может быть перезаписана одной такой строкой: для любого $w \in \Sigma^*$,
		\begin{center}
			$\ldots (w~\& \ldots \&~w) \ldots \rightarrow \ldots w \ldots$
		\end{center}
	
	\end{itemize}
	
	\textit{Языком}, сгенерированным конъюнктивной грамматикой $G = (N,\Sigma,P)$ со стартовым нетерминалом $S \in N$, будем называть $$L(G_S) = \{w \in \Sigma^*~|~S \xrightarrow{*} w\}.$$
	
	
	\section{Существующие работы}
	
	Ряд алгоритмов синтаксического анализа графов с использованием реляционной семантики запросов и КС-грамматик~\cite{hellingsRelational, RDF, GraphQueryWithEarley} демонстрируют низкую производительность на больших графах. Одной из самых популярных техник, используемых для увеличения производительности при работе с большими объемами данных, является использование графического процессора для вычислений, но перечисленные алгоритмы не позволяют эффективно применить данную технику.
	
	Алгоритм синтаксического анализа графов с использование реляционной семантики запросов и КС-грамматик, вычисляющий матричное транзитивное замыкание~\cite{azimov2018context} активно использует матричные операции и позволяет эффективно использовать вычисления на графическом процессоре ~\cite{matricesOnGPGPU}. 
	
	
	\section{Определения}
	
	For a given graph $D = (V, E)$ and a conjunctive grammar $G = (N, \Sigma, P)$, we define \textit{conjunctive relations} $R_A \subseteq V \times V$, for every $A \in N$, such that $R_A = \{(n,m)~|~\exists n \pi m~(l(\pi) \in L(G_A))\}$.
	
	We define a \textit{conjunctive matrix multiplication}, $a \circ b = c$, where $a$ and $b$ are matrices of the suitable size that have subsets of $N$ as elements, as $c_{i,j} = \{A~|~\exists (A \rightarrow B_1 C_1~\& \ldots \&~B_m C_m) \in P \text{ such that } (B_k, C_k) \in d_{i,j} \}$, where $d_{i,j} = \bigcup^{n}_{k=1}{a_{i,k} \times b_{k,j}}$. 
	
	We define the \textit{conjunctive transitive closure} of a square matrix $a$ as $a^{conj} = a^{(1)} \cup a^{(2)} \cup \cdots$ where $a^{(i)} = a^{(i-1)} \cup (a^{(i-1)} \circ a^{(i-1)})$, $i \ge 2$ and $a^{(1)} = a$.
	
	Также определим бинарную операцию $(~\cdot~)$ на произвольных подмножествах $N_1 , N_2$ множества нетерминальных символов $N$ грамматики $G = (N, \Sigma, P)$ следующим образом: $$N_1 \cdot N_2 = \{A~|~\exists B \in N_1, \exists C \in N_2 \text{ such that }(A \rightarrow B C) \in P\}.$$

	Используя операцию $(~\cdot~)$ в качестве операции умножения подмножеств множества $N$ и объединение в качестве сложения, мы можем определить \textit{матричное умножение}, $a \times b = c$, где $a$ и $b$ --- матрицы подходящего размера, элементы которых являются подмножествами множества $N$, следующим образом: $$c_{i,j} = \bigcup^{n}_{k=1}{a_{i,k} \cdot b_{k,j}}.$$

	Также мы определим \textit{матричное транзитивное замыкание} квадратной матрицы $a$, как $a^{cf} = a^{(1)} \cup a^{(2)} \cup \cdots$, где $a^{(1)} = a$ и $$a^{(i)} = a^{(i-1)} \cup (a^{(i-1)} \times a^{(i-1)}), ~i \ge 2.$$
	\section{Сведение синтаксического анализа графов к поиску транзитивного замыкания}
	
	\section{Алгоритм}
	\section{Апробация}
	\section{Заключение}
	
	
	\printbibliography
	
\end{document} 
