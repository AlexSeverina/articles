\section{Introduction}

Formal language theory has deep connection with different areas such as static code analysis~\cite{Reps:1995:PID:199448.199462,vardoulakis2010cfa2,Yan:2011:DCA:2001420.2001440,rehof2001type,lu2013incremental, pratikakis2006existential, zhang2017context}, graph database querying~\cite{hellingsRelational, hellingsPathQuerying,zhang2016context, koschmieder2012regular}, formal verification~\cite{!!!}, and others.
One of the most frequent scenario is formulate problem in terms of languages intersection.
For example in verification one can use one language as a model of program and another language for undesirable behaviors description (for example from program specification).
In case when intersection of these two languages is not empty one can conclude that program is incorrect, so we are interested in languages intersection emptiness problem decidability.
But in some cases we want to build constructive representation of intersection. 
For example, when we use languages intersection as a model for graph querying: language which produced by intersection is a query result and we want to have ability to process it, so we need an appropriate representation of intersection result.

Thus investigation of emptiness of languages intersection problem and constructive representation of languages intersection are useful for different applications.
Let's look at the simple case: user input validation. 
If intersection of the trivial language which contains one word---user input---with the language specified by validation template (for example regular expression for e-mail validation) is empty, then input is incorrect. 
The similar case is a programs syntax correctness checking, moreover we can look at the parsing as at the constructive representation of intersection.
The more interesting case is intersection of two regular languages which may be used as base for graph database regular querying~\cite{ABITEBOUL1999428,koschmieder2012regular,alkhateeb:tel-00293206}.
Next and one of the most comprehensive cases with decidable problem of emptiness problem is an intersection of regular and context-free languages.
This case is actual for program analysis~\cite{Reps:1995:PID:199448.199462,vardoulakis2010cfa2,Yan:2011:DCA:2001420.2001440}, graph analysis~\cite{hellingsPathQuerying,zhang2016context,grigorev2016context}, context-free compressed data processing~\cite{MANETH201819}, and verification~\cite{!!!}.
Note that for many of these cases constructive result representation is important because it is a value of interest and sources fro further processing.

We can try to go upper.
For example, intersection of linear conjunctive and regular languages may be useful for static code analysis~\cite{zhang2017context}, but here we first should find such classes of languages that emptiness of intersection problem is decidable.
For linear-conjunctive and regular is undecidable, but multiple context-free languages may be an interesting choice because it is closed under intersection with regular languages and emptiness problem for MCFLs is decidable~\cite{!!!}.
May we express any useful properties in terms of regular and multiple context-free languages intersection? 
This question is out of scope of this work but may be a good reason for future research in this area.
In this work we are focused on the regular and context-free languages intersection.

Some of applications mentioned above require certifications. 
For verification this requirement is evident.
For databases, for example, it may be necessary for reasoning on security aspects and, thus, we should create certified solutions for query executing.
Certified parsing may be critical for Web~\cite{!!!}, as far as certified regular expressions for input validation.
As a result we can find big a number of works on regular expressions mechanization and certification~\cite{!!!}, and number of certified parsers~\cite{!!!}.
On the other hand, mechanization (formalization) is important itself as theoretical results mechanization and verification, and many work done on formal languages theory mechanization~\cite{!!!}. 
Also it is important to have a base for reasoning about parsing algorithms and other problems on languages intersection.

It is the well-known fact that context-free languages are closed under intersection with regular languages. 
Theoretical result is the Bar-Hillel theorem~\cite{bar1961formal} which has constructive proof and provides construction for resulting language description.
Thus the Bar-Hillel theorem mechanization is a good start point for certified application development and important part of formal language theory mechanization as one of fundamental results.
And this work is aimed to provide such mechanization in Coq.

Our current work is a first step: we provide mechanization of theoretical results on context-free and regular languages intersection.
We choose Smolka's and !!! results on context-free languages mechanization~\cite{!!!} as a base for our work.
The main contribution of this paper may be summarized as follows.
\begin{itemize}
\item We provide constructive proof of the Bar-Hillel theorem in Coq.
\item We generalize Smolka's CFL results: terminals is abstract types....
\item All code are published on GitHub: \url{https://github.com/YaccConstructor/YC_in_Coq}.
\end{itemize}

This work is organized as follows. 
First of all, in the section~\ref{!!!} we formulate Bar-Hillel theorem and provide sketch of it's proof.
The next part is brief discussion of the Chomsky normal form in section~\ref{!!!}.
After that we describe our solution in the section~\ref{}.
This description is splitted into steps with respect to provided sketch and contains basic definitions, Smolka's results generalization, trivial cases handling, and steps summarization as a final proof.
Finally we discuss related works in the section~\ref{!!!} and provide some discussion of presented work and possible directions for future research in the section~\ref{!!!}.

