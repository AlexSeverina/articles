\section{Introduction}

Formal language theory has deep connection with different areas such as static code analysis~\cite{Reps:1995:PID:199448.199462,vardoulakis2010cfa2,Yan:2011:DCA:2001420.2001440,rehof2001type, lu2013incremental, pratikakis2006existential, zhang2017context}, graph database querying~\cite{hellingsRelational, hellingsPathQuerying,zhang2016context, koschmieder2012regular}, formal verification~\cite{!!!}, and others.
One of the most frequent scenario is formulate problem in terms of languages intersection.
For example in verification one can use one language as a model of program and another language for undesirable behaviors description (for example from program specification).
In case when intersection of these two languages is not empty one can conclude that program is incorrect, so we are interested in languages intersection emptiness problem decidability.
But in some cases we want to build constructive representation of intersection. 
For example, when we use languages intersection as a model for graph querying: language which produced by intersection is a query result and we want to have ability to process it, so we need an appropriate representation of intersection result.

Thus investigation of emptiness of languages intersection problem and constructive representation of languages intersection are useful for different applications.
Let's look at the simple case: user input validation. 
If intersection of the trivial language which contains one word---user input---with the language specified by validation template (for example regular expression for e-mail validation) is empty, then input is incorrect. 
The similar case is a programs syntax correctness checking, moreover we can look at the parsing as at the constructive representation of intersection.
The more interesting case is intersection of two regular languages which may be used as base for graph database regular querying~\cite{ABITEBOUL1999428,koschmieder2012regular,alkhateeb:tel-00293206}.
Next and one of the most comprehensive cases with decidable problem of emptiness problem is an intersection of regular and context-free languages.
This case is actual for program analysis~\cite{!!!}, graph analysis~\cite{!!!}, context-free compressed data processing~\cite{!!!}, and verification~\cite{!!!}.
Constructive result is important: paths, etc

We can try to go upper.
For example, intersection of linear conjunctive and regular languages may be useful for static code analysis~\cite{zhang2017context}, but here we first should find such classes of languages that emptyness of intersection problem is decidable.
For linear-conjunctive and regular is undecidable, but multiple context-free languages may be an interesting choice.
May we express any useful properties in terms of regular and multiple context-free languages intersection? 
This question is out of scope of this work but may be a good reason for future research in this area.

!!! Regular---regular and regular queries in Coq~\cite{!!!}.
!!! The simplest case is linear---regular and we have a big number of works on certified regular expressions~\cite{!!!}.
Some of these applications require certifications. 
For verification is evident.
For databases, for example, it may be necessary to reason on security aspects and, thus, we should create certified solutions for query executing.
So, mechanization of BH theorem may be useful step for...
On the other hand, mechanization (formalization) is important and many work done on formal languages theory mechanization. 
Parsing algorithms and reasoning about other problems on languages intersection.

It is the well-known fact that context-free languages are closed under intersection with regular languages. 
Theoretical result is the Bar-Hillel theorem~\cite{bar1961formal} which has constructive proof and provides construction for resulting language description.
Thus the Bar-Hillel theorem mechanization is a good start point for certified application development.

Short overview of current results.
Many different parts of formal languages are mechanized. 
Smolka.
Algorithms and basic results.

Our current work is a first step: we provide mechanization of theoretical results on context-free and regular languages intersection.
The main contribution of this paper may be summarized as follows.
\begin{itemize}
\item We provide constructive proof of the Bar-Hillel theorem in Coq.
\item We generalize Smolka's CFL results: terminals is abstract types....
\item All code are published on GitHub: \url{https://github.com/YaccConstructor/YC_in_Coq}.
\end{itemize}

This work is organized as follows. First of all, we formulate theorem to proof and !!!
Describe our solution. This description is splitted into steps.
Smolka's results generalization, trivial cases handling, general case. 
Summarization.
Related works
Discussion and conclusion.

