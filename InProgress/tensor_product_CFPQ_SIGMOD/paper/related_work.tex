\section{Related Work}

Language constrained path querying is widely used in graph databases, static code analysis, and other areas.
Both, RPQ and CFPQ (known as CFL reachability problem in static code analysis) actively studied in recent years.

There is a huge number of theoretical research on RPQ and it's specific cases.
RPQ with single-path semantics was investigated from the theoretical point of view by Barrett et al.~\cite{barrett2000formal}.
In order to research practical limits and restrictions of RPQ, a number of high-performance RPQ algorithms were provided.
For example, derivative-based solution provided by Maurizio Nol\'{e} and Carlo Sartiani which is implemented on the top of Pregel-based system~\cite{10.1145/2949689.2949711}, or solution of Andr\'{e} Koschmieder et al.~\cite{10.1007/978-3-642-31235-9_12}.
But only a limited number of practical solutions provide the ability to restore paths of interest. 
One of the recent works is research of Xin Wang et al.~\cite{Wang2019} in which Pregel-based provenance-aware RPQ algorithm, which utilizes a Glushkov's construction~\cite{Glushkov1961}, is provided.
Applicability of linear algebra-based RPQ algorithms with paths-providing semantics is not investigated.

On the other hand, a bunch of CFPQ algorithms based on different ideas and with different properties was proposed in recent years. 
All of them have not better than cubic time complexity in terms of the input graph size, and exploit ideas of different parsing algorithms, such as CYK in works of Jelle Hellings~\cite{hellingsRelational} and Phillip Bradford~\cite{8249039}, (G)LR and (G)LL in works of Ekaterina Verbitskaia et al.~\cite{10.1007/978-3-319-41579-6_22}, Semyon Grigorev et al.~\cite{Grigorev:2017:CPQ:3166094.3166104}, Fred Santos et al.~\cite{10.1007/978-3-319-91662-0_17}, Ciro Medeiros et al.~\cite{Medeiros:2018:EEC:3167132.3167265}.
Worth mentioning separately Azimov's algorithm~\cite{Azimov:2018:CPQ:3210259.3210264}, which is first, in our knowledge, linear algebra based algorithm for CFPQ. 
It was shown by Arseniy Terekhov et al.~\cite{10.1145/3398682.3399163} that this algorithm can be applied for real-world graph analysis problems, while Jochem Kuijpers et al. shows in~\cite{Kuijpers:2019:ESC:3335783.3335791} that other state-of-the-art CFPQ algorithms are not performant enough to handle real-world graphs.

One of the important properties of both RPQ and CFPQ algorithms is the ability to restore paths of interest. 
Some of the mentioned algorithms can solve only the reachability problem, while in some cases it is important to provide at least one path which satisfies the query. 
While Arseniy Terekhov et al.~\cite{10.1145/3398682.3399163} provide first linear algebra based CFPQ algorithm with single path semantics, Jelle Hellings in~\cite{!!!} provides the first theoretical investigation of this problem. Also, he provides an overview of related works and shows that the problem is related to the string generation problem and respective results from formal language theory.
Also, he concludes that both theoretical and empirical investigation of CFPQ with single-path and all-path semantics are in early stage, and we agree with this point of view, because we only demonstrate applicability of our solution on paths extraction, without detailed investigation of its properties.

Truly subcubic CFPQ is a long-standing problem which is actively studied in both graph database and static code analysis communities.
The question on the existence of a subcubic CFPQ algorithm was asked by Mihalis Yannakakis in 1990 in~\cite{Yannakakis}.
He notes that Valiant's algorithm~\cite{10.1016/S0022-0000(75)80046-8}, the first known truly subcubic algorithm for context-free parsing, can be generalized to direct acyclic graph querying, but it unlikely can be applied for general CFPQ. 
A bit later Thomas Reps proposed the CFL reachability as a framework for interprocedural static code analysis~\cite{10.5555/271338.271343}. Melski and Reps gave a dynamic programming formulation of the problem running in $O(n^3)$ time and formulated a problem of the cubic bottleneck of context-free language reachability~\cite{10.1145/258993.259006}.
Heintze and McAllester introduced the class of 2NPDA (2-way nondeterministic pushdown automata)-hard problems and demonstrated connection between the CFL-reachability problem and 2NPDA-recognition as evidence that it is hard to solve the CFL-reachability problem because the cubic time decision procedure for an arbitrary 2NPDA problem has not been improved since its discovery in 1968~\cite{10.5555/788019.788876}.
Since these problems were formulated by ~\cite{}.
The most general result is a slightly subcubic algorithm inspired by recursive state machine reachability, which was provided by Swarat Chaudhuri in~\cite{10.1145/1328897.1328460}.
This algorithm achieves logarithmic speedup and thus $O(n^3/\log{n})$ time complexity. 
The first truly subcubic algorithm with $\widetilde{O}(n^\omega)$ time complexity ($\omega$ is the best exponent for matrix multiplication, $\widetilde{O}$ is the asymptotic upper-bound mod polylog factors) for general graph and 1-Dyck language was provided by Phillip Bradford in~\cite{Bradford2017EfficientEP}. Unfortunately, this result cannot be generalized to general context-free queries
A similar result was provided by Andreas Pavlogiannis and Anders Alnor Mathiasen in~\cite{pavlogiannis2020finegrained}.
Another partial case was investigated by Krishnendu Chatterjee et al. in~\cite{10.1145/3158118}.
The $O(m + n \cdot \alpha(n))$ algorithm for an arbitrary Dyck querying of a bidirected graph was described. Here $m$ is a number of edges, $n$ is a number of vertices in the input graph, and $\alpha(x)$ is an inverse Ackermann function.
Specific types of static code analysis related to CFL-r, especially Andersen's Pointer Analysis also actively studying.
For example, recently BMM-hardness of 1-Dyck reachability was proven by	Qirun Zhang in~\cite{zhang2020conditional}.
Other partial cases such as tree querying also were studied.

The utilization of linear algebra is a promising way to high-performance graph analysis.
There is a big number of works on specific graph algorithm formulation in terms of linear algebra, for example, classical algorithms for transitive closure and all-pairs shortest paths.
Recently this direction was summarized in GrpahBLAS API~\cite{7761646} which provides building blocks to develop a graph analysis algorithm in terms of linear algebra. 
There is a number of implementation of this API, such as SuiteSparse:GraphBLAS~\cite{10.1145/3322125} or CombBLAS~\cite{10.1177/1094342011403516}.
Also, linear algebra based approaches to evaluate different classes of queries in different systems actively studying. This approach demonstrates significant performance improvement when applied for SPARQL queries evaluation~\cite{10.1145/3302424.3303962,DBLP:journals/corr/MetzlerM15a} and for Datalog queries evaluation~\cite{sato_2017}.
Finally, RedisGraph~\cite{8778293}, a linear-algebra powered graph database, was created, and it was shown that it outperforms many other graph databases in some scenarios. 