\section{Conclusion and Future Work}

In this work we present an improved version of the tensor-based algorithm for CFPQ: we reduce the algortithm to operations over Boolean matrices, and we provide ability to extract all paths which satisfie the query.
Moreover, the provided algorithm can handle grammars in EBNF, thus it does not requres grammar to be in CNF transformation and avoids grammar explosion.
As a result, the algorithm demonstrates practical performance not only on CFPQ queryes, but also on RPQ ones, which shown by our evaluation. 
Thus, we provide universal linear algebra based algorithm for RPQ and CFPQ evaluation.

Also the algorithm open a way to attack long-standing problem on subcubic CFPQ by reduceing it to incremental transitive closure: \textit{incremental transitive closure with $O(n^{1-\varepsilon})$ update time which returns all new reachable pairs on each insertuin, implies $O(n^{3-\varepsilon})$ CFPQ algorithm.}
In this work we prove $O(n^3/\log{n})$ time complexity by providing $O(n/\log{n})$ transitive closure algorithm.

Thus, the first task for the future is to find truly sublinear algorithm for incremental transitive closure or, as a first step, to improve logarithmic factor.
Also, it is interesting to get improved bounds in partial cases.
For example, dynamic transitive closure for planar graphs can be supported !!!, and for undirected graph !!!. Can we use these facts to provide better CFPQ algortithm for respective partial cases? 
In the case of planarity it is interesting to investigate properties of the input graph and grammar whuch allow to preserve planarity during query evaluation.

On the other hand, privided reduction open a way to investigate streaming graph querying.
This way we can formulate the following questions.
\begin{enumerate}
\item Can we provide more detailed analysis of CFPQ queryes, than provided in~\cite{!!!}?
\item Can we provide practical solution for CFPQ querying of streaming graphs?
\item Can we improve existing solutions~\cite{Pacaci2020RegularPQ} for RPQ?
\end{enumerate}

From a practical perspective, it is necessary to analyze the usability of advanced algorithms for dynamic transitive closure.
In the current work we evaluate na{\"i}ve implementation in which transitive closure recalculated on each iteration from scratch.
In~\cite{cs6345} it is shown that some of advanced algorithms for dynamic transitive closure can be efficiently implemented.
Can one of these algorithms be efficiently parallelized and utilized in the proposed algorithm?

Also, it is necessary to evaluate GPGPU-based implementation.
Experience in Azimov's algorithm shows that the utilization of GPGPUs allows one to improve performance because operations of linear algebra can be efficiently implemented on GPGPU~\cite{!!!}. 
Moreover, for practical reason, it is interesting to provide a multi-GPU version of the algorithm and to utilize unified memory, which, as shown in~\cite{!!!}, is suitable for linear algebra based processing of out-of-GPGPU-memory data.

In order to simplify the distributed processing of huge graphs, it may be necessary to investigate different formats for sparse matrices, such as HiCOO format~\cite{!!!}. 

Finally, it is necessary to provide a multiple-source version of the algorithm and integrate it with a graph database.
RedisGraph\footnote{!!!}~\cite{!!!} is a suitable candidate for this purpose.
This database uses SuiteSparse---an implementation of GraphBLAS standard---as a base for graph processing.
This fact allowed to Arseny Terkhov et.al.  to integrate Azimov's algorithm to RedisGraph with minimal effort~\cite{!!!}.

%Other semantics: shortest path, simple path and so on. 
%Weighted graphs.

%On RSM optimization and query optimization. RSM minimization, their transformations.


%Specialization on query.
%Algebraic opersations specialization (partially static data in Haskell~\cite{!!!}).
%Runtime specialization (Posgres)~\cite{!!!}
