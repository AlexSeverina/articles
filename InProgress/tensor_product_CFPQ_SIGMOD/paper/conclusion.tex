\section{Conclusion and Future Work}

In this work we present an improved version of the tensor-based algorithm for CFPQ: we reduce the algortithm to operations over Boolean matrices, and we provide ability to extract all paths which satisfie the query.
Moreover, the provided algorithm can handle grammars in EBNF, thus it does not requres grammar to be in CNF transformation and avoids grammar explosion.
As a result, the algorithm demonstrates practical performance not only on CFPQ queryes, but also on RPQ ones, which shown by our evaluation. 
Thus, we provide universal linear algebra based algorithm for RPQ and CFPQ evaluation.

Also the algorithm open a way to attack long-standing problem on subcubic CFPQ by reduceing it to incremental transitive closure: \textit{incremental transitive closure with $O(n^{1-\varepsilon})$ update time which returns all new reachable pairs on each insertuin, implies $O(n^{3-\varepsilon})$ CFPQ algorithm.}
In this work we prove $O(n^3/\log{n})$ time complexity by providing $O(n/\log{n})$ transitive closure algorithm.

Thus, the first task for the future is to find truly sublinera algorithm for incremental transitive closure or, as a first step, to improve logarithmic factor.
Also, it is interesting to get improved bounds in partial cases.
For example, dynamic transitive closure for planar graphs can be supported !!!, and for undirected graph !!!. Can we use these facts to provide better CFPQ algortithm for respective partial cases? 
In the case of planarity it is interesting to investigate properties of the input graph and grammar whuch allow to preserve planarity during query evaluation.


On the other hand, privided reduction open a way to investigate streaming graph querying.
Can we provide more detailed analysis of CFPQ queryes, than provided in~\cite{!!!}?
Can we provide practical solution for CFPQ querying of streaming graphs?
Can we inprove existing solutions~\cite{Pacaci2020RegularPQ} for RPQ?


On RSM optimization and query optimization. RSM minimization, their transformations.

We evaluate na{\"i}ve implemantation. Try to use advanced algorithms for dynamic transotive closure~\cite{cs6345}.

HiCOO format~\cite{!!!} for distributed processing of huge graphs.

GPGPU-based implementation. Multi-GPU version. Unified memory, etc~\cite{!!!}

Full integration with Graph DB.
For example, with RedisGraph.
SuiteSparse as abse and success of matrix algorithm integration~\cite{!!!}

Other semantics: shortest path, simple path and so on. 
Weighted graphs.

Specialization on query.
Algebraic opersations specialization (partially static data in Haskell~\cite{!!!}).
Runtime specialization (Posgres)~\cite{!!!}
