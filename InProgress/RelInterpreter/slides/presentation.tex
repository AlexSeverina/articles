\documentclass[xcolor=table]{beamer}
\usepackage{beamerthemesplit}
\usepackage{wrapfig}
\usetheme{SPbGU}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{fancyvrb}
\usetikzlibrary{shapes,arrows}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{listings}
\usepackage{multicol}
\usepackage{comment}
\setbeamertemplate{itemize items}[circle]

\lstdefinelanguage{ocanren}{
keywords={run, conde, fresh, let, in, match, with, when, class, type,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure,
true, false},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\textbf,%\ttfamily\underline,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
mathescape=true,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\\/}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)},
 moredelim=**[is][\color{red}]{@}{@}
}

\lstset{
language=ocanren
}


\beamertemplatenavigationsymbolsempty

\title[Relational Interpreters for Search Problems]{Relational Interpreters for Search Problems}
\institute[JetBrains Research]{
JetBrains Research, Programming Languages and Tools Lab  \\
Saint Petersburg State University
}

\author[Kate Verbitskaia]{Petr Lozov, \textbf{Kate Verbitskaia}, Dmitry Boulytchev}

\date{22.08.2019}

\definecolor{orange}{RGB}{179,36,31}

\begin{document}
{
\begin{frame}[fragile]
  \begin{tabular}{p{5.5cm} p{5.5cm}}
   \begin{center}
      \includegraphics[height=1.5cm]{pictures/jetbrainsResearch.pdf}
    \end{center}
    &
    \begin{center}
      \includegraphics[height=1.5cm]{pictures/SPbGU_Logo.png}
    \end{center}
  \end{tabular}
  \titlepage
\end{frame}
}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Solvers from Verifiers}

Relational interpeter = verifier 

Relational intepreter being run backward = solver

\lstinline{evalo prog ?? res}

\lstinline{isPatho path graph res} 

\lstinline{unifyo term term' subst res} 

\lstinline{run q (isPatho q graph True)} --- searches for all paths in the \lstinline{graph}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion [Byrd 2009]}

Relational programming is complicated, why not let users write a verifier as a function and then translate it into miniKanren?

\begin{itemize}
  \item Introduce a new variable for each subexpression
  \item For every n-ary function create an (n+1)-ary relation, where the last argument is unified with the result
  \item Transform \lstinline{if}-expressions and pattern matchings into disjunctions with unifications for patterns
  \item Introduce into scope free variables (with \lstinline{fresh})
  \item Pop unifications to the top
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion: Step 1}
  
Introduce a new variable for each subexpression

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}
let rec append a b =
  match a with
  | []      -> b
  | x :: xs -> 
    x :: append xs b
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{lstlisting}
let rec append a b =
  match a with 
  | []      -> b
  | x :: xs -> 
    let @q@ = append xs b in
    x :: @q@
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion: Step 2}
  
Introduce a new variable for each subexpression

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}
let rec append a b = ...
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{lstlisting}
let rec append$^o$ a b @c@ = ...
\end{lstlisting}
\end{column}
\end{columns}  
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion: Step 3}
  
Transform \lstinline{if}-expressions and pattern matchings into disjunctions with unifications for patterns

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}
let rec append a b =
  match a with 
  | []      -> b
  | x :: xs -> 
    let q = append xs b in
    x :: q
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{lstlisting}
let rec append$^o$ a b c =
  (a === [] /\ b === c) \/
  (  (a === x :: xs) /\
     (append$^o$ xs b q) /\
     (c === x :: q))
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion: Step 4}

Introduce free variables into scope  (with \lstinline{fresh})

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}
let rec append$^o$ a b c =
  (a === [] /\ b === c) \/
  (  (a === x :: xs) /\
     (append$^o$ xs b q) /\
     (c === x :: q))
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{lstlisting}
let rec append$^o$ a b c =
  (a === [] /\ b === c) \/
  (@fresh (x xs q)@ (
     (a === x :: xs) /\
     (append$^o$ xs b q) /\
     (c === x :: q)))
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion: Step 5}
  
Pop unifications to the top

\begin{columns}
\begin{column}{0.5\textwidth}
\begin{lstlisting}
let rec append$^o$ a b c =
  (a === [] /\ b === c) \/
  (fresh (x xs q) (
     (a === x :: xs) /\
     (append$^o$ xs b q) /\
     (c === x :: q)))
\end{lstlisting}
\end{column}
\begin{column}{0.5\textwidth}  
\begin{lstlisting}
let rec append$^o$ a b c =
  (a === [] /\ b === c) \/
  (fresh (x xs q) (
     (a === x :: xs) /\
     @(c === x :: q)@ /\
     (append$^o$ xs b q))
\end{lstlisting}
\end{column}
\end{columns}
\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Forward Execution is Efficient, Backward Execution is not}
  
  Forward execution is efficient, since it mimics the execution of a function
  
\vspace{6pt}  
  
Relational conversion for \lstinline{f$_1$ x$_1$ && f$_2$ x$_2$}: 
 
\begin{lstlisting}
fun res ->
  fresh (p) (
    (f$_1$ x$_1$ p) /\
    (conde [
      (p === ^false /\ res === ^false);
      (p === ^true  /\ f$_2$ x$_2$ res)]))
\end{lstlisting} 

Computes \lstinline{f$_2$ x$_2$ res} only if \lstinline{f$_1$ x$_1$ p} fails

\vspace{6pt}

It is not the best strategy, if we know what \lstinline{res} is

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Relational Conversion aimed at Backward Execution}

This coversion of  \lstinline{f$_1$ x$_1$ && f$_2$ x$_2$} is better for backward execution, but not forward

\begin{lstlisting}
fun res ->
    conde [
      (res === ^false /\ f$_1$ x$_1$ ^false);
      (f$_1$ x$_1$ ^true    /\ f$_2$ x$_2$ res)]
\end{lstlisting}


  There is no one strategy suitable for all cases
  
  \vspace{6pt} 
  
  Better is to use an automatic specializer
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Specialization}

Interpreter: given a program and input computes an output

\lstinline{eval prog input} == \lstinline{output} 

\vspace{6pt}

Consider that a part of the input is known: \lstinline{input == (static, dynamic)}

\vspace{6pt}

Specializer: given a program and static input, generates a new program, which evaluated to the same output as the original

\vspace{6pt}

\lstinline{spec prog static} $\Rightarrow$ \lstinline{prog$_{spec}$}


\lstinline{eval prog (static, dynamic) == eval prog$_{spec}$ dynamic}

\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Conjunctive Partial Deduction}
CPD --- specialization for prolog

Features: specialization, deforestation, tupling 
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Deforestation}
<example doubleAppendo>
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Tupling}
<example maxLengtho>
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{CPD: Intuition}
Symbolic execution + ensuring termination

Treating conjunctions as a whole

Embedding + Generalization? 
\end{frame}


\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluation}
  Compare 
  
\begin{itemize}
  \item Unnesting 
  \item Unnesting strategy aimed at backward execution
  \item Unnesting + CPD
  \item Interpretation of functional verifier with relational interpreter
\end{itemize}

Tasks 

\begin{itemize}
  \item Path search
  \item Search for a unifier of two terms
\end{itemize}
  
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluation: Path Search}

<Task formulation>

<The size of the program before and after unnesting and specialization>

<Table with time mesurements>  
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Evaluation: Unification}

<Task formulation>

<The size of the program before and after unnesting and specialization>

<Table with time mesurements>  
\end{frame}

\begin{frame}[fragile]
  \transwipe[direction=90]
  \frametitle{Conclusion \& Future Work}
Funcional verifier + unnesting + specialization = solver
 
Future
 
\begin{itemize} 
  \item Generate functional program from relational to reduce interpretation overhead
  \item Another specialization technique, less ad-hoc than CPD

\end{itemize} 
\end{frame}

\end{document}
