\chapter{КС и конъюнктивная достижимость через произведение матриц}

В данном разделе мы рассмотрим алгоритм решения задачи контекстно-свободной и конъюнктивной достижимости, основанный на произведении матриц. Будет показано, что при использовании конъюнктивных граммтик, представленный алгоритм находит переапроксимацию истинного решения задачи.

\section{Описание}
\label{Matrix-CFPQ}
В главе~\ref{graph:CYK}~был изложен алгоритм для решения задачи КС достижимости на основе CYK. Заметим, что обход матрицы напоминает умножение матриц в ячейках которых множества нетерминалов:

\begin{align*}
M_3 = &M_1 \times M_2 \\
M_3[i,j] = &\sum_{k=1}^{n} M[i,k] * M[k,j]
\end{align*}
, где сумма --- это объединение множеств:

$$
\sum_{k=1}^{n} = \bigcup_{k=1}^{n}
$$
, а поэлементное умножение определено следующим образом:
$$
S_1 * S_2 = \{N_1^0 ... N_1^m\} * \{N_2^0 ... N_2^l\} = \{N_3 \mid (N_3 \rightarrow N_1^i N_2^j) \in P\}.
$$

Таким образом, синтаксический анализ может быть выражен в терминах перемножения матриц над полукольцом с соответствующими операциями.

Для линейного входа существует алгоритм Валианта~\cite{Valiant:1975:GCR:1739932.1740048}, использующий эту идею.
Однако он не обобщается на графы из-за того, что существенно использует возможность упорядочить обход матрицы (см. разницу в CYK для линейного случая и для графа). 
Поэтому, хотя для линейного случая алгоритм Валианта является алгоритмом синтаксического анализа для произвольных КС граммтик за субкубическое время, его обобщение до задачи КС достижимости в произвольных графах с сохранением асимптотики является нетривиальной задачей~\cite{Yannakakis}.

Поэтому рассмотрим более простую идею, изложенную в статье Рустама Азимова~\cite{Azimov:2018:CPQ:3210259.3210264}: будем строить транзитивное замыкание графа через наивное (не через возведение в квадрат) умножение матриц.

Пусть $\mathcal{G} = (V, E)$ --- входной граф и $G = (N,\Sigma,P)$ --- входная грамматика. Тогда алгоритм может быть сформулирован как представлено в листинге~\ref{alg:graphParse}.

\begin{algorithm}[H]
\begin{algorithmic}[1]
\caption{Context-free recognizer for graphs}
\label{alg:graphParse}
\Function{contextFreePathQuerying}{$\mathcal{G}$, G}
    
    \State{$n \gets$ количество узлов в $\mathcal{G}$}
    \State{$E \gets$ направленные ребра в $\mathcal{G}$}
    \State{$P \gets$ набор продукций из $G$}
    \State{$T \gets$ матрица $n \times n$, в которой каждый элемент $\varnothing$}
    \ForAll{$(i,x,j) \in E$}
    \Comment{Инициализация матрицы}
        \State{$T_{i,j} \gets T_{i,j} \cup \{A~|~(A \rightarrow x) \in P \}$}
    \EndFor    
    \While{матрица $T$ меняется}
       
        \State{$T \gets T \cup (T \times T)$}
        \Comment{Вычисление транзитивного замыкания} 
    \EndWhile
\State \Return $T$
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{example}[Пример работы]

Пусть есть граф $\mathcal{G}$:
\begin{center}
    \begin{tikzpicture}[node distance=2.5cm,shorten >=1pt,on grid,auto]
    \node[state] (q_0)   {$1$};
    \node[state] (q_1) [above right=of q_0] {$2$};
    \node[state] (q_2) [right=of q_0] {$0$};
    \node[state] (q_3) [right=of q_2] {$3$};
    \path[->]
    (q_0) edge  node {a} (q_1)
    (q_1) edge  node {a} (q_2)
    (q_2) edge  node {a} (q_0)
    (q_2) edge[bend left, above]  node {b} (q_3)
    (q_3) edge[bend left, below]  node {b} (q_2);
    \end{tikzpicture}
    
\end{center}

и грамматика $G$:
\begin{align*}
S   &\to A B    &A  \to a \\ 
S  &\to A S_1   &B  \to b\\ 
S_1 &\to S B 
\end{align*}


Пусть $T_i$ --- матрица, полученная из $T$ после применения цикла, описанного в строках \textbf{8-9} алгоритма~\ref{alg:graphParse}, $i$ раз.
Тогда $T_0$, полученная напрямую из графа, выглядит следующим образом:

\[
T_0 = \begin{pmatrix}
    \varnothing & \{A\}       & \varnothing & \{B\}       \\
    \varnothing & \varnothing & \{A\}       & \varnothing \\
    \{A\}       & \varnothing & \varnothing & \varnothing \\
    \{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}
\]

Далее показано получение матрицы $T_1$.

\[
T_0 \times T_0 = \begin{pmatrix}
    \varnothing & \varnothing & \varnothing & \varnothing \\
    \varnothing & \varnothing & \varnothing & \varnothing \\
    \varnothing & \varnothing & \varnothing & \{S\}       \\
    \varnothing & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}
\]

\[
T_1 = T_0 \cup (T_0 \times T_0) = \begin{pmatrix}
    \varnothing & \{A\}       & \varnothing & \{B\}       \\
    \varnothing & \varnothing & \{A\}       & \varnothing \\
    \{A\}       & \varnothing & \varnothing & \cellcolor{lightgray} \{\pmb{S}\}       \\
    \{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}
\]

После первой итерации цикла нетерминал в ячейку $T[2,3]$ добавился нетерминал $S$. 
Это означает, что существует такой путь $\pi$ из вершины 2 в вершину 3 в графе $\mathcal{G}$, что $S \xrightarrow{*} \omega(\pi)$. В данном примере путь состоит из двух ребер $2 \rightarrow{a} 0$ и $ 0 \rightarrow{b} 3$, так что $S \xrightarrow{*} ab$.

Вычисление транзитивного замыкания заканчивается через $k$ итераций, когда достигается неподвижная точка процесса: $T_{k-1} = T_k$. Для данного примера $k = 13$, так как $T_{13} = T_{12}$. Весь процесс рабты алгоритма (все матрицы $T_i$) показан ниже (на каждой итерации новые элементы выделены жирным).

{\footnotesize
\begin{alignat*}{7}
& &&T_2 &&= \begin{pmatrix}
\varnothing & \{A\}       & \varnothing & \{B\}       \\
\varnothing & \varnothing & \{A\}       & \varnothing \\
\cellcolor{lightgray} \{A, \pmb{S_1}\}  & \varnothing & \varnothing & \{S\}       \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \ \ \ \ &&T_3 &&= \begin{pmatrix}
\varnothing & \{A\}       & \varnothing & \{B\}       \\
\cellcolor{lightgray} \{\pmb{S}\}       & \varnothing & \{A\}       & \varnothing \\
\{A, S_1\}  & \varnothing & \varnothing & \{S\}       \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \\ & &&T_4 &&= \begin{pmatrix}
\varnothing & \{A\}       & \varnothing & \{B\}       \\
\{S\}       & \varnothing & \{A\}       & \cellcolor{lightgray} \{\pmb{S_1}\}     \\
\{A, S_1\}  & \varnothing & \varnothing & \{S\}       \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}  \ \ \ \ &&T_5 &&= \begin{pmatrix}
\varnothing & \{A\}       & \varnothing & \cellcolor{lightgray} \{B, \pmb{S}\}    \\
\{S\}       & \varnothing & \{A\}       & \{S_1\}     \\
\{A, S_1\}  & \varnothing & \varnothing & \{S\}       \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \\ & &&T_6 &&= \begin{pmatrix}
\cellcolor{lightgray} \{\pmb{S_1}\}     & \{A\}       & \varnothing & \{B, S\}    \\
\{S\}       & \varnothing & \{A\}       & \{S_1\}     \\
\{A, S_1\}  & \varnothing & \varnothing & \{S\}       \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \ \ \ \ &&T_7 &&= \begin{pmatrix}
\{S_1\}     & \{A\}       & \varnothing & \{B, S\}    \\
\{S\}       & \varnothing & \{A\}       & \{S_1\}     \\
\cellcolor{lightgray} \{A, S_1, \pmb{S}\}  & \varnothing & \varnothing & \{S\}    \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}  \\
& &&T_8 &&= \begin{pmatrix}
\{S_1\}     & \{A\}       & \varnothing & \{B, S\}    \\
\{S\}       & \varnothing & \{A\}       & \{S_1\}     \\
\{A, S_1, S\}  & \varnothing & \varnothing & \cellcolor{lightgray} \{S, \pmb{S_1}\} \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \ \ \ \ &&T_9 &&= \begin{pmatrix}
\{S_1\}     & \{A\}       & \varnothing & \{B, S\}    \\
\{S\}       & \varnothing & \{A\}       & \cellcolor{lightgray} \{S_1, \pmb{S}\}     \\
\{A, S_1, S\}  & \varnothing & \varnothing & \{S, S_1\} \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \\ & &&T_{10} &&= \begin{pmatrix}
\{S_1\}     & \{A\}       & \varnothing & \{B, S\}    \\
\cellcolor{lightgray} \{S, \pmb{S_1}\}       & \varnothing & \{A\}       & \{S_1, S\}     \\
\{A, S_1, S\}  & \varnothing & \varnothing & \{S, S_1\} \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}  \ \ \ \  &&T_{11} &&= \begin{pmatrix}
\cellcolor{lightgray} \{S_1, \pmb{S}\}     & \{A\}       & \varnothing & \{B, S\}    \\
\{S, S_1\}       & \varnothing & \{A\}       & \{S_1, S\}     \\
\{A, S_1, S\}  & \varnothing & \varnothing & \{S, S_1\} \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \\ & &&T_{12} &&= \begin{pmatrix}
\{S_1, S\}     & \{A\}       & \varnothing & \cellcolor{lightgray} \{B, S, \pmb{S_1}\}    \\
\{S, S_1\}       & \varnothing & \{A\}       & \{S_1, S\}     \\
\{A, S_1, S\}  & \varnothing & \varnothing & \{S, S_1\} \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix} \ \ \ \ &&T_{13} &&= \begin{pmatrix}
\{S_1, S\}     & \{A\}       & \varnothing & \{B, S, S_1\}    \\
\{S, S_1\}       & \varnothing & \{A\}       & \{S_1, S\}     \\
\{A, S_1, S\}  & \varnothing & \varnothing & \{S, S_1\} \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}
\end{alignat*}
}

Таким образом, результат алгоритма~\ref{alg:graphParse} для нашего примера --- это матрица $T_{13} = T_{12}$. Заметим, что для данного алгоритма приведённый пример также является худшим случаем: на каждой итерации в матрицу добавляется ровно один нетерминал, при том, что необходимо заполнить порядка $O(n^2)$ ячеек.

\end{example}


\subsection{Расширение алгоритма для конъюнктивных грамматик}

Матричный алгоритм для конъюнктивных грамматик отличается от алгоритма~\ref{alg:graphParse} для контекстно-свободных грамматик только операцией умножения матриц, в остальном алгоритм остается без изменений. Определим операцию умножения матриц.
\begin{definition}
    Пусть $M_1$ и $M_2$ матрицы размера $n$. Определим операцию $\circ$  сдедующим образом:
     $$M_1 \circ M_2 = M_3,$$ $$M_3 [i,j] = \{A \mid \exists (A \rightarrow B_1 C_1 \& \ldots \& B_m C_m) \in P, (B_k , C_k) \in d[i,j] \forall k = 1,\ldots,m\}$$, где $$d[i,j] = \bigcup_{k = 1}^{n} M_1 [i,k] \times M_2 [k,j].$$
\end{definition}

Важно заметить, что алгоритм для конъюнктивных грамматик, в отличие от алгоритма для контекстно-свободных грамматик, дает лишь верхнюю оценку ответа. То есть все нетерминалы, которые должны быть в ячейках матрицы результата, содержатся там, но вместе с ними содержатся и лишние нетерминалы. Рассмотрим пример, иллюстрирующий появление лишних нетерминалов.

\begin{example}
    Грамматика $G$:
    \begin{align*}
    S &\to AB \& DC & C &\to c \\ 
    A &\to a        & D &\to DC \mid b\\
    B &\to BC \mid b
    \end{align*}
    Очевидно, что грамматика $G$ задает язык из одного слова $L(G) = \{abc\} = \{abc^*\} \cap \{a^* bc\}$.
    
    Пусть есть граф $\mathcal{G}$:
    \begin{center}
        \begin{tikzpicture}[node distance=2.5cm, shorten >=1pt,on grid,auto]
        \node[state] (q_0)   {$0$};
        \node[state] (q_1) [right=of q_0] {$1$};
        \node[state] (q_2) [right=of q_1] {$2$};
        \node[state] (q_6) [below=of q_2] {$6$};
        \node[state] (q_3) [right=of q_2] {$3$};
        \node[state] (q_5) [right=of q_6] {$5$};
        \node[state] (q_4) [right=of q_3] {$4$};
        \path[->]
        (q_0) edge  node {a} (q_1)
        (q_1) edge  node {b} (q_2)
        (q_1) edge  node {a} (q_6)
        (q_2) edge  node {c} (q_3)
        (q_3) edge  node {c} (q_4)
        (q_6) edge  node {b} (q_5)
        (q_5) edge  node {c} (q_4);
        \end{tikzpicture}
    \end{center}
    Применяя алгоритм, получим, что существует путь из вершины 0 в вершину 4, выводимый из нетерминала $S$. Однако очевидно, что в графе такого пути нет. 
    Такое поведение алгоритма наблюдается из-за того, что существует путь ``abcc'', соответствующий $L(AB) = \{abc^*\}$ и путь ``aabc'', соответствующий $L(DC) = \{a^{*}bc\}$, но они различны. Однако алгоритм не может это проверить, так как оперирует понятием достижимости между вершинами, а не наличием различных путей. Более того, в общем случае для конъюнктивных граммтик такую проверку реалиховать нельзя. Поэтому для классической семантики достидимости с ограничениями в терминах конъюнктивных граммтик результат работы алгоритма является оценкой сверху.
    
    Существует альтернативная семантика, когда мы трактуем конъюнкцию в праой части правил как крнъюнкцию в Datalog (подробнее о Datalog в параграфе~\ref{Subsection Datalog}). Т.е если есть правило $S \to AB \& DC$, то должен быть путь принадлежащий языку $L(AB)$ и путь принадлежащий языку $L(DC)$. В такой семантике алгоритм дает точный ответ.
\end{example}

Подробнее алгоритм описан в статье Рустама Азимова и Семёна Григорьева~\cite{565CECD7E8F5C6063935B41DB41797AA37D53B04}. Стоит также отметить, что обобщения данного алогритма для булевых грамматик не существует, хотя и сущетсвует частное решение для случая, когда граф не содержит циклов (является DAG-ом), предложенное Екатериной Шеметовой~\cite{Shemetova2019}.

\section{Особенности реализации алгоритмов, основанных на произведении матриц}

Алгоритмы, описанные выще, удобны с точки зрения реализации тем, что могут быть эффективно реализованы с использованием высокопроизводительных библиотек линейной алгебры, которые эксплуатируют возможности параллельных вычислений на современных CPU и  GPGPU~\cite{Mishin:2019:ECP:3327964.3328503}. 
Это позволяет с минимальными затратими получить эффективную параллельную реализацию алгоритма для решения задачи КС достижимости в графах. Далее рассмотрим некоторые детали, упрощающие реализацию с использованием современных библиотек и аппаратного обеспечения.

Так как множество нетерминалов и правил конечно, то мы можем свести представленный выше алгоритм к булевым матрицам: для каждого нетерминала заведём матрицу, такую что в ячейке стоит 1 тогда и только тогда, когда в исходной матрице в соответствующей ячейке сожержится этот нетерминал.
Тогда перемножение пары таких матриц, соответсвующих нетерминалам $A$ и $B$, соответствует построению путей, выводимых из нетерминалов, для которых есть правила с правой частью вида $A B$. 

\begin{example}
Представим в таком виде следующую матрицу:
\[
T_0 = \begin{pmatrix}
\varnothing & \{A\}       & \varnothing & \{B\}       \\
\varnothing & \varnothing & \{A\}       & \varnothing \\
\{A\}       & \varnothing & \varnothing & \varnothing \\
\{B\}       & \varnothing & \varnothing & \varnothing \\
\end{pmatrix}
\]

Тогда:
\begin{alignat*}{7}
& &&T_{0\_A} &&= \begin{pmatrix}
0 & 1       & 0 & 0       \\
0 & 0 & 1       & 0 \\
1  & 0 & 0 & 0       \\
0       & 0 & 0 & 0 \\
\end{pmatrix} \ \ \ \ &&T_{0\_B} &&= \begin{pmatrix}
0 & 0       & 0 & 1       \\
0       & 0 & 0       & 0 \\
0  & 0 & 0 & 0       \\
1       & 0 & 0 & 0 \\
\end{pmatrix}
\end{alignat*}
Тогда при наличии правила $S \to A B$ получим:
\[
T_{1\_S} =T_{0\_A} \times T_{0\_B} = \begin{pmatrix}
0 & 0       & 0 & 0       \\
0       & 0 & 0       & 0 \\
0  & 0 & 0 & 1       \\
0       & 0 & 0 & 0 \\
\end{pmatrix}
\]
\end{example}

Алгоритм же может быть переформулирован так, как показано в листинге~\ref{lst:algo1}. Такой взгляд на алгоритм позволяет использдвать для его реализации существующие высокорпоизводительные библиотеки для работы с булевыми матрицами (например M4RI\footnote{!!!}~\cite{!!!}) или библиотеки для линейной алгебры (например !!!).

\begin{algorithm}
  \floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Context-free path quering algorithm. Boolean matrix version}
\label{lst:algo1}
\Function{evalCFPQ}{$D=(V,E), G=(N,\Sigma,P)$}
    \State{$n \gets$ |V|}
    \State{$T \gets \{T^{A_i} \mid A_i \in N, T^{A_i}$ is a matrix $n \times n$, $T^{A_i}_{k,l} \gets$ \texttt{false}\} }
    \ForAll{$(i,x,j) \in E$, $A_k \mid A_k \to x \in P$}
        %\Comment{Matrices initialization}
        %\For{$A_k \mid A_k \to x \in P$}
          {$T^{A_k}_{i,j} \gets \texttt{true}$}
        %\EndFor
    \EndFor
    \For{$A_k \mid A_k \to \varepsilon \in P$}
       {$T^{A_k}_{i,i} \gets \texttt{true}$}
    \EndFor

    \While{any matrix in $T$ is changing}
        %\Comment{Transitive closure calculation}
        \For{$A_i \to A_j A_k \in P$}
          { $T^{A_i} \gets T^{A_i} + (T^{A_j} \times T^{A_k})$ } 
        \EndFor
    \EndWhile
\State \Return $T$
\EndFunction
\end{algorithmic}
\end{algorithm}

С другой стороны, для небольших запросов практически может быть выгодно представлять множества нетерминалов в виде битового вектора следующим образом.
Нумеруем все нетерминалы с нуля, в векторе стоит 1 на позиции $i$, если в множестве есть нетерминал с номером $i$.
Таким образом, в каждой ячейке хранится битовый вектор длины $|N|$.
Тогда операцию умножения надо определить следующим образом:
$$v_1 \times v_2 = \{v \mid \exists (v,v_3) \in P, \textit{append}(v_1, v_2) \& v_3 = v_3\},$$ где $\&$ --- побитовое \texttt{``и''}.
Чтобы это было возможно, правила надо кодировать соответственно: продукция это пара, где первый элемент --- битовый вектор длины $N$ с единственной единицей в позиции, соответствующей нетерминалу в правой части, а второй элемент --- вектор длины $2|N|$, с двумя единицами кодирующими первый и второй нетерминалы, соответственно.

\begin{example}
Пусть $N = \{S, A, B\}$ и есть продукция $S \to A B$. Тогда занумеруем нетерминалы $ S \to 0, A \to 1, B \to 2$ и продукция примет вид $[1, 0, 0] \to [0, 1, 0, 0, 0, 1]$. Матрица $T_0$ примет вид(в нашей нотации $.$ означает, что в ячейке стоит $[0,0,0]$):
\[
T_0 = \begin{pmatrix}
. & [0,1,0]       & . & [0,0,1]       \\
. & . & [0,1,0]       & . \\
[0,1,0]       & . & . & . \\
[0,0,1]      & . & . & . \\
\end{pmatrix}
\]

После выполнения умножения получим $T_1 = T_0 \times T_0$:
\[
T_1 = \begin{pmatrix}
. & [0,1,0]       & . & [0,0,1]       \\
. & . & [0,1,0]       & . \\
[0,1,0]       & . & . & [1,0,0] \\
[0,0,1]      & . & . & . \\
\end{pmatrix}
\]
\end{example}


На практике в роли векторов могут выступать беззнаковые целые. 
Например, 32 бита под ячейки в матрице и 64 бита под правила (или 8 и 16, если запросы совсем маленькие, или 16 и 32).
Тогда умножение выражается через битовые операции и сравнение.

Для небольших запросов такой подход к реализации может оказаться быстрее --- в данном случае скорость зависит от деталей. Минус подхода в том, что нет возможности использовать готовые библиотеку ленейной алгебры без предварительной модификации. Только если они не являются параметризуемыми и не позволяют задать собственный тип и собственную операцию умножения и сложения (иными словами, собственное полукольцо).

Также стоит замеить, что при работе с реальными графами матрицы как правило оказываются разреженными. Возникает вопрос, как представлять матрицу. Среди способов --- разреженные матрицы, GraphBLAS\footnote{GraphBLAS --- открытый стандарт для графовых алгоритмов --- \url{https://github.com/gunrock/graphblast} }, GPGPU, CUTLASS\footnote{Репозиторий библиотеки CUTLASS: \url{https://github.com/NVIDIA/cutlass}}.
Quad Tree~\cite{quadtree}.

Для вычислений лучше всего, когда все нужные для вычисления матрицы помещаются на одну карту. Хуже --- если только одна пара матриц. Хуже всего, когда не помещается даже пара матриц. Поэтому хороши распределенные решения, например через GraphBLAS.

\section{Обзор}
\begin{itemize}
    \item Lee. О конвертации парсеров КС-грамматик в перемножение булевых матриц~\cite{Lee:2002:FCG:505241.505242}
    \item OpenCypher~\cite{Kuijpers:2019:ESC:3335783.3335791}
    \item J.Hellings. CFPQ~\cite{hellingsRelational,hellings2015querying,Hellings2015PathRF}
    \item Zhang. CFPQ on rdf graphs~\cite{10.1007/978-3-319-46523-4_38}
    \item Bradford~\cite{bradford2007quickest,ward2008distributed,bradford2016fast,Bradford:2008:LCG:1373936.1373946}
\end{itemize}

Асимптотически приведенные алгоритмы имеют большую сложность, например \\ $O(n^2 |N|^2|P|~ (MM(n))$, где $MM(n)$ --- сложность перемножения матриц $n \times n$, $|P|$ --- мощность множества продукций, $|N|$ --- мощность множества нетерминалов. Однако такая большая сложность компенсируется возможностью их распараллеливания, в результате чего они работают быстрее однопоточных алгоритов с лучшей сложностью.

Брэдфорт получил субкубическую сложность для частного случая --- языка Дика с одним типом скобок~\cite{8249039}.

\section{Вопросы и задачи}
\begin{enumerate}
    \item Находить кратчайшие пути в графах, используя идеи из секции~\ref{Matrix-CFPQ}.
    \item Превратить граф, использующийся для CFPQ, в дерево.
    \item Реализовать предложенные идеи на различных архитектурах.
    \item Замерить производительность и расходы памяти по сравнению с существующими реализациями.
\end{enumerate}
