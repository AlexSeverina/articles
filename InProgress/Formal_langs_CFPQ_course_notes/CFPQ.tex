\section{Задача о поиске путей с ограничениями в терминах формальных языков}



В данной главе сформулируем постановку задачи о поиске путей в графе с ограничениями. 
А также приведем несколько примеров областей, в которых применяются алгоритмы решения этой задачи.

\subsection{Постановка задачи }


Пусть нам дан конечный ориентированный помеченный граф $\mathcal{G}=\langle V,E,L \rangle$.
Функция $\omega(\pi) = \omega((v_0, l_0, v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_{n-1},v_n)) = l_0 \cdot l_1 \cdot \ldots \cdot l_{n-1} $ строит слово по пути посредством конкатенации меток рёбер вдоль этого пути.
Очевидно, для пустого пути данная функция будет возвращать пустое слово, а для пути длины $n  > 0$ --- непустое слово длины $n$.

Если теперь рассматривать задачу поиска путей, то окажется, что то множество путей, которое мы хотим найти, задаёт множество слов, то есть язык.
А значит, критерий поиска мы можем сформулировать следующим образом: нас интересуют такие пути, что слова из меток вдоль них принадлежат заданному языку.
\begin{definition}
	\textit{Задача поиска путей с ограничениями в терминах формальных языков} заключается в поиске множества путей $\Pi = \{\pi \mid \omega(\pi) \in \mathcal{L}\}$.
	
\end{definition}

В задаче поиска путей мы можем накладывать дополнительные ограничения на путь (например, чтобы он был простым, кратчайшим или Эйлеровым~\cite{kupferman2016eulerian}), но это уже другая история.

Другим вариантом постановки задачи является задача достижимости.

\begin{definition}
	\textit{Задача достижимости} заключается в поиске множества пар вершин, для которых найдется путь с началом и концом в этих вершинах, что слово, составленное из меток ребер пути, будет принадлежать заданному языку.
	$\Pi' = \{(v_{i}, v_{j}) \mid \exists v_{i} \pi v_{j}, \omega(\pi) \in \mathcal{L}\}$.
	
\end{definition}

При этом, множество $\Pi$ может являться бесконечным, тогда как $\Pi'$ конечно, по причине конечности графа $\mathcal{G}$.

Язык $\mathcal{L}$ может принадлежать разным классам и быть задан разными способами.
Например, он может быть регулярным.
Или контекстно свободным.
Или многокомпонентным контекстно-свободным.

Если $\mathcal{L}$ --- регулярный, $\mathcal{G}$ можно рассматривать как НКА, в котором все вершины и стартовые, и конечные.
Тогда задача сводится к пересечению двух регулярных языков.

Более подробно мы рассмотрим случай, когда $\mathcal{L}$ --- контекстно-свободный язык.

Путь $G = \langle \Sigma, N, P \rangle$ --- контекстно-свободная граммтика.
Будем считать, что $L \subseteq \Sigma$.
Мы не фиксируем стартовый нетерминал в определении граммтики, поэтому, чтобы описать язык, задаваемый ей, нам необходимо отдельно зафиксировать стартовый нетерминал.
Таким образом, будем говорить, что $L(G,N_i) = \{ w | N_i \xRightarrow[G]{*} w  \}$ --- это язык задаваемый граммтикой $G$ со стартовым нетерминалом $N_i$.

\begin{example}
	Пример задачи поиска путей.
	
	Дана грамматика  $G:$
	\begin{align*}
	S   &\to a b \\ 
	S   &\to a S b
	\end{align*}
	
	Эта грамматика задаёт язык $\mathcal{L} = a^n b^n$.
	
	И дан граф $\mathcal{G}:$
	
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,on grid,auto]
		\node[state] (q_0)   {$0$};
		\node[state] (q_1) [above right=of q_0] {$1$};
		\node[state] (q_2) [right=of q_0] {$2$};
		\node[state] (q_3) [right=of q_2] {$3$};
		\path[->]
		(q_0) edge  node {a} (q_1)
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {a} (q_0)
		(q_2) edge[bend left, above]  node {b} (q_3)
		(q_3) edge[bend left, below]  node {b} (q_2);
		\end{tikzpicture}
		
	\end{center}
	
	Тогда примерами путей, принадлежащих множеству $\Pi = \{\pi \mid \omega(\pi) \in \mathcal{L}\}$ являются:
	
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,on grid,auto]
		\node[state] (q_1) {$1$};
		\node[state] (q_2) [right=of q_1] {$2$};
		\node[state] (q_3) [right=of q_2] {$3$};
		\path[->]
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {b} (q_3);
		\end{tikzpicture}
		
	\end{center}
	
	\begin{center}
		\begin{tikzpicture}[shorten >=1pt,on grid,auto]
		\node[state] (q_0)   {$0$};
		\node[state] (q_1) [right=of q_0] {$1$};
		\node[state] (q_2) [right=of q_1] {$2$};
		\node[state] (q_3) [right=of q_2] {$3$};
		\node[state] (q_4) [right=of q_3] {$2$};
		\path[->]
		(q_0) edge  node {a} (q_1)
		(q_1) edge  node {a} (q_2)
		(q_2) edge  node {b} (q_3)
		(q_3) edge  node {b} (q_4);
		\end{tikzpicture}
		
	\end{center}
	
\end{example}


\subsection{О разрешимости задачи}

Задачи из определения 4.1 и 4.2 сводятся к построению пересечения языка $\mathcal{L}$ и языка, задаваемого путями графа, R. То есть к построению пересечения двух автоматов. 
А мы для обсуждения разрешимости задачи рассмотрим более слабую постановку задачи:

\begin{definition}
	Необходимо проверить, что $\exists$ хотя бы один такой путь $\pi$ для данного графа, для данного языка $\mathcal{L}$, что $\omega(\pi) \in \mathcal{L}$.
	
\end{definition}

Эта задача сводится к проверке пустоты пересечения языка $\mathcal{L}$ c R - регулярным языком, задаваемым графом. От класса языка $\mathcal{L}$ зависит её разрешимость:

\begin{itemize}
	\item Если $\mathcal{L}$ регулярный, то получаем задачу $R \cap R = R$.
	Проверка регулярного языка на пустоту - разрешимая проблема.
	
	\item Если $\mathcal{L}$ контекстно свободный, то получаем задачу $CF \cap R = CF$.
	Проверка контекстно свободного языка на пустоту - разрешимая проблема.
	
	\item Помимо иерархии Хомского существуют и другие классификации языков.
	Так например, класс конъюнктивных(Conj) языков является строгим расширением контекстно-свободных языков и все так же позволяет полиномиальный синтаксический анализ.
	Если $\mathcal{L}$ - конъюнктивный. При пересечении Conj и регулярного языков получается Conj ($Conj \cap R = Conj$), а проблема проверки Conj на пустоту не разрешима.
	
	\item Еще один класс языков из альтернативной иерархии, не сравнимой с Иерархией Хомского, - MCFG(multiple context-free grammars). Как его частный случай - TAG(tree adjoining grammar).
	
	$R \cap MCFG = MCFG$ - проверка пустоты резрешима.
	
\end{itemize}

Существует еще много других классификаций языков, но поиск универсальной иерархии до сих пор продолжается.

Далее, для изучения алгоритмов решения, нас будет интересовать задача $R \cap CF = CF$.

\subsection{Области применения}
\begin{itemize}
	\item Статанализ. 
	Введено Томасом Репсом~\cite{Reps}.
	\item Применяется для различных межпроцедурных задач~\cite{LabelFlowCFLReachability,specificationCFLReachability,Zheng}.
	
	\item Графовые БД.
	Впервые предложил Михалис Яннакакис~\cite{Yannakakis}.
	
\end{itemize}

\subsection{Вопросы и задачи}
\begin{enumerate}
	\item Пусть есть граф. Задайте грамматику для поиска всех путей, таких, что....
	\item Существует ли в графе !!! путь из А в Б, такой что!!!
	\item Для графа !!! постройте все пути, удовлетворяющие !!!!
	
	\item Задача 1
	\item Задача 2
\end{enumerate}
