\section{От CFPQ к вычислению Datalog-запросов}\label{Subsection Datalog}
Рассмотрим грамматику  $S -> aSb | SS | \varepsilon$, заданную через набор предикатов:
\begin{itemize}
	\item a(i, w) --- Предикат, соответствующий терминалу. Обращается в True, если на i-том месте в строке w стоит символ a
	\item S(i, j, w) --- Предикат, соответствующий нетерминалу. Обращается в True, если выполняется одно из условий:
	\begin{enumerate}
		\item $i == j \quad(\varepsilon)$
		\item $\exists k: i \leq k \leq j \And S(i, k - 1, w) \And S(k, j, w)  \quad (SS)$
		\item  ${a(i, w) \And S(i+1, j-1, w) \And b(j-1, w)} \quad (aSb)$
	\end{enumerate}
\end{itemize}

Тогда S(0, |w|, w) покажет, выводится ли строка w из данной грамматики,
а S(\_,\_,w) даст нам список всех цепочек внутри w, выводящихся из S.

\subsection{Datalog}
Datalog --- декларативный логический язык программирования. Используется для написания запросов к дедуктивным базам данных\footnote{\url{https://en.wikipedia.org/wiki/Deductive_database}}. Программы на даталоге вылядят таким образом:
\begin{enumerate}
	\item Набор фактов (часто факты находятся в базе данных):
	\begin{itemize}
		\item $a(0).$
		\item $b(1).$
		\item $a(2).$
		\item $b(3).$
		\item $S(I, I).$
	\end{itemize}
	\item Набор правил:
	\begin{itemize}
		\item $s(I, J) := s(I, K-1), s(K,J), (I \leq K \leq J).$
		\item $a(I), s(I+1, J-1),b(J)$
	\end{itemize}
	\item Запросы:
	\begin{itemize}
		\item $?- s(I, J)$
	\end{itemize}
\end{enumerate}
Таким образом мы описали на даталоге строку через набор фактов, грамматику, указанную выше, через набор фактов и правил и сделали запрос на все цепочки, выводящиеся из S. 

\textbf{NB!} Обратите внимание, что строки, начинающиеся с большой буквы, в даталоге считаются переменными. Также важно, что все переменные неявно квантифицированны.

\textbf{NB!} В даталоге отсутствуют функциональный символы (но есть в реализациях), а отрицание ограничено.

Рассмотрим, как описать на даталоге представленный граф
\begin{center}
	\begin{tikzpicture}[shorten >=1pt,on grid,auto]
	\node[state] (q_0)   {$0$};
	\node[state] (q_1) [above right=of q_0] {$1$};
	\node[state] (q_2) [right=of q_0] {$2$};
	\node[state] (q_3) [right=of q_2] {$3$};
	\path[->]
	(q_0) edge  node {$a$} (q_1)
	(q_1) edge  node {$a$} (q_2)
	(q_2) edge  node {$a$} (q_0)
	(q_2) edge[bend left, above]  node {$b$} (q_3)
	(q_3) edge[bend left, below]  node {$b$} (q_2);
	\end{tikzpicture}
\end{center}
\begin{itemize}
	

a(0, 1).\\
a(1, 2).\\
a(2, 0).\\
b(2, 3).\\
b(3, 2).\\

