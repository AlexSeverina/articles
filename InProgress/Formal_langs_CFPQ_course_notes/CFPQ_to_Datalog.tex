\section{От CFPQ к вычислению Datalog-запросов}\label{Subsection Datalog}
Рассмотрим грамматику  $S -> aSb | SS | \varepsilon$, заданную через набор предикатов:
\begin{itemize}
	\item a(i, w) --- Предикат, соответствующий терминалу. Обращается в True, если на i-том месте в строке w стоит символ a
	\item S(i, j, w) --- Предикат, соответствующий нетерминалу. Обращается в True, если выполняется одно из условий:
	\begin{enumerate}
		\item $i == j \quad(\varepsilon)$
		\item $\exists k: i \leq k \leq j \And S(i, k - 1, w) \And S(k, j, w)  \quad (SS)$
		\item  ${a(i, w) \And S(i+1, j-1, w) \And b(j-1, w)} \quad (aSb)$
	\end{enumerate}
\end{itemize}

Таким образом S(0, |w|, w) покажет, выводится ли строка w из данной грамматики,
а S(\_,\_,w) даст нам список всех цепочек внутри w, выводящихся из S.

\subsection{Datalog\footnote{\url{https://en.wikipedia.org/wiki/Datalog}}}
Datalog --- декларативный логический язык программирования. Используется для написания запросов к дедуктивным базам данных\footnote{\url{https://en.wikipedia.org/wiki/Deductive_database}}. Программы на даталоге вылядят таким образом:
\begin{enumerate}
	\item Набор фактов (часто факты находятся в базе данных):
	\begin{itemize}
		\item $a(0).$
		\item $b(1).$
		\item $a(2).$
		\item $b(3).$
		\item $s(I, I).$
	\end{itemize}
	\item Набор правил:
	\begin{itemize}
		\item $s(I, J) := s(I, K-1), s(K,J), (I \leq K \leq J).$
		\item $s(I,J):=a(I), s(I+1, J-1),b(J)$
	\end{itemize}
	\item Запросы:
	\begin{itemize}
		\item $?- s(I, J)$
	\end{itemize}
\end{enumerate}
Таким образом мы описали на даталоге строку через набор фактов, грамматику, указанную выше, через набор фактов и правил и сделали запрос на все цепочки, выводящиеся из S. 

\textbf{NB!} Обратите внимание, что строки, начинающиеся с большой буквы, в даталоге считаются переменными. Также важно, что все переменные неявно квантифицированны.

\textbf{NB!} В даталоге отсутствуют функциональный символы (но есть в реализациях), а отрицание ограничено.
\subsection{Datalog для работы с графами}
Рассмотрим, как описать на даталоге представленный граф
\begin{center}
	\begin{tikzpicture}[shorten >=1pt,on grid,auto]
	\node[state] (q_0)   {$0$};
	\node[state] (q_1) [above right=of q_0] {$1$};
	\node[state] (q_2) [right=of q_0] {$2$};
	\node[state] (q_3) [right=of q_2] {$3$};
	\path[->]
	(q_0) edge  node {$a$} (q_1)
	(q_1) edge  node {$a$} (q_2)
	(q_2) edge  node {$a$} (q_0)
	(q_2) edge[bend left, above]  node {$b$} (q_3)
	(q_3) edge[bend left, below]  node {$b$} (q_2);
	\end{tikzpicture}
\end{center}
$a(0, 1).\\
a(1, 2).\\
a(2, 0).\\
b(2, 3).\\
b(3, 2).\\
S(I,I).\\$
Теперь зададим рассмотренную выше грамматику для работы с графом.\\
$s(I, I).\\
s(I,J) := s(I, K-1),s(K, J).\\
s(I, J):= a(I, L),S(L,M),b(M,J).\\$
Тогда запрос $?-s(I, J)$ выдаст нам все возможные пути в графе.\\

\subsection{Алгоритм Эрли}
Для парсинга контекстно-свободных грамматик может использоваться алгоритм Эрли.
Рассмотрим грамматику $G=(N,T,P,S)$, слово $a_1...a_n$,
и правило $A \rightarrow \alpha\beta$. Тогда запись $[A\rightarrow \alpha \bullet \beta](i,j), j \in [1..n]$ будет означать, что:
\begin{itemize}
	\item $\alpha \xrightarrow{\smash{*}} a_i_+_1...a_j$ (Цепочка $a_i_+_1...a_j$ выводится из $\alpha$)
	\item $S \xrightarrow{\smash{*}} a_1...a_jA_\gamma$ (Последовательность $a_1...a_j$ выводится из $S$)
\end{itemize}

Вывод записей\\

$\frac{S \rightarrow \alpha \in P}{[S \rightarrow \bullet \alpha](0,0)}$ Init\\

$\frac{\left[A \rightarrow \alpha \bullet a_{j+1} \beta\right](i, j)}{\left[A \rightarrow \alpha a_{j+1} \bullet \beta\right](i, j+1)}$ Scan\\

$\frac{[A \rightarrow \alpha \cdot B \beta](i, j) \quad B \rightarrow \gamma \in P}{[B \rightarrow \bullet \gamma](j, j)}$ Predict\\

$\frac{[A \rightarrow \alpha \cdot B](i, j) \quad[B \rightarrow \gamma \bullet](j, k)}{[A \rightarrow \alpha B \bullet \beta](i, k)}$ Complete\\

