\section{Алгоритм на основе восходящего анализа}

Традиционно, алгоритмы, применияемые для анализа языков программирвания как раз умеют строить дерево разбора --- то, что нам надо.
Только нам бы лес.
Вот и посмотрим, как это можно сделать.

Сперва погововрим про классический синтаксический анализ, потом про его адоптацию к анализу графов.

\subsection{Восходящий синтаксический анализ}

Основы LR-анализа.

LR-автомат. Ситуации (item).

Таблицы, конфликты.

\begin{example}
Пример автомата и таблиц.
\end{example}

\begin{example}
Ну и пример разбора.
\end{example}


На практике конфликты стараются решать ещё и на этапе генерации.
Да, реальные тулы могут сгенерировать парсер по неоднозначной грамматике: из переноса или свёртки выбирать перенос, из нескольких свёрток --- первую в каком-то порядке (обычно в порядке появления соответствующих продукций в граммтике).

Про модификации: SLR, LALR --- меньше конфликтов. иногда больше таблицы.

Немного про рекурсивно-восходящй анализ.

Но вообще, бывают обобщённые анализаторы, которые умеют обрабатывать все конфликты.

Томита --- вообще говоря не все граммтики, RNGLR~\cite{Scott:2006:RNG:1146809.1146810} --- все грамматики, но вообще говоря не за куб, а за произвольный полином, более продвинутый BRNGLR~\cite{!!!} --- все граммтики за куб.

Куча интересностей и подробностей~\cite{DBLP:phd/ethos/Economopoulos06}.

Общая идея --- объединение состояний. 

\begin{example}
Ну и пример с конфликтами и объединением состояний.
\end{example}


\subsection{Кс запросы}


Наша реализация~\cite{10.1007/978-3-319-41579-6_22}

Конфликты типа перенос-перенос --- ветвления в графах.

Слияние состояний в циклах.

Проходящие редукции.

А почему терминируется?


\subsection{Вопросы и задачи}
\begin{enumerate}
\item Постройте автомат для грамматики
\item Постройте таблицу для автомата из задачи
\item В том числе дать неоднозначную грамматику
\item Запустить, постоить деревья, стеки и т.д.
\item Реализовать рекурствно-восходящий анализ
\item Реализовать !!!!
\end{enumerate}
