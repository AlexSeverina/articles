\section{Алгоритм на основе нисходящего анализа}

GLL~\cite{Grigorev:2017:CPQ:3166094.3166104}

Другие реализации~\cite{MEDEIROS201975}

\subsection{Нисходящий синтаксический анализ}

Рекурсивный спуск, LL, таблицы, неоднозначности, левая рекурсия.

\subsubsection{Рекурсивный спуск}

\subsubsection{LL(k)-алгоритм синтаксического анализа}

LL(k)-алгоритм синтаксического анализа~--- нисходящий анализ без отката, но с предпросмотром.
Решение о том, какую продукцию применять, принимается на основании k следующих за текущим символом.
Временная сложность алгоритма $O(n)$, где $n$~--- длина слова.

Алгоритм использует входной буфер, стек для хранения промежуточных данных и таблицу анализатора, которая управляет процессом разбора.
В ячейке таблицы указано правило, которое нужно применять, если рассматривается нетерминал $A$, а следующий символ строки~--- $t$.
Также в таблице выделена отдельная колонка для $\$$~--- маркера конца строки.

\begin{center}
  \begin{tabular}{ c || c | c | c | c }
             & $\dots$ & t & $\dots$ & $\$$ \\ \hline
    $\dots$  & $\dots$ & $\dots$ & $\dots$ & $\dots$ \\ \hline
    $A$  & $\dots$ & $A \to \alpha$ & $\dots$ & $\dots$ \\ \hline
    $\dots$  & $\dots$ & $\dots$ & $\dots$ & $\dots$
  \end{tabular}
\end{center}

Для построения таблицы вычисляются множества $\first[k]$ и $\follow[k]$.

\begin{definition}
  Пусть $G = \langle N, \Sigma, P, S \rangle$~--- КС-грамматика. Множество $\first[k]$ определено для сентециальной формы $\alpha$ следующим образом:
  \[ \first[k](\alpha) = \{ \omega \in \Sigma^* \mid \alpha \derives{} \omega \text{ и } |\omega| < k \text{ либо } \exists \beta: \alpha \derives{} \omega \beta \text{ и } |\omega| = k \} \text{, где } \alpha, \beta \in (N \cup \Sigma)^* \]
\end{definition}

\begin{definition}
  Пусть $G = \langle N, \Sigma, P, S \rangle$~--- КС-грамматика. Множество $\follow[k]$ определено для сентециальной формы $\beta$ следующим образом:
  \[\follow[k](\beta) = \{ \omega \in \Sigma^* \mid \exists \gamma, \alpha: S \derives{} \gamma \beta \alpha \text{ и } \omega \in \first[k](\alpha) \} \]
\end{definition}

В частном случае для $k = 1$:

\[ \first(\alpha) = \{ a \in \Sigma \mid \exists \gamma \in (N \cup \Sigma)^*: \alpha \derives{} a \gamma \} \text{, где } \alpha \in (N \cup \Sigma)^* \]

\[ \follow(\beta) = \{ a \in \Sigma \mid \exists \gamma, \alpha \in (N \cup \Sigma)^* : S \derives{} \gamma \beta a \alpha \} \text{, где } \beta \in (N \cup \Sigma)^*  \]

Множество $\first$ можно вычислить, пользуясь следующими соотношениями:

\begin{itemize}
  \item $\first(a \alpha) = \{a\}, a \in \Sigma, \alpha \in (N \cup \Sigma)^* $
  \item $\first(\varepsilon) = \{\varepsilon\}$
  \item $\first(\alpha \beta) = \first(\alpha) \cup (\first(\beta) \text{, если } \varepsilon \in \first(\alpha))$
  \item $\first(A) = \first(\alpha) \cup \first(\beta) \text{, если в грамматике есть правило } A \to \alpha \mid\beta$
\end{itemize}

Алгоритм для вычисления множества $\follow$:

\begin{itemize}
  \item Положим $\follow(X) = \varnothing, \forall X \in N$
  \item $\follow(S) = \follow(S) \cup \{\$\} \text{, где } S \text{--- стартовый нетерминал}$
  \item Для всех правил вида $A \to \alpha X \beta: \follow(X) = \follow(X) \cup (\first(\beta) \setminus \{\varepsilon\} )$
  \item Для всех правил вида $A \to \alpha X \text{ и } A \to \alpha X \beta \text{, где } \varepsilon \in \first(\beta): \follow(X) = \follow(X) \cup \follow(A)$
  \item Последние два пункта применяются пока есть что добавлять в строящиеся множества.
\end{itemize}

Пример множеств $\first$ для нетерминалов следующей грамматики:

\begin{multicols}{2}
\begin{align*}
  S  &\to a S' \\
  S' &\to A b B S' \mid \varepsilon \\
  A  &\to a A' \mid \varepsilon \\
  A' &\to b \mid a \\
  B  &\to c \mid \varepsilon
\end{align*}

\columnbreak

\begin{align*}
  \first(S)  &= \{ a \} \\
  \first(A)  &= \{ a, \varepsilon \} \\
  \first(A') &= \{ a, b \} \\
  \first(B)  &= \{ c, \varepsilon \} \\
  \first(S') &= \{ a, b, \varepsilon \}
\end{align*}
\end{multicols}

Пример множеств $\follow$ для нетерминалов следующей грамматики:

\begin{multicols}{2}
\begin{align*}
  S  &\to a S' \\
  S' &\to A b B S' \mid \varepsilon \\
  A  &\to a A' \mid \varepsilon \\
  A' &\to b \mid a \\
  B  &\to c \mid \varepsilon
\end{align*}

\columnbreak

\begin{align*}
  \follow(S)  &= \{ \$ \} & \\
  \follow(S') &= \{ \$ \} &(S \to a S')\\
  \follow(A)  &= \{ b \}  &(S' \to A b B S') \\
  \follow(A') &= \{ b \}  &(A \to a A')\\
  \follow(B)  &= \{ a, b, \$ \} &(S' \to A b B S', \varepsilon \in \first(S'))
\end{align*}
\end{multicols}

Таблица заполняется следующим образом: продукции $A \to \alpha, \alpha \neq \varepsilon$ помещаются в ячейки $(A, a)$, где $a \in \first(\alpha)$, продукции $A \to \alpha$~--- в ячейки $(A, a)$, где $a \in \follow(A)$, если $\varepsilon \in \first(\alpha)$

\begin{example}

Пример таблицы для грамматики $S \to ( S ) \mid \varepsilon$

\begin{center}
\begin{tabular}{ r || c | c || c | c | c }
N & $\first$ & $\follow$ & ( & ) & $\$ $ \\ \hline
$S$ & $\{ (, \varepsilon \}$ & $\{ ), \$ \}$ & $S \rightarrow (S)$ & $S \rightarrow \varepsilon$ & $S \rightarrow \varepsilon$
\end{tabular}
\end{center}

\end{example}

А что, если в ячейку несколько записей? Значит нам не повезло и граммтика неоднозначна. Можно попробовать увеличить $k$. Но и это может не помочь. Когда?

А что будет, если есть леворекурсивные правила?

Интерпретатор автомата принимает входную строку и построенную управляющую таблицу и работает следующим образом.
В каждый момент времени конфигурация автомата это позиция во входной строке и стек.
В начальный момент времени стэк пуст, а позиция во входной строке соответствует её началу.
На певом шаге в стек добавляются последовательно сперва симаол концы строки, затем стартовый нетерминал.
На каждом шаге анализируется существующая конфигурация и совершается одно из действий.
\begin{itemize}
\item Если текущая позиция --- конец строки и вершина стека --- символ конца строки, то успешно завершаем разбор.
\item Если текушая вершина стека --- терминал, то проверяем, что позиция в строке соответствует этому терминалу. Если да, то снимаем элемент со стека, сдвигаем позицию на единицу и продолжаем разбор. Иначе завершаем разбор с ошибкой.
\item Если текущая врешина стека --- нетерминал $N_i$ и текущий входной символ $t_j$, то ищем в управляющей таблице ячейку с координатими $(N_i, t_j)$ и записываем на стек содержимое этой ячейки.
\end{itemize}

\begin{example}Пример работы LL анализатора.
  Таблца вида (стек, указатель во входе, комментарии)
\end{example}

Проблемы с левой рекурсией.

А ещё надо бы деревья научиться строить.

\begin{example}Пример работы LL анализатора с деревом.
  Таблца вида (стек, указатель во входе, дерево, комментарии)
\end{example}

Итого. По некоторым граммтикам можно построить LL(k) анализатор (назовём их LL(k) граммтиками), но не по всем.
С левой рекурсией, конечно, можно бороться, существуют алгоритмы устранения левой и скрытой левой рекурсии, а вот с неодносзначностями ничего не поделаешь.



\subsection{GLL и его применение для КС запросов}

Можно построить анализатор, работающий с произвольными КС-граммтиками.
Generalized LL (GLL)~\cite{Scott:2010:GP:1860132.1860320,10.1007/978-3-662-46663-6_5}

\begin{definition}[Позиция в грамматике (grammar slot)]
\end{definition}

Наблюдение. Один из основных шагов анализа --- попытаться распознать какой-то нетерминал начиная с какой-то позиции.
Проблема в том, что попробовать сделать это можно иногда более чем одним способом (иначе у нас бы получился LL и всё было бы хорошо). Однако количество различных таких ``попыток'' конечно: не более чем попытаться распознать каждый нетерминал начиная с каждой позиции во входе. При этом последовательность таких попыток задаётся выбранным правилом на текущем шаге, как в LL. Например, так. Мне нужно распознать нетерминал $N_i$ начная с позиции $j$. Таблица говорит мне, что для этого я должен воспользоваться правилом $N_i \to t_l \ N_k$. Это значит, что я должен прочиать токен, переместиться в позицию $j+1$ и попробовать распознать из неё нетерминал $N_k$. Таким образом, у на появились события (распознать нетерминал начиная с позиции) и связи между ними --- это удобно рисовать в виде графа, где события --- вершины, а связи --- рёбра.

А ещё у нас есть описание состояния всей это системы: позиция в граммтике, позиция во входе, указатель на вершину стека.

\begin{definition}[Дескриптор]
\end{definition}

Взяв очередной дескриптор мы без какой-либо дополниельной информации можем продолжить анализ входа из состояния, задаваемого этим дескриптором.
Нам надо будет поддерживать очередь дескрипторов на обработку: в неё будем класть дескрипторы, которые надо обработать. А на каждом шаге доставать очередной и обрабатывать.

Давайтие изобразим пример (ссыль на пример прошлого раздела) в таких терминах.
\begin{example}
\end{example}

У нас получился стек в виде графа. Это граф-структурированный стек или GSS (Graph Structured Stack), который впервые бвл предложен Масару Томитой ()~\cite{!!!}, но в контексте восходящего анализа.



Теперь возьмём грамматику, которая содержит левую рекурсию и неоднозначна.

Построим для неё управляющую таблицу.


В некоторых ячейках больше одной инструкции.

Будем действовать так, как действовал бы обычный LL.

\begin{example} GLL.

  И тут у нас сперва левая рекурсия, потом ещё и неоднозначности.

  + надо запоминать, кого доставали со стека.

  + надо запоминать дескрипторы.

\end{example}


Но нам надо строить SPPF, чтобы получать пути.
Прикрутим просто в вершину ещё и ссылку на соответствующий узел дерева.

Ну а теперь всё это на граф~\cite{Grigorev:2017:CPQ:3166094.3166104}
Заметим, что позиции всё так же вершины графа.
Дальше всё само собой.

\begin{example} GLL на графе с SPPF.
\end{example}


Детали реализации: иногда лучше не очередь дескрипторов, а стек, так как выше локальность данных --- мы кладём пачку дескрипторов, соответсвующих исходящим рёбрам. Зависит от структуры представления графа, но если это список смежности, что исходящие хранятся рядом и их лучше обработать сразу.

\subsection{Вопросы и задачи}
\begin{enumerate}
  \item Задача 1
  \item Задача 2
\end{enumerate}
