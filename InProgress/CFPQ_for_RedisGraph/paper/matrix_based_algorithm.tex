\section{Matrix-based Algorithm for CFPQ}

The matrix-based algorithm for CFPQ was proposed by Rustam Azimov~\cite{Azimov:2018:CPQ:3210259.3210264}.
This algorithm can be expressed in terms of operations over boolean matrices (see listing~\ref{lst:algo1}) which is an advantage for implementation.

\begin{algorithm}
  \floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Context-free path quering algorithm}
\label{lst:algo1}
\Function{contextFreePathQuerying}{D, G}

    \State{$n \gets$ the number of nodes in $D$}
    \State{$E \gets$ the directed edge-relation from $D$}
    \State{$P \gets$ the set of production rules in $G$}
    \State{$N \gets$ the set of nonterminals in $G$}
    \State{$T \gets \{T^{A_i} \mid A_i \in N, T^{A_i}$ is a matrix $n \times n$ in which each element is \texttt{false}\}}
    \ForAll{$(i,x,j) \in E$}
        \Comment{Matrix initialization}
        \For{$A_k \mid A_k \to x \in P$}
          \State{$T^{A_k}_{i,j} \gets \texttt{true}$}
        \EndFor
    \EndFor
    \For{$A_i \mid A_i \to \varepsilon \in P$}
       \State{$T^{A_i}_{i,i} \gets \texttt{true}$}
    \EndFor

    \While{any matrix in $T$ is changing}
        \Comment{Transitive closure calculation}
        \For{$A_i \to A_j A_k \in P$}
          \State{$T^{A_i} \gets T^{A_i} + (T^{A_j} \times T^{A_k})$}
        \EndFor
    \EndWhile
\State \Return $T$
\EndFunction
\end{algorithmic}
\end{algorithm}

Here $D = (V, E)$ is the input graph and $G = (N,\Sigma,P)$ is the input grammar.
For each matrix $T^{A_k}$, $T^{A_k}[i,j] = \texttt{true} \iff \exists \pi = v_i \ldots v_j $---path in $D$, such that $A_k \xRightarrow[G]{*} \omega(\pi) $, where $\omega(\pi)$ is a word formed by the labels along the path $\pi$.
Thus, this algorithm solves the reachability problem, or, according to Hellings~\cite{hellingsRelational}, implements relational query semantics.

The performance-critical part of the algorithm is boolean matrix multiplication.
Note, that if the matrices $T_{N_j}$ and $T_{N_k}$ have not been changed at the previous iteration, then we can skip update operation.
Such optimization can improve performance.
Also, it is important for applications that real-world data is often sparse, so it should be a better solution to use libraries which manipulate with sparse matrices.

As we can see, CFPQ can be naturally reduced to linear algebra.
Linear algebra for graph problems is an actively developed area.
One of the most important results is a GraphBLAS API which provides a way to operate over matrices and vectors over user-defined semirings.
In this paper we use SuteSparse implementation of GraphBLAS and boolean semiring.
All our implementations are based on the optimized version of the algorithm.
