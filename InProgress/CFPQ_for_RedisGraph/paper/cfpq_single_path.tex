\section{Matrix Based CFPQ for Single-Path Querying}
In this section, we propose the matrix-based algorithm for CFPQ w.r.t. the single-path query semantics (see listing~\ref{lst:algo2}). This algorithm constructs the set of matrices $T$ with PathIndexes as elements.
{\small
	\begin{algorithm}
		\floatname{algorithm}{Listing}
		\begin{algorithmic}[1]
			\caption{CFPQ algorithm w.r.t. single-path query semantics}
			\label{lst:algo2}
			\Function{evalCFPQ}{$D=(V,E), G=(N,\Sigma,P)$}
			\State{$n \gets$ |V|}
			\State{$T \gets \{T^{A_i} \mid A_i \in N, T^{A_i}$ is a matrix $n \times n$, $T^{A_i}_{k,l} \gets \bot$ \} }
			\ForAll{$(i,x,j) \in E$, $A_k \mid A_k \to x \in P$}
			%\Comment{Matrices initialization}
			%\For{$A_k \mid A_k \to x \in P$}
			{$T^{A_k}_{i,j} \gets (i,j,i,1,1)$}
			%\EndFor
			\EndFor
			\For{$A_k \mid A_k \to \varepsilon \in P$}
			{$T^{A_k}_{i,i} \gets (i,i,i,1,0)$}
			\EndFor
			
			\While{any matrix in $T$ is changing}
			%\Comment{Transitive closure calculation}
			\For{$A_i \to A_j A_k \in P$}
			{ $T^{A_i} \gets T^{A_i} + (T^{A_j} \odot T^{A_k})$ } 
			\EndFor
			\EndWhile
			\State \Return $T$
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
}

After constructing the set of matrices $T$ for every node pair $i, j$ and nonterminal $A$ we can extract a path $i \pi j$ from $i$ to $j$ such that $A \xRightarrow[G]{*} l(\pi)$ if such path exists. We also propose the algorithm (see listing~\ref{lst:algo3}) for extracting one of those paths which forms a string with minimal height of derivation tree. Our algorithm returns the empty path $[]$ if such a path does not exist for given $i,j,A$.

{\small
	\begin{algorithm}
		\floatname{algorithm}{Listing}
		\begin{algorithmic}[1]
			\caption{Path extraction algorithm}
			\label{lst:algo3}
			\Function{extractPath}{$i, j, A, T=\{T^{A_i}\}, G=(N,\Sigma,P)$}
			\State{$index \gets T^{A}_{i,j}$ }
			
			\If{$index = \bot$}
			\State \Return $[]$
			\EndIf
			
			\If{$index.height = 1$}
			\ForAll{$ x \mid (i,x,j) \in E$}
			\If{$A \to x \in P$}
			\State \Return $[(i,x,j)]$
			\EndIf
			\EndFor
			\EndIf
			
			\ForAll{$A \to B C \in P$}
			\State{$index_B \gets T^{B}_{i,index.middle}$ }
			\State{$index_C \gets T^{C}_{index.middle,j}$ }			
			\If{$(index_B \neq \bot) \wedge (index_C \neq \bot)$}
			\State{$maxH \gets max(index_B.height, index_C.height)$ }
			\If{$index.height = maxH + 1$}
			
						
			\State{$\pi_1 \gets$ \Call{extractPath}{$i, index.middle, B, T, G$}}
			\State{$\pi_2 \gets$ \Call{extractPath}{$index.middle, j, C, T, G$}}
			\State \Return $\pi_1 + \pi_2$
			\EndIf
			\EndIf
			\EndFor
			\EndFunction
		\end{algorithmic}
	\end{algorithm}
}

Theorems on correctness.

Complexity analysis.

\subsection{Example?}
