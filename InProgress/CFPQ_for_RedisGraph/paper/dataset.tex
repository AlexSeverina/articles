\section{Dataset description}

In our evaluation we use combined dataset which contains the following parts.
\begin{itemize}
\item CFPQ\_Data dataset which provided in\footnote{CFPQ\_Data data set GitHub repository: \url{https://github.com/JetBrains-Research/CFPQ_Data}. Access date: 12.11.2019.}~\cite{Mishin:2019:ECP:3327964.3328503} and contains both syntethic and real-world graphs and queryes.
Real-world data includes RDFs, syntatic cases include theoretical worst-case and random graphs.
\item Dataset which provided in~\cite{Kuijpers:2019:ESC:3335783.3335791}. We integrate both Geospecies and Synthetic data sets into CFPQ\_Data and use it in our evaluation.
\item New bigger RDFs, such as !!!!. 
In ~\cite{Mishin:2019:ECP:3327964.3328503} was shown that matrix-based algorithm is performad enough to handle bigger RDFs than used in initial data sets, such as~\cite{RDF}. 
So, we add a number of big RDFs to CFPQ\_Data and use them in our evaluation. 
\end{itemize}

The variants of the \textit{same generation query}~\cite{FndDB} is used in almost all cases because it is an important example of real-world queries that are context-free but not regular.

\textbf{[RDF]} The set of the real-world RDF files (ontologies) from~\cite{RDF} and two variants of the same generation query which describes hierarchy analysis.
The first query is the grammar $G_4$:
\[
 \begin{array}{lcl}
   s  \rightarrow \textit{SCOR} \ s \ \textit{SCO}   & \quad & s  \rightarrow \textit{TR} \ s \ \textit{T}     \\
   s  \rightarrow \textit{SCOR} \ \textit{SCO}       & \quad & s  \rightarrow  \textit{TR}  \ \textit{T}

 \end{array}
 \]
The second one is the grammar $G_5$: $s \rightarrow \textit{SCOR} \ s \ \textit{SCO} \ | \  \textit{SCO}$.

\textbf{[Worst]} The theoretical worst case for CFPQ time complexity proposed by Hellings~\cite{hellingsPathQuerying}: the graph is two cycles of coprime lengths with a single common vertex.
The first cycle is labeled by the open bracket and the second cycle is labeled by the close bracket.
Query is a grammar for the $A^nB^n$ language.
The example of such graph and grammar is presented in figure:

        \[
         \begin{array}{l}
           s \rightarrow A \ s \ B \\
           s \rightarrow A \ B
         \end{array}
         \]


\textbf{[Full]} The case when the input graph is sparse, but the result is a full graph.
Such a case may be hard for sparse matrices representations.
As an input graph, we use a cycle, all edges of which are labeled by the same token.
As a query we use two grammars which describe the sequence of tokens of arbitrary length: the simple ambiguous grammar $G_2$: $s \rightarrow  s \ s \ | \ A$,  and the highly ambiguous grammar $G_3$: $s \rightarrow s \ s \ s \ | \ A$.

\textbf{[Sparse]} Sparse graphs from~\cite{fan2018scaling} are generated by the GTgraph graph generator, and emulate realistic sparse data.
Names of these graphs have the form \texttt{Gn-p}, where \texttt{n} corresponds to the total number of vertices, and \texttt{p} is the probability that some pair of vertices is connected.
The query is the same generation query represented by the grammar $G_1$ (figure~\ref{fig:grammar_example}).
