\section{Conclusion and Future Work}
In this work, we provide the first matrix-based algorithm for CFPQ with single-path query semantics.
Also, we implemented a CPU and GPGPU based CFPQ for RedisGraph and showed that CFPQ with relational and single-path query semantics can be performant enough to analyze real-world data.
However, our implementations are prototypes and we plan to provide full integration of CFPQ to RedisGraph.
First of all, it is necessary to extend Cypher graph query language used in RedisGraph to support syntax for specification of context-free constraints.
There is a proposal which describes such syntax extension\footnote{Proposal with path pattern syntax for openCypher: \url{https://github.com/thobe/openCypher/blob/rpq/cip/1.accepted/CIP2017-02-06-Path-Patterns.adoc}. Access date: 12.11.2019}. It is shown that context-free constraints can be expressed with the proposed syntax and we plan to support this syntax in libcypher-parser\footnote{Web page of libcypher-parser project: \url{http://cleishm.github.io/libcypher-parser/}. Access date: 12.11.2019} used in RedisGraph.

The best our current GPU-based implementations (RG\_SPARSE\textsubscript{rel} and RG\_SPARSE\textsubscript{path}) have shown that it makes sense to use a GPU to speed up CFPQ on real world data. But amount of the GPU RAM usually less than the CPU RAM so one of the direction of future research is a solution that uses systems with multiple GPU.

Our implementations compute relational or single-path semantics of a query, but some problems require to find all paths which satifies the constraints.
To the best of our knowledge, there is no matrix-based algorithm for all-path query semantics, thus we see it as a direction for future research.

Another important open question is how to update the query results dynamically when data changes.
The mechanism for result updating allows one to recalculate query faster and use the result as an index for other queries. There is a theoretical results in this area~\cite{10.1007/978-3-662-54458-7_16}, but they should be evaluates in practice.

Also, further improvements of the dataset are required.
For example, it is necessary to include real-world cases from the area of static code analysis~\cite{Zheng:2008:DAA:1328897.1328464,veduradabatch,LPAR-21:Cauliflower_Solver_Generator_for}.
Another direction is to find new applications required CFPQ, such as for example, graph segmentation~\cite{8731467}. 
