\section{Introduction}

Creation of data-centric applications which use graph structured data (graph data bases, social graph, code analysis applications) requires 
developed in general-purpose languages 
special languages for graph traversing/querying (SPARQL, cypher, gremlin, etc)
, data access, languages integration for graph-structured data (or graph DB) access.

One of type of avigation queries is a language-constarined path querying~\cite{!!!}.
Many of languages allow users to specify regular constraints, but some tasca requerd more powerfull -- context-free constarints.
For example, classical same generation query is not a regular, also CFL reacability can be used for static code analysis.
Not only reachability information, but strucure of results: for debugging and futher processing.
Structural representation of result: not only reachability, but paths; debuggibg~\cite{structForDebugging}; understanding.

Theoretical research, but no languages for applications develoer
Some different formulation of the similar problems: Language-constrained path querying and language reachability.
Language-constrained path querying, Yannakakis~\cite{Yannakakis}. 
Hellings~\cite{ConjCFPathQuery, Hellings16}, RDF~\cite{CFGonRDF}, etc~\cite{QueryGraphWithData, RegularDBQuery, GraphQueryWithEarley, FLCpathProblem, graphDB}


Integration with general purpose programming languages is a classical problem~\cite{stringEmbeddedLanguagesProblem}.
Languge integration problem: special DSLs for SQL, ORM, Linq.
Transperent integration inpo gp programming language: static correctness, typing, composability
Similar to problem with SQL : correctnes, type safety, etc. Special DSL vs Combinators (LINQ~\cite{LINQ1, LINQ2}, etc)
cfSparql --- separated language
Special graph query languages. SPARQL~\cite{sparql}, cypher~\footnote{https://neo4j.com/developer/cypher-query-language/}, gremlin~\cite{gremlin}
String-embedded DSLs.


Language may be specified with grammar.
In this area parer combinator technique is a classiacal alternative for specialized DSLs for grammar specification. 
An idea to use combinators for graph traversing proposed in~\cite{ScalaGraphParsing}, but has some problems: cycles, left-recursive grammars
Parser-combinators is one of classical approach for parsing!!!.
Scala combinators for graph~\cite{ScalaGraphParsing} --- one of attempt to adopt combinators technique for graph processing.
Only an idea of combinators using, but language class and restrictions are not discussed.
Problems with cycles in graph. 
Ad-hoc solution.
We propose a general solution.
Problems with left-recursive grammars(???Should be checked)

Classical combinators are based on LL(k) and has restrictions: left-recursive grammars.
GLL~\cite{scott2010gll} can handle arbitrary context-free grammars, SPPF~\cite{SPPF}

Combinators for arbitrary grammars on GLL and GLL for graphs. 
Parser combinators library bsed on GLL --- 
Meerkat~\footnote{\url{https://github.com/meerkat-parser/Meerkat}}~\cite{Meerkat}. 
Can handle arbitrary context-free grammars
Written in Scala

We show how to compose this ideas and get general solution for arbitrary CF grammars combinators, structural representation.
We make the following contributions in this paper.

\begin{enumerate}
\item Combinators for CF path querying with structural representation of result.
 Transparent integration of query language into general-purpose programming language. Compositionality (subquerying mechanism)
\item Implementation in Scala. Generalization of linear parsing. Integration with Neo4J graph data base. Available on gitHub:\url{https://github.com/YaccConstructor/Meerkat}
\item Evaluation on realistic data, which shows that it is applicable. Comparison  with other tools 
for CF path querying.
\end{enumerate}