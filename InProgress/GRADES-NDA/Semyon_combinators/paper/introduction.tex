\section{Introduction}

When you develop a data-centric application, you want to use general purpose programming language and have an transparent and native access to data sources.
The naiv approach, named string-embedded DSLs, which means that you have a driver which can execute a string with query and return (posibly untyped) result have some serious problems.
First of all, it is necessary to use special DSL which may require additional knolages from developer.
Moreover, string-embedded languahe is a source of errors and vulnerabilities which static detection is very hard~\cite{stringEmbeddedLanguagesProblem}.  

Applications which use graph structured data is also have such problem. 
There is a number of special languages for graph traversing/querying,
 such as SPARQL~\cite{sparql}, Cypher~\footnote{Cypher languge web page: \url{https://neo4j.com/developer/cypher-query-language/}. Access date: 16.01.2018}, Gremlin~\cite{gremlin},
 but if you want to create an application for data analysis or static code analysis~\cite{!!!}, 
It is necessary to integrate these languages into gp programming languge.
, data access, languages integration for graph-structured data (or graph DB) access.


Languge integration problem: special DSLs for SQL, ORM, Linq.
Transperent integration inpo gp programming language: static correctness, typing, composability
Similar to problem with SQL : correctnes, type safety, etc. Special DSL vs Combinators (LINQ~\cite{LINQ1, LINQ2}, etc)

String-embedded DSLs.


These leeds to creation such special techniques as Object Relationship Mapping (ORM) or Language Integrated Query (LINQ) which uses not only for relational data bases manipulation, but for graph DB too.



One of useful type of graph queries is a language-constarined path queries~\cite{FLCpathProblem}.
Many of languages allow users to specify regular constraints, but some tascs requerd more powerfull -- context-free constarints.
For example, classical same generation query is not a regular, also CFL reacability can be used for static code analysis.
For some tasks not only reachability information. Strucure of results: for debugging and futher processing.
Structural representation of result: not only reachability, but paths; debuggibg~\cite{structForDebugging}; understanding.

Theoretical research, but no languages for applications develoer
cfSparql --- separated language
Some different formulation of the similar problems: Language-constrained path querying and language reachability.
Language-constrained path querying, Yannakakis~\cite{Yannakakis}. 
Hellings~\cite{ConjCFPathQuery, Hellings16}, RDF~\cite{CFGonRDF}, etc~\cite{QueryGraphWithData, RegularDBQuery, GraphQueryWithEarley, FLCpathProblem, graphDB}

One of the natural way to specify any language is specify its formal grammar.
In practice of development programming languages processors there are two classical approach to do specify the grammar.
One of them is by using special DSL for grammar specification.
The classical alternative way is a parer combinator technique which.

Classical combinators are based on LL(k) and has restrictions: left-recursive grammars.
GLL~\cite{scott2010gll} can handle arbitrary context-free grammars, SPPF~\cite{SPPF}
There is a solution whish use GLL for CFPQ~\cite{GrigorevR16}
Combinators for arbitrary grammars on GLL. 
Parser combinators library bsed on GLL --- Meerkat~\footnote{Meerkat project repository: \url{https://github.com/meerkat-parser/Meerkat}. Access date: 16.01.2018}~\cite{Meerkat}. 
Can handle arbitrary context-free grammars
Written in Scala


An idea to use combinators for graph traversing proposed in~\cite{ScalaGraphParsing}, but has some problems: cycles, left-recursive grammars
Parser-combinators is one of classical approach for parsing!!!.
Scala combinators for graph~\cite{ScalaGraphParsing} --- one of attempt to adopt combinators technique for graph processing.
Only an idea of combinators using, but language class and restrictions are not discussed.
Provide approximated handling of cycles in input graph and have a problem with left-recursive grammars. 

We propose a general solution.
We show how to compose these ideas and get general solution for transparent integration of context-free constrained path querying language into general-purpose programming language.

We make the following contributions in this paper.

\begin{enumerate}
\item We show that it is possible to create parser combinators for context-free path querying which supports both arbitrary contex-free grammars and arbitrary graphs and provide finite structural representation of query result.
\item We provide the implementation of parser combinators library in Scala. This library provide integration with Neo4J graph data base. Source code available on GitHub:\url{https://github.com/YaccConstructor/Meerkat}.
\item We perform an evaluation on realistic data. 
Also we compare performance of our library with other GLL-bsed CFPQ tool and with Trails library.
As a result we conclude that our solution provide good expressivity and performance to be applied for real-world problems. 
\end{enumerate}