\section{Evaluation}

\begin{table*}[t]
\centering
\begin{tabular}{|l|l|lll|lll|}
\hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Ontology}} & \multicolumn{1}{c|}{\multirow{2}{*}{Number of tripples}} & \multicolumn{3}{c|}{Query 1}  & \multicolumn{3}{c|}{Query 1}\\ \cline{3-8} 
\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Number of\\  results\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}In memory graph \\ query time (ms)\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}DB query \\ time (ms)\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Number of\\ results\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}In memory graph \\ query time (ms)\end{tabular}} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}DB query \\ time (ms)\end{tabular}} \\ \hline
\hline
atom-primitive              & 425  & 15454 & 174 & 236 & 122  & 49 & 56 \\
biomedical-mesure-primitive & 459  & 15156 & 328 & 398 & 2871 & 36 & 52 \\
foaf                        & 631  & 4118  & 23  & 42  & 10   & 1  & 2  \\
funding                     & 1086 & 17634 & 151 & 175 & 1158 & 18 & 23 \\
generations                 & 273  & 2164  & 9   & 27  & 0    & 0  & 0  \\
people\_pets                & 640  & 9472  & 68  & 87  & 37   & 2  & 3  \\
pizza                       & 1980 & 56195 & 711 & 792 & 1262 & 44 & 56 \\
skos                        & 252  & 810   & 4   & 29  & 1    & 0  & 1  \\
travel                      & 277  & 2499  & 23  & 93  & 63   & 2  & 2  \\
univ-bench                  & 293  & 2540  & 19  & 74  & 81   & 2  & 3  \\
wine                        & 1839 & 66572 & 578 & 736 & 133  & 5  & 7  \\
\hline
\end{tabular}
\caption{Evaluation results for In Memory Graph and Graph DB}
\label{table:rdfs}
\end{table*}

Some experiments on real data and comarison with existing solutions

\subsection{Ontology querying}

One of well-known graph querying problems is a queries for ontologies \cite{FndDB}. We use Meerkat to evaluate
it on some popular ontologies presented as RDF files from paper \cite{CFGonRDF}. We convert RDF files to a labeled directed graph like the following: for every RDF triple $(subject,\ predicate,\ object)$ we create two edges $(subject,\ predicate,\ object)$ and $(object,\ predicate^{-1},\ subject)$.\\
On those graphs we apply two queries from the paper \cite{GrigorevR16} which grammars are on Fig. \ref{lst:query1}, and Fig. \ref{lst:query2} in two ways.
\begin{itemize}
	\item Convert RDF files to a graph input for meerkat and then directly parse on query 1 and query 2
	\item Convert RDF files to a Neo4j database and then parse this database on given queries
\end{itemize} 
Table \ref{table:rdfs} shows experimental results of those two aproaches over the testing RDF files where $number\ of\ results$ is a number of triples of type $(nonterminal,\ start\ vertex,\ end\ vertex)$
The perfomance is about $2$ times slower than in \cite{GrigorevR16} and shows the same results. If compare the perfomance of in memory graph querying and database querying, the second one is slower in about $2-4$ times.



\begin{figure}[t]
\begin{align*}
& S \rightarrow subClassOf^{-1}\ S\ subClassOf\\
& S \rightarrow type^{-1}\ S\ type\\
& S \rightarrow subClassOf^{-1}\ subClassOf\\
& S \rightarrow type^{-1}\ type
\end{align*}
\caption{Querry 1 grammar}
\label{lst:query1}
\end{figure}

\begin{figure}[t]
\begin{align*}
& S \rightarrow\ B\ subClassOf\\
& B \rightarrow subClassOf^{-1}\ B\ subClassOf\\
& B \rightarrow subClassOf^{-1}\ subClassOf
\end{align*}
\caption{Querry 2 grammar}
\label{lst:query2}
\end{figure}



Integration with Neo4J

\subsection{Static code analysis}

Alias analysis is one of the fundamental static analysis problems\cite{Marlowe}. Alias analysis checks may-alias relations between code expressions and can be formulated as a Context-Free language (CFL) reachability problem\cite{Reps}. In that case program represeted as Program Expression Graph (PEG)\cite{Zheng}. Verticies in PEG are program expressions and edges are relations between them. In a case of analysisng C source code there is two kind of edges \textbf{D}-edge and \textbf{A}-edge.
\begin{itemize}
	\item Pointer dereference edge (\textbf{D}-edge). For each pointer deference $*e$ there is a directed D-edge from $e$ to $*e$.
	\item Pointer assignment edge (\textbf{A}-edge). For each assignment $*e_1=e_2$ there is a directed A-edge from $e_2$ to $*e_1$
\end{itemize}
Also, for the sake of simplicity, there are edges labeled by $\overline{D}$ and $\overline{A}$ which corresponds to reversed D-edge and A-edge, respectively.

The grammar for may-alias problem from \cite{Zheng} presented on Fig. \ref{lst:aliasGrammar}. It consists of two nonterminals \textbf{M} and \textbf{V}. It allows us to make two kind of queries for each of nonterminals \textbf{M} and \textbf{V}.
\begin{itemize}
	\item \textbf{M} production shows that two l-value expression are memory aliases i.e. may stands for the same memory location.
	\item \textbf{V} shows that two expression are value aliases i.e. may evaluate to the same pointer value.
\end{itemize}

We made \textbf{M} and \textbf{V} queries on the code some open-source C projects. The results are presented on the Table \ref{table:staticAnalysis} 

\begin{figure}[t]
\begin{align*}
& M \rightarrow\ \overline{D}\ V\ D\\
& V \rightarrow (M ?\ A)^{*} \ M?\ (A\ M?)^{*}
\end{align*}
\caption{Context-Free grammar for the may-alias problem in syntax}
\label{lst:aliasGrammar}
\end{figure}



\begin{table}[t]
\centering
\begin{tabular}{|l|l|ll|l|}
\hline
\multirow{2}{*}{Program} & \multirow{2}{*}{Code Size (KLOC)} & \multicolumn{2}{c|}{Count of aliases} & \multirow{2}{*}{Time (ms)} \\ \cline{3-4}
 &  & \multicolumn{1}{c|}{M aliases} & \multicolumn{1}{c|}{V aliases} &  \\ 
\hline
\hline
wc-5.0      & 0.5K & 0   & 174  & 350 \\
pr-5.0      & 1.7K & 13  & 1131 & 532 \\
ls-5.0      & 2.8K & 52  & 5682 & 436 \\
bzip2-1.0.6 & 5.8K & 9   & 813  & 834 \\
gzip-1.8    & 31K  & 120 & 4567 & 1585\\
\hline
\end{tabular}
\caption{Running may-alias queries on Meerkat on some C open-source projects}
\label{table:staticAnalysis}
\end{table}


Comparison with GLL

Comparison with ~\cite{ScalaGraphParsing}