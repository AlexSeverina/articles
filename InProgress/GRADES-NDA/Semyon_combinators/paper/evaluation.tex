\section{Evaluation}

In this section we present evalution of Meerkat grph querying library.
We show its perfomance on a classical ontology graphs for in memory graph and for Neo4j database, show application on may-alias static code analysis problem, and compare with Trails \cite{ScalaGraphParsing} library for graph traversals.

All tests are perfomed on a machine running Fedora 27 with quad-core Intel Core i7 2.5 GHz CPU with 8 GB of memory.


\begin{table*}[t]
\centering
\begin{tabular}{|l|l|lllll|lllll|}
\hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Ontology}} & 
\multicolumn{1}{c|}{\multirow{2}{*}{\#tripples}} & 
\multicolumn{5}{c|}{Query 1}  &
\multicolumn{5}{c|}{Query 2}\\ 
\cline{3-12} 
\multicolumn{1}{|c|}{} & 
\multicolumn{1}{c|}{}  &
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\#results\end{tabular}} & 
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}In memory \\ graph (ms)\end{tabular}} & 
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}DB query \\ (ms)\end{tabular}} & 
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Trails\\ (ms)\end{tabular}} & 
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}GLL \\ (ms)\end{tabular}} & 
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}\#results\end{tabular}} &
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}In memory \\ graph (ms)\end{tabular}} &
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}DB query \\ (ms)\end{tabular}} &
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Trails \\ (ms)\end{tabular}} &
\multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}GLL \\ (ms)\end{tabular}} \\
\hline\hline
atom-primitive              & 425  & 15454 & 112 & 167 & 2849 & 232 & 122  & 49 & 52 & 453 & 19 \\
\shortstack[l]{biomedical- \\
 measure-primitive}         & 459  & 15156 & 226 & 247 & 3715 & 482 & 2871 & 34 & 42 & 60  & 26 \\
foaf                        & 631  & 4118  & 16  & 25  & 432  & 29  & 10   & 1  & 2  & 1   & 1 \\
funding                     & 1086 & 17634 & 123 & 152 & 367  & 179 & 1158 & 18 & 23 & 76  & 13 \\
generations                 & 273  & 2164  & 6   & 21  & 9    & 12  & 0    & 0  & 0  & 0   & 0 \\
people\_pets                & 640  & 9472  & 63  & 84  & 75   & 80  & 37   & 2  & 3  & 2   & 1 \\
pizza                       & 1980 & 56195 & 544 & 650 & 7764 & 793 & 1262 & 44 & 47 & 905 & 50 \\
skos                        & 252  & 810   & 4   & 9   & 6    & 6   & 1    & 0  & 1  & 0   & 0 \\
travel                      & 277  & 2499  & 21  & 55  & 34   & 21  & 63   & 2  & 2  & 1   & 2 \\
univ-bench                  & 293  & 2540  & 15  & 43  & 31   & 24  & 81   & 2  & 2  & 2   & 1 \\
wine                        & 1839 & 66572 & 543 & 727 & 3156 & 606 & 133  & 5  & 7	  & 4   & 5 \\
\hline
\end{tabular}
\caption{Comparation of Meerkat, Trails and GLL perfomance on ontologies}
\label{table:rdfs}
\end{table*}


\subsection{Ontology querying}
\label{sec:ontology}

One of well-known graph querying problems is a queries for ontologies~\cite{FndDB}.
We use Meerkat to evaluate it on some popular ontologies presented as RDF files from paper~\cite{CFGonRDF}. 
We convert RDF files to a labeled directed graph like the following: for every RDF triple $(subject,\ predicate,\ object)$ we create two edges $(subject,\ predicate,\ object)$ and $(object,\ predicate^{-1},\ subject)$.
On those graphs we apply two queries from the paper \cite{GrigorevR16} which grammars are in Fig.~\ref{fig:query1Gen}, and Fig.~\ref{fig:query2Gen} 

\begin{figure}[h]
\begin{lstlisting}
val query2 = syn(
  sameGen(List(("subclassof-1", "subclassof"))) ~
   "subclassof")
\end{lstlisting}
\caption{Query 2 grammar}
\label{fig:query2Gen}
\end{figure}

The queries applied in two following ways.
\begin{itemize}
    \item Convert RDF files to a graph input for meerkat and then directly parse on query 1 and query 2
    \item Convert RDF files to a Neo4j database and then parse this database on given queries
\end{itemize} 

Table~\ref{table:rdfs} shows experimental results of those two aproaches over the testing RDF files where $\#results$ is a number of pairs of nodes $(v_1,\ v_2)$ such that exists S-path from $v_1$ to $v_2$.

Meerkat and GLL~\cite{GrigorevR16} shows the same results (column $\#results$)
And if compare permomance to GLL on Query 1 Meerkat is a little bit faster, meanwhile on Query 2 GLL is faster.

In comparation of perfomance of in memory graph querying and database querying, the second one is slower in about $2-4$ times.


\subsection{Static code analysis}

Alias analysis is one of the fundamental static analysis problems~\cite{Marlowe}.
Alias analysis checks may-alias relations between code expressions and can be formulated as a Context-Free language (CFL) reachability problem~\cite{Reps}.
In that case program represeted as Program Expression Graph (PEG)~\cite{Zheng}.
Verticies in PEG are program expressions and edges are relations between them.
In a case of analysisng C source code there is two kind of edges \textbf{D}-edge and \textbf{A}-edge.

\begin{itemize}
    \item Pointer dereference edge (\textbf{D}-edge). For each pointer deference $*e$ there is a directed D-edge from $e$ to $*e$.
    \item Pointer assignment edge (\textbf{A}-edge). For each assignment $*e_1=e_2$ there is a directed A-edge from $e_2$ to $*e_1$
\end{itemize}

Also, for the sake of simplicity, there are edges labeled by $\overline{D}$ and $\overline{A}$ which corresponds to reversed D-edge and A-edge, respectively.

The grammar for may-alias problem from~\cite{Zheng} presented in Fig.~\ref{lst:aliasGrammar}.
It consists of two nonterminals \textbf{M} and \textbf{V}.
It allows us to make two kind of queries for each of nonterminals \textbf{M} and \textbf{V}.

\begin{itemize}
    \item \textbf{M} production shows that two l-value expression are memory aliases i.e. may stands for the same memory location.
    \item \textbf{V} shows that two expression are value aliases i.e. may evaluate to the same pointer value.
\end{itemize}

We made \textbf{M} and \textbf{V} queries on the code some open-source C projects.
The results are presented on the Table~\ref{table:staticAnalysis} 

\begin{figure}[t]
\begin{align*}
& M \rightarrow\ \overline{D}\ V\ D\\
& V \rightarrow (M ?\ \overline{A})^{*} \ M?\ (A\ M?)^{*}
\end{align*}
\caption{Context-Free grammar for the may-alias problem}
\label{lst:aliasGrammar}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}
val M  = syn("nd" ~ V ~ "d")
val V  = syn((M.? ~ "na").* ~ M.? ~ ("a" ~ M.?).*)
\end{lstlisting}
\caption{Meerkat representation of may-alias problem grammar}
\label{fig:aliasMeerkat}
\end{figure}


\begin{table}[t]
\centering
\begin{tabular}{|l|l|ll|l|}
\hline
\multirow{2}{*}{Program} & \multirow{2}{*}{Code Size (KLOC)} & \multicolumn{2}{c|}{Count of aliases} & \multirow{2}{*}{Time (ms)} \\ \cline{3-4}
 &  & \multicolumn{1}{c|}{M aliases} & \multicolumn{1}{c|}{V aliases} &  \\ 
\hline
\hline
wc-5.0      & 0.5K & 0   & 174  & 107 \\
pr-5.0      & 1.7K & 13  & 1131 & 63  \\
ls-5.0      & 2.8K & 52  & 5682 & 253 \\
bzip2-1.0.6 & 5.8K & 9   & 813  & 71  \\
gzip-1.8    & 31K  & 120 & 4567 & 227 \\
\hline
\end{tabular}
\caption{Running may-alias queries on Meerkat on some C open-source projects}
\label{table:staticAnalysis}
\end{table}

\subsection{Comparison with Trails}

Trails~\cite{ScalaGraphParsing} is a Scala graph combinator library.
It provides traversers for describing paths in graphs in terms of parser combinators and allows to get results as a stream (maybe infinite) of all possible paths described by composition of basic traversals.
Trails as well as Meerkat support parsing in memory graphs, so we compare perfomance of Trails and Meerkat on the ontology queries which are described above.
The result of comparation are in table~\ref{table:rdfs}.
Trails gives the same results as Meeerkat (column $results$ in table~\ref{table:rdfs}) but slower than Meerkat.

To summarise we show that parser combinators are expressive enough for a formulation of real queries.
Performance of our implementation, which is based on combinators for linear input parsing, is comparable with other similar solutions and enough for real-world problems solution.
