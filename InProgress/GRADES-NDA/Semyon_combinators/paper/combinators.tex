\section{Parser-Combitators for Path Querying}

Parser-Combinators is a way to describe context-free grammar in terms of functions and operations on them. 
Parser is a function which takes some input and returns either Success with result of parsing or Error in a case of failure. 
Such parsers are composable which makes it easy to create new parsers from existing ones.
But classical parser combinators libraries can was made to work on a linear input, and Meerkat which we use as a base for our work too.

We extend input for Meerkat from linear to the graph one.
It can be done by using an odservation which for (string or graph) parsing we need only to provide function for getting symbols follower by specified position.
As far as Meerkat based on GLL, termination and correctness for arbitrary input graph and arbitrary context-free grammar is based on GLL generalization for CFPQ, which described in~\cite{GrigorevR16}.
That allows us to adopt parser combinators technique for context-free path querying.

Let us introduce an example of same generation query by using Meerkat.
Context-free grammar $G$ presented in Fig.~\ref{fig:query1} and its Meerkat representation is in Fig.~\ref{fig:query1Meerkat}

\begin{figure}[h]
\begin{align*}
& S \rightarrow subClassOf^{-1}\ S\ subClassOf\\
& S \rightarrow type^{-1}\ S\ type\\
& S \rightarrow subClassOf^{-1}\ subClassOf\\
& S \rightarrow type^{-1}\ type
\end{align*}
\caption{Query 1 grammar}
\label{fig:query1}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}
val S: Nonterminal = syn(
   "subclassof-1" ~ S ~ "subclassof" |
   "type-1" ~ S ~ "type" |
   "subclassof-1" ~ "subclassof" |
   "type-1" ~ "type")
\end{lstlisting}
\caption{Meerkat representation of Query 1}
\label{fig:query1Meerkat}
\end{figure}

Let's closely take a look at it.
For every nonterminal in our CF grammar we create a val of  \lstinline{Nonterminal} type.
Strings are implicitly converted to terminals.
\lstinline{syn} is a macro which creates new nonterminal and automaticaly assigns a name of our val to it.
Inside a \lstinline{syn} macro we've got a defenition of nonterminal.
It using two combinators \lstinline{~} and \lstinline{|}.
The first one \lstinline{~} says that after edge described by left operand we would like to have adjacence edge described by right one.
\lstinline{|} is an altenative combinator which have lower priority then \lstinline{~} and used to describes possible alternatives of paths description.

The following table shows the some combinators avalible in Meerkat. 

\begin{table}[h]
\centering
\begin{tabular}{|c|c|}
\hline
\multicolumn{1}{|c|}{Combinator} & \multicolumn{1}{c|}{Description} \\ \hline
{\lstinline!a ~ b!} & {\lstinline!a!} and then {\lstinline!b!}   \\
{\lstinline!a | b!} & {\lstinline!a!} or {\lstinline!b!}         \\
{\lstinline!a.?!}   & {\lstinline!a!} or nothing   \\
{\lstinline!a.*!}   & zero or more of {\lstinline!a!} \\
{\lstinline!a.+!}   & at least one {\lstinline!a!} \\
\hline
\end{tabular}
\caption{Meerkat combinators}
\label{table:combinators}
\end{table}

One of the most excited combinators feature is that queries using combinators can be used as first class values, which provide high ability for queryes generalization and comosition.
Let's take a look at Fig~\ref{fig:gen}. \lstinline{sameGen} creates a same generation query for every pair of brackets in \lstinline{brs}.
This generaization is independent from environment (graph and other parsers), and we can use it for creation of different queries.
For example, the following application of \lstinline{sameGen} build a query which is equivalents to the query presented in Fig.~\ref{fig:query1Meerkat}:

\begin{lstlisting}
val query1 = syn( sameGen( List(
    ("subclassof-1", "subclassof")
    , ("type-1", "type"))))
\end{lstlisting}

\begin{figure}[h]
\begin{lstlisting}
def sameGen(brs) =
  bs.map { case (lbr, rbr) => 
             lbr ~ syn(sameGen(bs).?) ~ rbr } 
  match {
    case x :: Nil => syn(x)
    case x :: y :: xs => 
      syn(xs.foldLeft(x | y)(_ | _))
  }
\end{lstlisting}
\caption{Same generations query generator}
\label{fig:gen}
\end{figure}

And let's fially parse graph from Fig.~\ref{fig:graph} and get all paths described by same-generation grammar from it.

\begin{figure}[h]
\includegraphics{graph}
\caption{Example graph}
\label{fig:graph}
\end{figure}

To do it let us use meerkat function \lstinline{parseGraphFromAllPositions(parser,graph)} which applies given parser to given graph and gets from SPPF all pairs of nodes such that exists a path between them described by a parser.

The result for graph in Fig.~\ref{fig:graph} is $\{(1,0), (1,2), (0,0), (2,1), (2,2), (0,2), (0,1), (1,1)\}$, where $(i,j)$ stands for the path from node with label $i$ to the node with label $j$

Meerkat library consists of 3 main units (Fig. ~\ref{fig:architecture}): the input data unit, the analysis unit, the visualization unit.

The input data unit can accept two main types: graphs and strings. It is necessary to implement the IGraph interface to analyze graphs with different implementations. There are two implementation of IGraph at the moment: Neo4JGraph and SimpleGraph. Neo4JGraph takes data from the Neo4j graph database. SimpleGraph allows you to describe the graph in the code of the program.

The analysis unit consists of parser and SPPFLookup. The parser gets the input data and the grammar, which is a input data query.  The parser maps the input data to the input grammar and finds all the paths. The result is added to the SPPFLookup data structure, which contains all the paths in the input data corresponding to the grammar. All nodes in the SPPFLookup are in a single instance and re-used.

After the analysis is completed, the visualization unit gets SPPFLookup and SPPF query. The unit filters the path and then returns the file in dot format to the user.
%\begin{figure}
%\caption{Architecture Meerkat}
%\label{fig:architecture}
%\includegraphics[width=0.3\textwidth]{architecture.jpg}
%\end{figure} 




