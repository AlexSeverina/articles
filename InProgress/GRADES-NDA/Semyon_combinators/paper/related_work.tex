\section{Related Work}

Some different formulation of the similar problems: Language-constrained path querying and language reachability.
Language-constrained path querying, Yannakakis~\cite{Yannakakis}. 
Hellings~\cite{ConjCFPathQuery, Hellings16}, RDF~\cite{CFGonRDF}, etc~\cite{QueryGraphWithData, RegularDBQuery, GraphQueryWithEarley, FLCpathProblem, graphDB}

Special graph query languages. SPARQL, cypher, gremlin

Languge integration problem: special DSLs for SQL, ORM, Linq.
Transperent integration inpo gp programming language: static correctness, typing, composability

Parser-combinators is one of classical approach for parsing!!!.

Scala combinators for graph~\cite{ScalaGraphParsing} --- one of attempt to adopt combinators 
technique for graph processing.
Only an idea of combinators using, but language class and restrictions are not discussed.
Problems with cycles in graph. 
Ad-hoc solution. We propose a general solution.
Problems with left-recursive grammars(???Should be checked)

Classical combinators are based on LL(k) and has restrictions: left-recursive grammars.
GLL~\cite{scott2010gll} can handle arbitrary context-free grammars, SPPF~\cite{SPPF}

Parser combinators library bsed on GLL --- 
Meerkat~\footnote{\url{https://github.com/meerkat-parser/Meerkat}}~\cite{Meerkat}. 
Can handle arbitrary context-free grammars
Written in Scala

Structural representation of result: not only reachability, but paths; debuggibg; understanding.