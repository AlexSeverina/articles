\section{Introduction}

Graph data models are widely used in many areas, for example, graph databases~\cite{graphDB}, bioinformatics~\cite{Bio}, static analysis~\cite{kodumal2004set, zhang2013fast}, etc. In these areas, it is often required to process queries for large graphs. The most common type of graph queries is navigational query. The result of a query evaluation is a set of implicit relations between the nodes of the graph, i.e. a set of paths. A natural way to specify these relations is to specify the paths using some form of formal grammars (regular expressions, context-free grammars) over the alphabet of edge labels. Context-free grammars are actively used in graph querying because of the limited expressive power of regular expressions. For example, classical \emph{same-generation queries}~\cite{FndDB} cannot be expressed using regular expressions.

The result of a context-free path query evaluation is usually a set of triples \mbox{$(A, m, n)$}, such that there is a path from the node $m$ to the node $n$, whose labeling is derived from a non-terminal $A$ of the given context-free grammar. This type of query is evaluated using the \emph{relational query semantics}~\cite{hellingsRelational}. There is a number of algorithms for context-free path query evaluation using this semantics~\cite{GLL, hellingsRelational, RDF, GraphQueryWithEarley}.

The existing algorithms for context-free path query evaluation w.r.t. relational semantics demonstrate a poor performance when applied to large graphs. The algorithms for context-free language recognition had a similar problem until Valiant~\cite{valiant} proposed a parsing algorithm, which computes a recognition table by computing matrix transitive closure. The algorithm works for a linear input and has the complexity, which is essentially the same as for Boolean matrix multiplication. One of the hard open problems is to generalize Valiant's matrix-based approach for context-free path query evaluation.

We propose the first matrix-based algorithm for context-free path query evaluation using relational query semantics. Valiant's algorithm computes the transitive closure of an upper triangular matrix by increasing the length of paths considered. We use another definition of matrix transitive closure, which does not depend explicitly on the path length since the cyclic graphs contain paths of infinite length. Additionally, we compute the transitive closure of an arbitrary matrix, since the context-free path query evaluation requires to process arbitrary graphs. While we do not achieve the same worst-case time complexity for graph input as Valiant's algorithm for linear case, the use of matrix operations (such as matrix multiplication) in our algorithm makes it possible to efficiently apply such computing techniques as \emph{GPGPU} (General-Purpose computing on Graphics Processing Units) and parallel computation~\cite{matricesOnGPGPU}. From a practical point of view, matrix multiplication can be performed on different GPUs independently. It can help to utilize the power of multi-GPU systems and increase the performance of context-free path querying. Also, the algorithms for distributed-memory matrix multiplication make it possible to handle graph sizes inherently larger, than the memory available on the GPU~\cite{MM_on_multi-GPU, hetero_multi-GPU, choi1994pumma}.

The exact contribution of this paper can be summarized as follows:

\begin{itemize}
\item we show, how the context-free path querying w.r.t. relational query semantics can be reduced to the calculation of matrix transitive closure;
\item we introduce a matrix-based algorithm for context-free path querying w.r.t. relational query semantics which is based on matrix operations that makes it possible to speed up computations, using GPGPU;
\item we prove the correctness of our algorithm;
\item we show the practical applicability of our algorithm by presenting the results of its evaluation on a set of conventional benchmarks.
\end{itemize}

This paper is structured as follows: the section~\ref{section_motivating} provides a small motivating example; the section~\ref{section_preliminaries} defines some notions, used later on; in the section~\ref{section_related} the overview of related works is presented; the section~\ref{section_main} discusses our matrix-based algorithm for context-free path querying and provides a step-by-step demonstration for a small example;  we evaluate the performance of our algorithm in the section~\ref{section_evaluation}, and provide some concluding remarks in the section~\ref{section_conclusion}.
