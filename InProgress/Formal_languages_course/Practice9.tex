\section{Практика 9}

\subsection{Григорьев С.В.}

Абстрактный и конкретный синтаксис языка запросов к графам, семантика языка запросов к гарфам.

Абстрактный синтаксис скрывает детали синтаксического анализа и конкретного ``текстового'' представления синтаксиса, оставляя только важную для дальнейшего анализа иформацию о структуре программы. 

Первая, минималистичная, версия языка запросов к графам.

\begin{verbatim}
type script: Seq of List<stmt>

type stmt:
  | Connect of String
  | Select of obj_expr * graph_expr

type graph_expr =
  | Intersect of graph_expr * graph_expr 
  | Query of pattern
  | GraphName of String

type obj_expr:
  | Edges   
  | Conut of obj_expr
  
type pattern: 
  | smb of String
  | star of pattern
  | plus of pattern
  | alt of pattern * pattern
  | seq of pattern * pattern
  | option of pattern

\end{verbatim}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}

Тперь поговорим о семантике данного языка. Исполнение скрипта на получившимся языке достаточно естественно описывается состоянием из текущей базы данных, текущего графа, и текущего результата вычислений. Значение этой тройки и будет семантикой нашей программы.

При обработке непустой последовательности инструкций сначала вычисляем результат выполнения первой инструкции, затем на нем --- всех остальных.

$$
\infer[]{c \xrightarrow{Seq \ (hd::tl)} c''}{c \xrightarrow{hd} c', \ \ c' \xrightarrow{Seq \ tl} c''}
$$

При обработке команды \verb|Connect| сохраняем её аргумент в конфигурации как путь к текущей базе данных.
$$
\infer[]{\langle db, graph, res\rangle \xrightarrow{Connect \ db'} \langle db', graph, res\rangle}{}
$$

При обработке инструкции \verb|Select| сперва вычисляется граф, из которого будут выбираться объекты, затем вычисляются сами объекты.

$$
\infer[]{c \xrightarrow{Select \ obj \ graph} c''}{c \xrightarrow{graph} c', \ \ c' \xrightarrow{obj} c''}
$$

При обработке инструкции \verb|Graph| загружаем в окружение граф из файла с именем, соотвествующим аргументу этой инструкции, лежащем в базе (директории), соответствующей значению \verb|cur_db|.

$$
\infer[]{\langle db, graph, res \rangle \xrightarrow{\textit{GraphName} \ name} \langle db ,loadGraph(String.concat(db,name)), res\rangle}{}
$$

При обработке инструкции \verb|Intersect| сперва вычисляем оба подвыражения, затем пересекаем получившиеся графы как конечные автоматы. Считаем все вершины стартовыми и финальными одновременно.

$$
\infer[]{\langle db, graph, res\rangle \xrightarrow{\textit{Intersect} \ graph_1 \ graph_2} \langle db, \textit{intersectFA}(graph', graph''), res\rangle}{\langle db, graph,res\rangle \xrightarrow{graph_1} \langle db', graph', res'\rangle, \ \ \langle db, graph,res\rangle \xrightarrow{graph_2} \langle db'', graph'', res''\rangle}
$$


При обработке инструкции \verb|Query| необходимо потроить минимальный детерминированный автомат по регулярному выражению, задаваемому шаблоном.

$$
\infer[]{\langle db, graph, res \rangle \xrightarrow{\textit{Query} \ pattern} \langle db, \textit{buildMinDFA}(pattern), res \rangle}{}
$$

При обработке инструкции \verb|Edges| в текущий результат вычислений записывается множество троек, соотвествующих рёбрам текущего графа.

$$
\infer[]{\langle db, graph, res \rangle \xrightarrow{\textit{Edges}} \langle db, graph, \{(v_i,e,v_j) \mid (v_i,e,v_j) \in graph.Edges\}\rangle}{}
$$

При обработке инструкции \verb|Count| сперва вычисляется подвыражене, а затем в текущий результат вычислений записывается размер результата вычисления подвыражения, если результат был множеством.

$$
\infer[type\_of(res') \equiv Set ]{\langle db, graph, res \rangle \xrightarrow{\textit{Count} \ expr} \langle db, graph, Set.count(res') \rangle}{\langle db, graph, res \rangle \xrightarrow{expr} \langle db', graph', res' \rangle}
$$

--------------------------------------------------------------------------------
%\end{document}

%Семантика. 


%Пример конкретного синтаксиса.

\begin{align*}
\textit{script} \to & \varepsilon  \\
                    & \mid \textit{stmt \ SEMI \ script} \\
\textit{stmt} \to & \textit{KW\_CONNECT \ KW\_TO \ STRING} \\
                  & \mid KW\_LIST \ KW\_ALL \ KW\_GRAPHS \\
                  & \mid select\_stmt \\
                  & \mid named\_pattern\_stmt \\
named\_pattern \to & NT\_NAME \ OP\_EQ  \ pattern \\
select\_stmt \to & \textit{KW\_SELECT} \ obj\_expr \ \textit{KW\_FROM} \ STRING \ \textit{KW\_WHERE} \ where\_expr \\
obj\_expr \to & vs\_info \\
              & \mid \textit{KW\_COUNT} \ vs\_info \\
              & \mid \textit{KW\_EXISTS} \ vs\_info \\
vs\_info \to & LBR \ IDENT \ COMMA \ IDENT \ RBR \\
             & \mid IDENT \\
where\_expr \to & LBR \ v\_expr RBR \ \\
                & OP\_MINUS \ pattern \ OP\_MINUS \ OP\_GR \\
                & LBR \ v\_expr \ RBR \\
v\_expr \to & IDENT \mid UNDERSCORE \mid IDENT \ DOT \ KW_ID \ OP\_EQ \ INT \\
pattern \to & alt\_elem \\
            & \mid alt\_elem \ MID \ pattern \\
alt\_elem \to & seq \\
             & \mid LBR \ RBR \\
seq \to & seq\_elem \\
        & \mid seq\_elem \ seq \\
seq\_elem \to & prim\_pattern \\
              & \mid prim\_pattern \ OP\_STAR \\
              & \mid prim\_pattern \ OP\_PLUS \\
              & \mid prim\_pattern \ OP\_Q \\
prim\_pattern \to & IDENT \\
                 & \mid NT\_NAME \\
                 & \mid LBR \ pattern \ RBR \\
\end{align*}

Токены (терминальный алфавит).
\begin{align*}
LBR = & '(' \\
RBR = & ')' \\
COMMA = & ',' \\
SEMI = & ';' \\
MID = & '|' \\
DOT = & '.' \\
OP\_STAR = & '*' \\ 
OP\_PLUS = & '+' \\
OP\_Q = & '?' \\
OP\_MINUS = & '-' \\
OP\_GR = & '>' \\
OP\_EQ = & '=' \\
KW\_ID = & 'ID' \\
KW\_COUNT = & 'COUNT' \\
KW\_EXISTS = & 'EXISTS' \\
KW\_FROM = & 'FROM' \\
KW\_WHERE = & 'WHERE' \\
KW\_LIST = & 'LIST' \\
KW\_ALL = & 'ALL' \\
KW\_GRAPHS = & 'GRAPHS' \\
KW\_CONNECT = & 'CONNECT' \\
KW\_TO = & 'TO' \\
IDENT = & [a-z][a-z]^* \\
INT = & 0 \mid [1-9][0-9]^* \\
NT\_NAME = & [A-Z][a-z]^* \\
STRING = & {'['} ([aA-zZ] \mid [0-9] \mid ({'-'} \mid {' \ '} \mid {'\_'} \mid {'/'} \mid {'.'}))^* {']'}
\end{align*}

Пример скрипта:
\begin{verbatim}
CONNECT TO [\home\user\graph_db];
S = a S b S | () ;
SELECT COUNT(u) FROM [g1.txt] where (v.id = 10) - S -> (u);
\end{verbatim}

Задача на дом.
\begin{enumerate}
  \item Описать конкретный синтаксис языка запросов к графам, согралованный с приведённым абстрактным синтаксисом. Результат: грамматика и лексика в маркдаун (*.md) файле в репозитории (например, описание языка в readme.md). С примерами выражений на языка и текстовым описанием его особенностей.
  \item Синтаксический анализатор предложенного языка на основе имеющейся реализации CYK. На вход принимается строка (с консоли или из файла), в которой токены разделены пробелами и переносами строк. Для приведённого выше скрипта вход выглядит следующим образом:
  \begin{verbatim}
  KW_CONNECT KW_TO STRING SEMI 
  NT_NAME OP_EQ IDENT NT_NAME IDENT NT_NAME MID LBR RBR SEMI 
  KW_SELECT KW_COUNT LBR IDENT RBR 
  KW_FROM STRING 
  KW_WHERE LBR IDENT DOT KW_ID OP_EQ INT RBR 
  OP_MINUS NT_NAME OP_MINUS OP_GR LBR IDENT RBR SEMI
  \end{verbatim}
\end{enumerate}




Расширенная версия.

\begin{verbatim}
type script: Seq of List<stmt>

type stmt:
  | Connect of String
  | Select of obj_expr * graph_expr
  | NamedPattern of String * regexp

type graph_expr =
  | ReachabilityInfo of graph_expr * path_pattern 
  | Intersect of graph_expr * graph_expr 
  | GraphName of String

type obj_expr:
  | Vertices of String  
  | Conut of String
  | Exists of String
  | Pair of obj_expr * obj_expr

vs_info:
  | pair of v_info * v_info
  | single of v_info

v_info:
  | name of String
  | any
  
path_pattern:
  | path of v_expr * pattern * v_expr

v_expr: 
  | name of String
  | any 
  | v_pattern

v_pattern:
  | id_pattern of Int   

pattern: 
  | smb of String
  | star of regexp
  | plus of regexp
  | alt of regexp * regexp
  | seq of regexp * regexp
  | option of regexp

\end{verbatim}
