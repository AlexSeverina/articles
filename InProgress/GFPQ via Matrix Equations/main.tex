\documentclass[sigconf]{acmart}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{tabularx}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{mathtools}

\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{verbatim}

%\AtBeginDocument{%
%  \providecommand\BibTeX{{%
%    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-9999-9/18/06}



\begin{document}

\title{Context-Free Path Querying via Matrix Equations}

\author{Yuliya Susanina}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7/9 Universitetskaya nab.}
  \city{St. Petersburg} 
  \state{Russia} 
  \postcode{199034}
}
\affiliation{
  \institution{JetBrains Research}
  \streetaddress{Primorskiy prospekt 68-70, Building 1}
  \city{St. Petersburg}
  \country{Russia}
  \postcode{197374}
}
\email{st049970@student.spbu.ru}


%\author{Semyon Grigorev}
%\affiliation{%
%    \institution{Saint Petersburg State University}
%    \streetaddress{7/9 Universitetskaya nab.}
%    \city{St. Petersburg}
%    \state{Russia}  
%    \postcode{199034}
%}
%\affiliation{
%  \institution{JetBrains Research}
%  \streetaddress{Universitetskaya nab., 7-9-11/5A}
%  \city{St. Petersburg}
%  \country{Russia}
%  \postcode{199034}
%}
%\email{s.v.grigoriev@spbu.ru}
%\email{semen.grigorev@jetbrains.com}



%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Context-free path querying (CFPQ) underlies many problems related to graph-structured data in such areas as bioinformatics, static code analysis, graph databases.
  The importance of developing highly efficient algorithms for CFPQ connected with a large amount of data to process.
  Computational mathematics may be very useful due to the meaningful theoretical basis and multiple constantly improving implementations.
  We show how to reduce GFPQ evaluation to solving the systems of matrix equations over $\mathbb{R}$.
  Thus we propose a new way to reduce CFPQ to problem with available high-performance solutions.
  Also we demonstrate the applicability of our approach to the real-world data analysis.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Information systems~Query languages</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Theory of computation~Formal languages and automata theory</concept_desc>
  <concept_significance>500</concept_significance>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Design and analysis of algorithms~Approximation algorithms analysis</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Query languages}
\ccsdesc[500]{Theory of computation~Formal languages and automata theory}


\keywords{context-free path querying, graph databases, context-free grammar, nonlinear matrix equations, newton method}

\maketitle

\section{Introduction}

Context-free path querying (CFPQ)---a way to specify path constraints in terms of context-free grammars---is becoming more popular in many areas, e. g. bioinformatics~\cite{sevon2008subgraph}, graph databases~\cite{yannakakis1990graph,Medeiros:2018:EEC:3167132.3167265,Kuijpers:2019:ESC:3335783.3335791} or static code analysis~\cite{Reps,zhang2013fast}. 
This type of query increases the expressive power of commonly used regular languages constrained path query (RPQ) and therefore forms a promising research area.
Despite the fact that many different algorithms for CFPQ are proposed~\cite{RDF,Medeiros:2018:EEC:3167132.3167265,azimov2018context,Verbitskaia:2018:PCC:3241653.3241655,10.1007/978-3-319-91662-0_17}, resent research shows that real-world data handling is still a problem~\cite{Kuijpers:2019:ESC:3335783.3335791}.

One of the resent experiments~\cite{mishin2019evaluation} shows that one of the promising ways to get high-performance CFPQ is to reduce the problem to well-established problems for which high-performance solutions are available.
One such reduction was proposed by Rustam Azimov~\cite{azimov2018context} who shows that CFPQ can be reduced to Boolean matrix multiplication.
In this way we can offload the most computationally intensive part to high-performance libraries for matrix processing, which utilizes GPGPUS and other modern hardware.

On the other hand, there are several results of applying linear algebra methods to logic programming~\cite{sato2017linear, aspis2018linear}. 
In~\cite{sato2017linear} it is shown that the evaluation of a subset of datalog queries can be reduced to matrix equation solving.  
This way one can use numerical linear algebra and computational mathematics to improve the performance of query evaluation.
The question is may we use this way for CFPQ?
By this reduction, we can utilize another set of high-performance solutions which are used for numerical analysis and equation solving to improve the performance of CFPQ.
Also, approximate computational methods can accelerate CFPQs processing.
And most importantly, the popularity of artificial intelligence techniques pushed the development and improvement of many efficient libraries for numerical computing.

In this work we propose a new approach for CFPQs processing, based on solving the systems of equations in the set of real numbers $\mathbb{R}$.
We also assess the feasibility of using both accurate and approximate methods of computational mathematics and utilize respective methods, such as a Newton method with high-performance implementations available.
So, we propose an alternative way to reduce CFPQ to a problem with available high-performance solutions.
The evaluation of our approach on a set of conventional benchmarks shows that it is comparable with matrix-based approach and applicable for real-world data processing.

\section{Preliminaries}

Context-free grammar (CFG) is a triple $G=(N, \Sigma, R)$, where $N$ is a set of nonterminal symbols, $\Sigma$ is a set of terminal symbols and $R$ is a set of productions of the followings form: $A \Rightarrow \alpha$, $\alpha \in (N \cup \Sigma)^*$. 
$\mathcal{L}(G_S)$ denotes a language specified by CFG $G$ with respect to $S \in N$: $\mathcal{L}(G_S) = \{\omega \mid S \Rightarrow_{G}^{*} \omega\}$.

Directed graph is a triple $D = (V,E,\sigma)$, where $V$ is a set of vertices, $\sigma \subseteq \Sigma$ is a set of labels, and a set of edges $E\subseteq V\times \sigma \times V$. 
Denote a path from the node $m$ to the node $n$ in graph $D$ as $m\lambda n$, where
$\lambda$ is the unique word, obtained by concatenating the labels of the edges along this path.
$P$ is a set of all paths in $D$.

Relational semantics for CFPQ (according Hellings~\cite{hellings2014conjunctive}) is for a graph $D$ and a CFG $G$, to find \emph{context-free relations} $R_A \subseteq V \times V$ such that for each $A \in N$: $R_A = \{(m, n) \mid m\lambda n \in P, \lambda \in \mathcal{L}(G_A)\}.$
All such relations are finite, so each of them can be represented as a Boolean matrix: $(T_A)_{i,j} = 1 \iff (i,j) \in R_A$. 

%Matrix-based algorithm, proposed by Rustam Azimov~\cite{azimov2018context}, processes CFPQs by using relational query semantics~\cite{hellings2015querying} and offloads the most time-consuming operations onto Boolean matrix multiplication, thus allowing significantly increase the performance~\cite{mishin2019evaluation}, but it takes time $\mathcal{O}(|V|^{4+\omega})$. 


\section{Equation-Based Approach}

To reduce CFPQ to equation solving we use a similar way which uses Taisuke Sato to reduce Datalog program evaluation to linear algebra operations~\cite{sato2017linear}.
For the given graph and the given grammar each terminal and nonterminal specifies a finite relation which can be represented as a Boolean matrix as presented above.
After that for each production $N_i \to \beta^0_0 \dots \beta^0_k \mid \ldots \mid \beta^l_0 \dots \beta^l_m, \beta^i_j \in \Sigma \cup N$ we can create an equation $T_{N_i} = T_{\beta^0_0}\cdot \ldots \cdot T_{\beta^0_k} + \ldots + T_{\beta^l_0}\cdot \ldots \cdot T_{\beta^l_m} $


For example, consider a simple CFG $G_1 : S \rightarrow aSb \mid ab$. 
Respective Boolean matrix equation:

\begin{center}
\(
\left. 
\begin{array}{l}
T_S = T_AT_ST_B + T_AT_B
\end{array} 
\right.
\)
\end{center}

We can solve this equation by na\"ive iterative process:
\begin{center}
\(
\left. 
\begin{array}{l}
T_S^0 = \mathbf{0} \\
T_S^{k+1} = T_a T_S^k T_b + T_a T_b
\end{array} 
\right.
\)
\end{center}

Unfortunately, this modification does not entail any meaningful improvements. 
But we can consider another equation over $\mathbb{R}$:

\begin{center}
\(
\left. 
\begin{array}{l}
\mathcal{T}_S = \epsilon(T_A \mathcal{T}_S T_B + T_A T_B)
\end{array}
\right.
\)
\end{center}

And the corresponding matrix series $\{ \mathcal{T}_S^{k}\}$, which converges to $\mathcal{T}_S^*$ when $\mathcal{T}_S^{k} \leq \textbf{1}$ as a a monotonically increasing series of matrices with an upper bound:

\begin{center}
\(
\left.
\begin{array}{c}
\mathcal{T}_S^0 = \mathbf{0} \\
\mathcal{T}_S^{k+1} = \epsilon(T_A \mathcal{T}_S^k T_B + T_A T_B).
\end{array} 
\right.
\)
\end{center}

It can be proved that $((\mathcal{T}_S^{k+1})_{ij} > 0 \iff (T_S^{k+1})_{ij} = 1)$ and $ceil(\mathcal{T}_S^*) = T_S^*$, where $ceil(x)$ returns the smallest integer not less than $x$~\cite{sato2017linear}.

So, each rule of the form $N_i \to \beta^0_0 \dots \beta^0_k \mid \ldots \mid \beta^l_0 \dots \beta^l_m, \beta^i_j \in \Sigma \cup N$ can be replaced with an equation 
$T_{N_i} = \epsilon_{N_i}(T_{\beta^0_0}\cdot \ldots \cdot T_{\beta^0_k} + \ldots + T_{\beta^l_0}\cdot \ldots \cdot T_{\beta^l_m}) $, where $\epsilon_X$ is chosen such that $\mathcal{T}_X^{k} \leq \textbf{1}$ for each $k$.
In real-world cases we deal with the systems of matrix equations because grammars contain more than one nonterminal. 
We can consider the following possible cases of these systems.

\underline{\textbf{Linear Equations.}}
If the input CFG is linear, each equation is of the form of generalized Sylvester equation: $\sum_{i = 1}^{k} A_iXB_i = C$.
For $k = 1, 2$ we can solve it in $\mathcal{O}(|V|^3)$~\cite{Bartels:1972:SME:361573.361582}.
Otherwise, for $k > 2$ it can be reduced using Kronecker product to solving a linear system $Ax = b$, where $A$ is a matrix of size $(|V|^2 \times |V|^2)$ and time required to compute its solution is $\mathcal{O}(|V|^6)$ or $\mathcal{O}(|V|^{4 + 2\omega})$ with more efficient matrix multiplication algorithms. 
The use of sparse matrix representation and approximate methods can be very efficient for solving the equations of this type~\cite{bouhamidi2008}.

For the system of equations, we construct the dependency graph $D_G$ for nonterminals of the given grammar $G$ and split the set of the equations into the disjoint subsets accordingly to the set of strongly connected components in $D_G$, which can be found in $\mathcal{O}(|V| + |E|)$~\cite{tarjan1972}.
Then we solve our system in stages, for each subset.

\underline{\textbf{Nonlinear Equations.}}
For the nonlinear case we can rewrite each equation of the form $X = \Psi(X)$ to the equivalent $F(X) = X - \Psi(X) = 0$ and use Newton's method for nonlinear functions root finding:

\begin{center}
\(
\left.
\begin{array}{c}
F(X) = \mathbf{0}, X_0 \\
\end{array} 
\right.
\)

\(
\left. 
\begin{array}{l}
X_{i+1} = X_i - (F'(X_i))^{-1}F(X_i) 
\end{array} 
\right.
\iff 
\left\{
\begin{array}{l}
F'(X_i)H_i = - F(X_i) \\
X_{i+1} = X_i + H_i
\end{array} 
\right.
\)
\end{center}

Here $X_0$ is an initial guess, in our case $X_0 = $ \textbf{0}, as our solution is a matrix consists of small positive numbers. 
The convergence of this method can be quadratic which allows finding the solution significantly faster.
Even as it is necessary to solve an equation for $H_i$ (also generalized Sylvester equation) on each iteration step, the majority of high-performance implementations do not compute the Jacobian inverse and use its approximate value~\cite{knoll2004jacobian}.

The main difficulty in using Newton's method is choosing an appropriate $\epsilon$, to ensure the least positive solution for nonlinear equations $\epsilon$ must be smaller than $\frac{1}{|V|}$.


\section{Evaluation}

The equation-based approach for CFPQ was implemented and evaluated on \textbf{Query 2} from~\cite{azimov2018context}.
The equation constructed for this query were solved on the CPU by using two functions form Python package \textit{scipy}~\cite{scipy}: 
solving as a sparse linear system using \textit{spsolve} (\textbf{sSLV})
and
root funding of a function using \textit{optimize.newton\texttt{\_}krylov} (\textbf{dNWT}).

\begin{table}[h]
\centering
\caption{Evaluation results for Query 2 (in ms)}
\label{tbl2}
\begin{tabular}{ | c | c || c | c || c | c | c |}
\hline
Ontology    & |V| & dNWT & sSLV & dGPU & sCPU &  sGPU \\
\hline                           
\hline                           
bio-meas    & 341 &  284 & 35   & 276  & 91  & 24\\
people-pets & 337 &  73  & 49   & 144  & 38  & 6\\
funding     & 778 &  502 & 184  & 1246 & 344 & 27\\
wine        & 733 &  791 & 171  & 722  & 179 & 6\\
pizza       & 671 &  334 & 161  & 943  & 256 & 23\\
\hline
\end{tabular}

\end{table}

We compare (Table~\ref{tbl2}) our solution with the first matrix-based algorithm implementations described in~\cite{azimov2018context} and conclude that equation based approach can be applied on real-world data as well as the matrix-based algorithm. 
Moreover, we can improve the performance by the utilization of parallel techniques for matrix operations.

\section{Conclusion and future work}

We proposed a new approach for CFPQ, based on solving the systems of equations over $\mathbb{R}$.
The evaluation of our approach on a set of conventional benchmarks showed its applicability for real-world data analysis.

Direction for future research is utilization of high-performance solvers, for example which utilize GPGPU and distributed computations, and comparison with other algorithms for CFPQ.
Also, it is interesting to determine the subclasses of (system of) polynomial equations whose solution can be reduced to CFPQ and try to construct bidirectional reduction between CFPQ and these subclasses, thereby finding efficient solutions for both these problems at a time.



\begin{acks}
The research was supported by the Russian Science Foundation grant 18-11-00100 and a grant from JetBrains Research.
\end{acks}


\bibliographystyle{ACM-Reference-Format}
\bibliography{main}



\end{document}
\endinput