\section{Introduction}

Concurrent systems are widely spread and its verification is a nontrivial and important problem.
There are a lot of papers that describe concurrent programs behavior via Push Down Systems or Context-Free languages~\cite{gange2015tool, bouajjani2003generic, chaki2006verifying, ModelPDA1}, and our interest is around a \textit{shuffle} of Context-Free Languages (CFL)~\cite{CFLShuffle}.
This languages describe the interleaving of CFLs (or PDA) and look perfect to describe the interleaved behavior of concurrent programs.

First of all we introduce the notion of \textit{shuffle} operation ($\odot$), that can be defined for sequences as follows:
\begin{itemize}
    \item $\varepsilon \odot u = u \odot \varepsilon = {u}$, for every sequence $ u \in \Sigma^*$;
    \item $\alpha_1 u_1 \odot \alpha_2 u_2 = \{\alpha_1 w | w \in (u_1 \odot \alpha_2 u_2) \} \cup \newline
    \{\alpha_2 w | w \in (\alpha_1 u1 \odot u_2 ) \},  \forall \alpha_1, \alpha_2 \in \Sigma$ and $\forall u_1, u_2 \in \Sigma^*$.
\end{itemize}
For example, $"ab" \odot "123" = \{a123b,a1b23, 12ab3, 123ab, etc.\}$.

Shuffle can be extended to languages as $$L_1 \odot L_2 = \bigcup\limits_{u_1\in L_1, u_2\in L_2} u_1 \odot u_2.$$

We can describe required aspects of behavior of functions (or methods, or subsystems) $f_1, f_2 ... f_n$ from our system $\mathcal{S}$ that run concurrently as shuffle of context-free languages $L_{f_1}, L_{f_2} ... L_{f_n}$ generated for each of them.
As a result, language  $\mathcal{L} = L_{f_1} \odot L_{f_2} \odot... \odot L_{f_n}$ describes all possible executions of our system.
If we want to check a correctness of $\mathcal{S}$, then we should check whether $\mathcal{L}$ contains any ``bad execution''.
Let suppose that the set of bad executions can be described by some regular language $R_1$.
Now we should inspect an intersection $\mathcal{L} \cap R_1$ --- its emptiness means that $\mathcal{S}$ can not demonstrate bad behavior.

The idea described above is used in the paper~\cite{stenman2011approximating}. 
As far as shuffled context-free languages are not closed under intersection with the regular one~\cite{CFLShuffle} and the problem of defining either string is in the shuffle of CFL is NP-Complete,
 authors use a context-free approximation of shuffle of CFL and intersect it with error traces, but since the approximation was used this approach didn't found some of known bugs. 

While NP-completeness may looks like death warrant, there are SAT-solvers which deal with NP problems very successfully.
In this paper we show how to reduce emptiness checking of shuffled CFL and finite regular language intersection to SAT.
Our reduction is very native and use some classical parsing techniques.
Generalization for arbitrary regular language is a topic for future research.


\section{Languages Shuffle to SAT}

First, we assume that $ R_1 $ is finite regular language.
This is possible in assumption that the error can usually be detected in the first iterations of the loops, so at the first step we can approximate general regular language by fixed unrolling of loops.
This assumption is used in bounded model checking~\cite{BMC}.%, but here we use the bound on traces language instead of program language.

Then we appeal to the intuition of shuffle operation.
If the sequence $J$ is in the language $B \odot C$ then there is a split of $J$ of $J_B$ and $J_C$ such that $b_1 c_1 b_2 c_2 ... b_k c_k = J$ where $b_i, c_i \in (\Sigma^* \cup \varepsilon)$
and $b_1 b_2 ... b_k = J_B, c_1 c_2 ... c_k = J_C$.
Both $J_B$ and $J_C$ are in the language $J'$ --- the language of lines $J$ with all possible omissions of terminals.
For the finite automaton $R_2$ the desired language of lines with omissions is described by an automaton $R_2'$ --- an epsilon-closure of $ R_2 $.

Since the language of $R_2'$ is finite, we can consider the languages
$ L_{f_i}' = L_{f_i} \cap R_2', i \in 1..n$ --- the finite context-free narrowing of languages $ L_{i}$.
Thus, we redefine initial problem of language intersection to $(L_{f_1}' \odot L_{f_2}' \odot... \odot L_{f_n}')\cap R_2$.
All this languages are finite therefore we can generate a SAT problem instance to check intersection emptiness.

\section{Shuffle to SAT}

An instance of SAT problem is a boolean formula which is checked by solver for satisfiability. 
Constructing a formula for the problem defined above requires a more deep inspection of the languages' structure.
$R_2$ is a finite automaton that describes multiple paths from initial state to final. Transition labels of 
this paths define a language os that automaton. In terms of our problem we can consider the terminals of this language as 
a transitions of the form $i\_a\_j$, where $i$ and $j$ are states of $R_2$; $a$ --- transition label.
Since the languages $L_{f_i}'$ are $L_{f_i} \cap R_2'$, they describe the sets of transitions in 
$R_2$. Thus, the problem of giving the line from the language defined by intersection $(L_{f_1}' \odot L_{f_2}' \odot... \odot L_{f_n}')\cap R_2$
is equivalent to providing a sets $W_1...W_n$ of transitions ($W_i \in L_{f_i}'$) which preserve the following conditions:
\begin{itemize}
    \item $\bigcap\limits_{i\in 1..n} W_i = \emptyset$, i.e.
    each transition of $R_2$ contained not more then in one of the sets $W_i$.
    \item $\bigcup\limits_{i\in 1..n} W_i \in R_2$, i.e. union of all transitions
    is a path in $R_2$ from initial to final state. 
\end{itemize}
Such problem interpretation intuitively define the rules of the SAT formula generation.~\cite{Grigorev}
The formula consist of following parts, connected with conjunction.
\begin{itemize}
    \item Define the sets of transitions for each language $L_{f_i}'$ with the alternation
     of formulas $(t_i^1 \& t_i^2 \& ...\& t_i^k)$, where $t_i^1 ... t_i^k$ are transitions of the same set.
    \item ...
    \item ...
\end{itemize}


Binarized Shared Packed Parse Forest (SPPF)~\cite{brnglr, SPPF} compresses derivation trees optimally reusing common nodes and subtrees.
Version of GLL~\cite{scott2010gll} which utilizes this structure for parsing forest representation achieves worst-case cubic space complexity~\cite{gllParsingTree}.

Binarized SPPF can be represented as a graph in which each node has one of four types described below.
We denote the start and the end positions of substring as $i$ and $j$ respectively, and we call tuple $(i,j)$ an \textit{extension} of a node.

\begin{itemize}
    \item \textbf{Terminal node} with label $(i, T, j)$.
    \item \textbf{Nonterminal node} with label $(i, N, j)$. 
    This node denotes that there is at least one derivation for substring $\alpha=\omega[i..j-1]$ such that $N \Rightarrow^*_G \alpha, \alpha = \omega[i..j-1] $.
    All derivation trees for the given substring and nonterminal can be extracted from SPPF by left-to-right top-down graph traversal started from respective node.     
    \item \textbf{Intermediate node}: a special kind of node used for binarization of SPPF. These nodes are labeled with $(i,t,j)$, where $t$ is a grammar slot.
    \item \textbf{Packed node} with label $(N \rightarrow \alpha, k)$. 
    Subgraph with ``root'' in such node is one possible derivation from nonterminal $N$ in case when the parent is a nonterminal node labeled with $(<\mkern-9mu | \mkern-9mu> (i, N, j))$.

\end{itemize}

An example of SPPF is presented in figure~\ref{SPPF}. We remove redundant intermediate and packed nodes from the SPPF to simplify it and to decrease the size of the structure.



\section{Example}
%Consider functions Add() and Dec() running concurrently. An \textit{error} operator stands the program reach unwanted state.
%The problem is to define either program can reach the \textit{error} operator. 



%To solve this problem we build Finite Automata to check for an emptiness an intersection $L_prog \cap L_exec$, where
%$L_prog$ is the language described by shuffle of grammars $G_add$ and $G_dec$; $L_exec$ is regular language described by Finite Automaton $R$.


%To preserve the semantics of program we need to add constraints on variables in R.


%then idea is to get formula that describes our intersection. 

%In general, CFG can't be represented by finite SAT formula, because CF grammars can produce infinite 
%lines, thus in model checking widely use bounding of loops and recursion with some N. On the other hand,
%the error traces can be bounded instead of grammars, thus we change our problem to 

%--- 


%Consider such example: we want to define either line $L = a12b3c$ is contained
%in language defined by grammar $S = A \odot B; A = 12 | 123 | a12 | 1a2; B = abc | b3c | 21a$. 

%Let us describe the main ideas of our approach to solve this problem.
%\begin{itemize}
%   \item Generate language $L'$ of all subsequences of $L$, e.g. $L' = \{a, a23, 123, bc, abc, ...\}$.
%   \item Find the intersections of $L'$ with languages of grammars $A$ and $B$. 
%         The results are:
%         \begin{itemize}
%               \item $L'_A = L' \cap L_A = \{12, 123, a12\}$;
%               \item $L'_B = L' \cap L_B = \{abc, b3c\}$.
%         \end{itemize}
%    \item Find a pairs of lines $\{(l'_A, L'_B) : l'_A \in L'_A, L'_B \in L'_B\}$ that can be shuffled to get line $L$. 
%          This pairs are $(123, abc)$ and $(a12, b3c)$. thus we can say that language defined with $G_1$ contains $L$.
%\end{itemize}

%Parsing of regular languages described in~\cite{Grigorev}

\section{Conclusion}

We propose the way to reduce emptiness checking of intersection of shuffled CF languages with finite regular one to SAT.
We show that result formula has a special structure (huge XOR subformula) which require to use XOR-SAT-solvers.
We hope that our restriction on regular language is week enough to solve real tasks.
To prove it it is necessary to evaluate our approach on real project.

Main question for future research is decidability of emptiness of shuffled CFL and regular language intersection.
It is known that shuffled CFL is not closed under intersection with regular languages~\cite{CFLShuffle}, but decidability of intersection emptiness is looks an open question.
If it will be shown that it is undecidable in general case, then it is interesting to find subclasses for which this problem is decidable.



\begin{acks}
The research was supported by the Russian Science Foundation grant 18-11-00100 and a grant from JetBrains Research.   
\end{acks}
