\newcommand{\CS}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\scriptsize\bf \#}}

\subsection{Main idea}

The solution involves using of the conception that is close to CFL-reachability to solve the problems mentioned above.

The classic CFL-r approach (TODO-CITATION) is a search of paths in a graph, edges concatenation of which is a word of a certain context-free language which is defined by grammar.
In case of static analyses it means the following specialization.
The analysed graph is the control-flow graph of the considered program such that its nodes represent states and edges contain statements which transfer program from one state to another respectively.
The grammar, in turn, defines sequences of statements passing through which leads to an error.
So, the analysis is a composition of a grammar and a set of rules that define a translation of existing program into control-flow graph.
And the result of the analysis are a control-flow graph and a set of paths in it each of which corresponds to a sequence of operations that can be passed through during the execution of the original program.

However, such definition has a few drawbacks when it comes to static analyses.
The first of them is that grammars have a slightly unnatural structure in comparison with program interpreter.
For example, call-return edges pairing is defined using grammars as brackets that contain anything else between them.
In interpreter semantics, in contrast, calls and returns are usually defined separately from each other using only stack concept.
So, the main idea is to formulate analyses in terms of pushdown automata which has the same computational power as context-free grammars (TODO-CITATION) but can emulate original interpreter semantics in more natural way.
Moreover, it is quite useful to define automata as abstract as possible to allow to use any objects as states, input and stack symbols and by this get closer to interpreter in contrast to grammars which are based on strings.
NEED-HELP: GRAMMARS, IN GENERAL, ARE NOT LIMITED BY STRINGS AND THEIR REAL DISADVANTAGE IS THAT THEY ARE BASED ON EXACT MATCHES OF TERMINALS, BUT HOW TO EXPRESS IT MORE CLEARLY?

Therefore we define an analysis as a composition of PDA and the set of rules that generates a control-flow graph.
The result of such analysis is still a set of paths in the graph each of which can be traversed during the usual execution and also accepted by automaton, thus it can cause an erroneous behaviour.

\subsection{Example}

Now, let's consider the construction of a simple analysis including definition of graph and PDA.
Let the sample problem be a kind of taint tracking analysis, namely, we propagate tainted variables from marked sources to the vulnerable sinks simultaneously checking whether they pass through filters or not.

Firstly, we construct graphs of each method so that each edge represents one statement of original program.
Next step is to provide a way of interaction between methods somehow.

TODO: PROGRAM AND PICTURE

One way of providing interprocedural connections is to replace invocations with calling and returning edges that are directed to the beginning or from the end of an invoked procedure respectively and then add different labels for each pair to distinguish one pair from another.
Of course, such approach allows to perform further analysis but has some disadvantages.
First of them is that when some procedure changes then all connections that have been added instead of invocations inside it should be removed and then new edges need to be added again.
But the second one is more significant.
It is not obvious how to support dynamically forming connections such as invocations of delegates.

Thus, instead of it, we offer to modify PDA concept and add an ability to jump to any point of input graph during the transition.
Actually, it can be interpreted as adding of fake edges.
So, there is no need to change produced control flow graph at all and the only requirement is to have an opportunity to find the entry point of an invoked procedure during the simulation.

Now let's define PDA that performs the considered analysis.
To simplify definition we give it in informal way which still can be translated into strict rules.
Let set of states be set of variables with one dummy initial state, 
set of stack symbols be just edges with one dummy edge that indicates the bottom of the stack 
and the transition rules be following (SHOULD I REWRITE THEM IN PSEUDOCODE???):
\begin{itemize}
	\item If current state is initial and next operation is assignment of some variable to tainted source then change state to this variable
    \item If current state is initial and operation is an invocation then push current edge to the stack and jump to the entry point of called procedure.
	\item If current state is a variable and operation assigns some variable to the current variable then change state to this new variable
	\item If current state is a variable and operation is invocation that passes this variable as argument then push current edge to the stack, switch state to the variable that corresponds to the argument and jump to the entry point of called procedure.
	\item If current state is a variable and operation is return of this variable from function then pop the edge from the stack, change state to the variable that is assigned by popped invocation and jump to the target of the popped edge.
	\item If current state is a variable and operation is a filter invocation then just drop further execution because since this point variable is already filtered.
	\item And finally, if there met some sink then accept the path.
	\item In all other cases just skip the operation
\end{itemize}

Therefore, if this PDA is runned from the whole programs's entry point then each accepted path is the sequence of operations that since the certain one pass some tainted variable from a source to a sink bypassing any filters.

So, since there is a definition of the analysis it is needed to have an engine that makes it possible to implement this rules using it and then get result of the computation.
The solution described below meets exactly these requirements.

\subsection{Solution structure}

In order to provide the most common interface for interaction with IDE, the solution is offered to be divided into two separate entities.
The first of them is the thin plugin for IDE that translates methods into the graphs, sends them to the second entity and then gets analysis results by request.
The second one is the remote service that aggregates graphs into the full graph of the program, is able to update it incrementally and finally can perform any available analysis by request.
This side also takes care about PDA simulation and results extraction and provides interfaces that require only the PDA implementation itself.

\subsection{Service}

Service is implemented in \CS \ but due to socket-based connection can be used with any other plugin implementation that supports interchange protocol.

The protocol is based on request-response pattern where plugin acts as a master and sends requests respectively.
The most frequent request is 

TODO: IN PROGRESS

\subsection{Automata construction}

TODO: SHORT INTRODUCTION. MORE PROPER STYLE.
The main entity that is used for the construction is the abstract PDA class that is needed to be inherited by concrete analysis implementation.
Due to generalization of PDA and its slightly different meaning in case of static analyses it is named pushdown virtual machine (PDVM) (fig.~\ref{fig:PDVM}).

\begin{figure}[h]
	\includegraphics[width=\linewidth]{pictures/{PDVM.dia}.png}
	\caption{Abstract Pushdown Virtual Machine}
	\label{fig:PDVM}
\end{figure}

It is designed to provide a set of specific methods that control PDA-like behaviour.
The first important subset of them are Push, Pop, Skip and Save.
Each of them corresponds to one transition of classic PDA but supports jumps as well.
I.e they perform corresponding stack modification, change the state and then jump somewhere or just step to the next position if jump target is not specified.
The only odd thing here is difference between Skip and Save.
Both of them just stay stack unchanged and then performs other actions, however skipped input symbols are not added into traces during further results extraction and saved ones are.

Another contol method is Accept.
Invocation of it leads to the accepting of all paths execution of which finishes in the current position and in the current state.

Finally, two remaining methods are needed to be implemented by developer using control methods.
Step method is invoked for each next input symbol in a configuration.
Action method is called in each new configuration just before input symbols reading.
It can be used when it is needed to perform a chain of transitions without any movement.

Since a PDVM is constructed it can be runned from any set of positions.

\subsection{Plugin}

TODO: PLUGIN
