\newcommand{\CS}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\scriptsize\bf \#}}

Static analyses are important part of modern development tools. 
They take care of verifying correctness of some program's behaviour freeing a programmer from this duty.
By used scope of program, an analyze can be classified as intraprocedural or interprocedural, i.e. as those which make decisions based on only one current procedure or based on the whole program respectively.
And interprocedural analyses, in theory, can be more precise due to amount of available information.

\begin{figure}[h]
	\includegraphics[width=\linewidth]{pictures/{SampleCode.dia}.png}
	\caption{Sample code}
	\label{fig:SampleCode}
\end{figure}

For example, let's consider the listing in \CS at fig.~\ref{fig:SampleCode}.
It is known that method \textit{Sink} is vulnerable to invalid arguments and so, it is marked by appropriate attribute.
The method \textit{Filter} validates its argument and possibly modifies it to ensure that returned data is definitely valid. Methods with such behaviour are marked with attribute \textit{Filter}. The most common example of such method is the one that adds escape characters into the string to avoid affecting internal behaviour of the system by user input.
And the field \textit{Source} is known as potentially tainted that is also indicated by attribute.
Class \textit{D} extracts data using class \textit{A} as a source, then validates it using class \textit{B} then performs some computations involving class \textit{C}.
So, there might appear an issue that leads to usage of data that are not been validated yet as it happens during the invocation of method \textit{Consume}.
The problem is to find all such issues, i.e. we want an analysis that finds all possible ways how data from source can reach sink bypassing filters.

This problem is a special case of interprocedural label flow analysis, so there are several approaches of solving such problems.
One of them is CFL-reachability and the solution involving this approach is present by Rehof et al. in~\cite{CFLr}.
Moreover, CFL-reachability is a long-time studied framework and thus there are a lot of other possible applications to static analyses and also there developed algorithms which can reach acceptable performance in practice (TODO: CITE GLL?).
The main idea of this approach is to find paths in a graph that satisfy constraints defined by context-free grammar.
In particular, path is accepted if the concatenation of its edges can be derived in the grammar.
However, in practice, there are a few drawbacks of such definition.
Firstly, grammar-driven parsing is based on exact matching of terminals which forces to generate a very large grammars in case when edges contain some unique attributes.
For example, brackets matching described in~\cite{CFLr} requires to generate as many rules as there are call sites in the source code.
Secondly, the structure of a grammar may not follow the structure of concrete semantics of a language, so the construction of it becomes non-obvious. (NEED-HELP: IS PREVIOUS PROPOSITION DANGEROUS???).

Moreover, there is another engineering problem that it is needed to extract a graph from a program to perform further computations.
So, the main purpose of our work is to implement a tool solving all mentioned problems and thus allowing to use CFL-reachability in practical cases.
In the further sections: 
\begin{itemize}
	\item We describe scalable representation of a graph which allows to contain as much information about the program as necessary
	\item We introduce another approach for definition of constraints based on pushdown automata instead of grammars which makes formulating of analyses easier
	\item We present the extensible solution which allows to implement new analyses using introduced abtractions
	\item We evaluate it by testing on a few synthetic tests and estimate performance by running of an analysis on a large open-source project
\end{itemize}

%Another approach is abstract interpretation which main idea is to define the semantics abstracting the concrete one.
%We propose to combine these two approaches to achieve acceptable performance and expressive power.
%I.e. the program is translated into a graph as it is in CFL-r, but constraints that specifiy what paths is needed to be accepted are set by pushdown automaton which transition relation simulates the semantics of original program.
%Let's take a closer look at these two components that define an analysis in conjunction.
