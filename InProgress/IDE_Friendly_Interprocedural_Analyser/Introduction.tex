\newcommand{\CS}{C\nolinebreak\hspace{-.05em}\raisebox{.4ex}{\scriptsize\bf \#}}

Static code analysis is an important part of modern software development tools.
It take care of verifying correctness of some program's behaviour freeing a programmer from this duty.
By used scope of program, an static analysis can be classified as intraprocedural and interprocedural, i.e. as those which make decisions based on only one current procedure or based on the whole program respectively.
And interprocedural analyses, in theory, can be more precise due to amount of available information.

\begin{figure}[h]
	\includegraphics[width=\linewidth]{pictures/{SampleCode.dia}.png}
	\caption{Sample code}
	\label{fig:SampleCode}
\end{figure}

One of the classical problem which reqires interprocedural analysis is taint tracking problem (e.g. described in \cite{TaintTrackingIntro} and \cite{TaintTrackingISO}).
The problem is that the input data can has inappropriate format or contains an exploit such as SQL injection.
Such data is called \textit{tainted}.
Tainted data can reach vulnerable operation that can lead to an incorrect behaviour in case of incorrect format, or can be a reason of security issue.


Simple example of C\# code which may requre taint analysis is presented in fig.~\ref{fig:SampleCode}.
We will use this example for our solution explanation.
First of all, we introduce a number of entities which play importatnt roles in tis analysis.
The first type of them is \textit{source}.
In our case \textit{source} is a field that can potentially contains the tainted data, for example, the field \textit{Source} of the class \textit{A}.
The second type of entities is \textit{sink}.
\textit{Sink} is a method which is vulnerable to tainted data.
In our example, the method \textit{Sink} of the class \textit{C} has this property.
And the third important type of entities is a \textit{filter} (or \textit{sanitizer} in some other definitions).
It is a method that checks the correctness of data passing through it and if it is incorrect, \textit{filter} throws an exception or modifies data to ensure the correctness of the result.
The method \textit{Filter} of the class \textit{B} in the given snippet be a filter.

We assume that each entity is marked by a programmer with an appropriate attribute: \textit{[Tainted]} for sources, \textit{[Filter]} for filters and \textit{[Sink]} for sinks.
So, the problem stands for finding all paths being passed through which the tainted data can flow into a sink bypassing any filter.

In our example the class \textit{D} extracts data using the class \textit{A} as a source, then validates it using class \textit{B} then performs some computations involving the class \textit{C}.
We can see, that there might appear an issue that leads to usage of data that are not been validated if we invoke the method \textit{Consume}.
The problem is to find all such issues, i.e. we need an interprocedural analysis that finds all possible ways how data from source can reach sink bypassing filters.

The one of the well-known framework for interprocedural static code analysis is a CFL-reachability framework which was proposed by Thomas Reps~\cite{Reps}.
This framework is generic: it provides the abstraction which allaws one to implement meny different types of interprocedural static code analysis, sach as pointer analysis~\cite{Zheng, JavaCFL}, taint analysis~\cite{Huang:2015:SPT:2771783.2771803}, lable flow analysis~\cite{10.1007/11823230_7,CFLr}, library summarization~\cite{10.1007/978-3-662-54434-1_33}.
Moreover, CFL-reachability is a long-time studied framework and thus there are a number of specific solutions which demonstrate reasonable performance in practice~\cite{Wang:2017:GSD:3093315.3037744}.

Note, that this framework allows one to implement analysis which can be flow-sensitive or context-sensitive, but not both at the same time~\cite{Reps:2000:UCD:345099.345137}. In our examples we implement flow-sensitive analysis, but one can modify it ti be context-sensitive.

The main idea of this approach is to find paths in a graph that satisfy constraints defined by a context-free grammar.
In particular, a path is accepted if the concatenation of labels on its edges gives a word which can be derived in the grammar.
However, in practice, there are a few drawbacks of such grammar-based definition.
Firstly, grammar-driven parsing is based on exact matching of terminals which forces to generate a very large grammars in case when edges contain some unique attributes.
For example, brackets matching described in~\cite{CFLr} or~\cite{Zheng, JavaCFL} requires to generate as many rules as there are call sites in the source code.
Secondly, grammar is a additional lelvel of abstraction.
This level is useful for algorithms formalization, but it is not such flexible as direct maniulation with correspondend push-down automaton.

Also, there is engineering problem is extraction of a graph from a program to perform further computations.
First of all, it should be possible to update the graph locally to synchronise it with source code modifications with minimal effort.
Another importatnt requirement is to provide generic graph representation to be able to implement difeerent types of analysis. 

The main goal of our work is to implement a tool solving all mentioned problems and thus allowing to use CFL-reachability in practical cases.
We make the following contributions in the paper.
\begin{itemize}
	\item We describe scalable representation of a graph which allows to contain as much information about the program as necessary.
	\item We introduce the approach for definition of constraints based on pushdown automata instead of grammars which makes formulating of analyses easier.
	\item We present the implementation of proposed approach which allows to create new types of analysis using introduced abtractions.
	Also we implemet the plugin which uses the solution to provide analysis results to ReSharper, Rider and InspectCode (source code and executables can be downloaded here: \url{github.com/gsvgit/CoFRA}).
	\item We evaluate the proposed solution by testing on a few synthetic tests and estimate performance by running an analysis on a large open-source project.
\end{itemize}

%Another approach is abstract interpretation which main idea is to define the semantics abstracting the concrete one.
%We propose to combine these two approaches to achieve acceptable performance and expressive power.
%I.e. the program is translated into a graph as it is in CFL-r, but constraints that specifiy what paths is needed to be accepted are set by pushdown automaton which transition relation simulates the semantics of original program.
%Let's take a closer look at these two components that define an analysis in conjunction.
