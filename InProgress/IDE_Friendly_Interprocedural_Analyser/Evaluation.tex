In order to test the resulting solution we have implemented the frontend as a plugin using ReSharper SDK, so it can be installed into ReSharper, Rider and InspectCode.
The source code is parsed by internal ReSharper tools and the result is used to produce graphs and meta-information.
The issues found by the backend are shown using code highlighting.

Also, we have implemented the PDA constructed in the section 2 with some slight modifications allowing to process interactions with object fields.
To provide more information an issue found by this analysis, the code higlighting accompanied by bulbs containing the full path of tainted variable from the source to the sink represented as the sequence of operations.

\subsection{Sample cases}

Let's look closer at properties of the resulting soluiton.
All these properties are illustrated by screenshots taken exactly from the runned Rider IDE with some small relocations of bulbs to make them not to overlap the code.

Firstly, the solution ensures flow sensitivity. I.e. it processes flow of variables passed into methods and returned from them correctly.
Which can be seen at fig~\ref{fig:ReturnsAndBrackets}.

\begin{figure}[h]
	\includegraphics[width=\linewidth]{screenshots/ReturnsAndBrackets.png}
	\caption{Snippet 1}
	\label{fig:ReturnsAndBrackets}
\end{figure}

In the example, line 39 contains the sink reachable from the tainted source, so it is highlighted and there also shown a full trace of instructions over which the tainted variable is passed.
However, the sink on line 40 is not highlighted because data reaching it are passed through filter, despite it passes through method \textit{Brackets} which also passed by a tainted variable.

Secondly, the solution has a limited context sensitivity. I.e. it allows to track propagation of objects that are tainted by assigning of some fields inside them both by their own methods and by outer code interacting with their fields directly.
The first case is shown at fig~\ref{fig:ObjectTainting}.

\begin{figure}[h]
	\includegraphics[width=\linewidth]{screenshots/ContextSensitivity.png}
	\caption{Snippet 2}
	\label{fig:ObjectTainting}
\end{figure}

There is a method \textit{Store} which execution affects only that object by which reference the method is called.

Finally, the solution works with any type of recursion and does not fall into infinite cycles.
It can be seen at fig.~\ref{fig:Recursion}.

\begin{figure}[h]
	\includegraphics[width=\linewidth]{screenshots/Recursion.png}
	\caption{Snippet 3}
	\label{fig:Recursion}
\end{figure}

\subsection{Performance}

It is also necessary to measure the performance of the resulting solution.
Because the implemented taint tracking analysis forces to mark all participating entities manually, it is difficult to perform it on some large project.
However, there is another intermediate analysis which is runned before any other one to collect some information required by resolver.
In particular, it tracks propagation of all variables to discover all possible concrete types of each variable.
So, it involves each variable and each method in the whole program and thus the time and space required for execution of this analysis may be consistent estimation of the efficiency of the solution.

The code base that has been chosen as a source of data is the full solution of the Mono project.
(TODO: ADD SYSTEM CONFIGURATION).
The results is shown in the table~\ref{tab:Performance}.

\begin{table}[h]
	\begin{tabular}{|l|l|l|l|l|}
	\hline
		Project & Classes & Methods & \begin{tabular}[c]{@{}l@{}}Execution \\ time (s)\end{tabular} & \begin{tabular}[c]{@{}l@{}}Allocated \\ memory (GB)\end{tabular} \\ \hline
		Mono & 21013 & 192745 & $21\pm 0.5$ & $\sim 4.2$ \\ \hline
	\end{tabular}
	\caption{Performance}
	\label{tab:Performance}
\end{table}
