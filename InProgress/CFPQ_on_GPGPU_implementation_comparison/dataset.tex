\section{Dataset description}

We create and publish a dataset for CFPQ algorithms evaluation.
This dataset contains both the real data and synthetic data for different specific cases, such as the theoretical worst case, or matrices representation specific worst cases.

Our goal is querying algorithms evaluation, not a graph storages or graph databases evaluation, so all data is presented in a text-based format to simplify usage in different environments.
Grammars are in Chomsky Normal Form and are stored in the files with \verb|yrd| extension.
Each line is a rule in the form of a triple or pair.
The example of grammar representation is presented in figure~\ref{fig:grammar_example} in appendix.

Graphs are represented as a set of triples (edges) and are stored in the files with \verb|txt| extension.
Example of graph is presented in figure~\ref{fig:graph_example} in appendix.

Each case is a pair of set of graphs and a set of grammars: each query (grammar) should be applied to each graph.
Cases are placed in folders with the case-specific name.
Grammars and graph are placed in subfolders with names \verb|Grammars| and \verb|Matrices| respectively.


It is known that variants of the \textit{same generation query}~\cite{FndDB} are a classical example of queries that are context-free but not regular, so we use this type of queries in our evaluation.
The datatset includes data for next cases.

\textbf{[RDF]} The set of real RDF files (ontologies) from~\cite{RDF} and two variants of the same generation query (figures~\ref{fig:grammar_rdf} in appendix) which describes hierarchy analysis.

\textbf{[Worst]} Theoretical worst case for CFPQ time complexity which is proposed by Hellings~\cite{hellingsPathQuerying}: the graph is two cycles of coprime lengths with a single common vertex.
The first cycle labeled by an open bracket and the second cycle is labeled by a close bracket.
Query is a grammar for $A^nB^n$ languge (grammar $G_1$, figure~\ref{fig:grammar_example} in appendix).

\textbf{[Full]} The case when the input graph is sparse, but the result is a full graph.
Such a case may be hard for sparse matrices representation.
As an input graph, we use a cycle all edges of which are labeled by the same token.
As a query we use two grammars which describe sequence of tokens of arbitrary length: simple ambiguous grammar $G_2$  and highly ambiguous grammar $G_3$ (figure~\ref{fig:grammar_full} in appendix).

\textbf{[Sparse]} Sparse graphs from~\cite{fan2018scaling} which generated by the GTgraph graph generator, and emulates realistic sparse data.
Names of these graphs have a form \texttt{Gn-p}, where \texttt{n} represents the total number of vertices, each pair of vertices is connected by probability \texttt{p}.
The query is the same generation query represented by grammar $G_1$ (figure~\ref{fig:grammar_example} in appendix).

