\section{Dataset description}

We created and published a dataset for CFPQ algorithms evaluation.
This dataset contains both the real-world data and synthetic data for different specific cases, such as the theoretical worst case, or matrices representation specific worst cases.

Our goal is to evaluate querying algorithms, not graph storages or graph databases, so all data is presented in a text-based format to simplify usage in different environments.
Grammars are in Chomsky Normal Form, and graphs are represented as a list of triples (edges).
Some details of the data representation can be found in Appendix.

It is known that variants of the \textit{same generation query}~\cite{FndDB} are a important example of queries that are context-free but not regular, so we use this type of queries in our evaluation.
The dataset includes data for the following cases.
Each case is a pair of set of graphs and a set of grammars: each query (grammar) should be applied to each graph.

\textbf{[RDF]} The set of real-world RDF files (ontologies) from~\cite{RDF} and two variants of the same generation query which describes hierarchy analysis.
The first query is a grammar $G_4$:
\[
 \begin{array}{lcl}
   s  \rightarrow \textit{SCOR} \ s \ \textit{SCO}   & \quad & s  \rightarrow \textit{TR} \ \textit{T}     \\
   s  \rightarrow  \textit{TR}  \ s \ \textit{T}     & \quad & s  \rightarrow \textit{SCOR} \ \textit{SCO} .

 \end{array}
 \]
The second one is grammar $G_5$: $s \rightarrow \textit{SCOR} \ s \ \textit{SCO} \ | \  \textit{SCO}$.

\textbf{[Worst]} Theoretical worst case for CFPQ time complexity which is proposed by Hellings~\cite{hellingsPathQuerying}: the graph is two cycles of coprime lengths with a single common vertex.
The first cycle is labeled by the open bracket and the second cycle is labeled by the close bracket.
Query is a grammar for $A^nB^n$ languge.
The example of such graph is presented and such grammar is presented in figure~\ref{fig:grammar_example}.

\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.20\textwidth}
        \centering
        \[
         \begin{array}{rcl}
           s & \rightarrow & A \ s \ B \\
           s & \rightarrow & A \ B
         \end{array}
         \]
        \caption{Grammar $G_1$ which specifies the $A^n B^n$ language}
    \end{subfigure}%
    ~\quad
    \begin{subfigure}[b]{0.24\textwidth}
        \centering
        \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
   \node[state] (q_1)   {$1$};
   \node[state] (q_2) [above=of q_1] {$2$};
   \node[state] (q_3) [above right=of q_1, below right=of q_2] {$0$};
   \node[state] (q_4) [right=of q_3] {$3$};
    \path[->]
    (q_1) edge  node {A} (q_2)
    (q_2) edge  node {A} (q_3)
    (q_3) edge  node {A} (q_1)
    (q_3) edge[bend left, above]  node {B} (q_4)
    (q_4) edge[bend left, below]  node {B} (q_3);
\end{tikzpicture}

        \caption{Example of input graph $D_1$ for worst case where \texttt{A} is the open bracket, and \texttt{B} is the close bracket}
        \label{fig:worstCaseGraph}
    \end{subfigure}%
    \caption{The example of graph and grammar for worst case}
    \label{fig:grammar_example}
\end{figure}


\textbf{[Full]} The case when the input graph is sparse, but the result is a full graph.
Such a case may be hard for sparse matrices representation.
As an input graph, we use a cycle, all edges of which are labeled by the same token.
As a query we use two grammars which describe sequence of tokens of arbitrary length: simple ambiguous grammar $G_2$: $s \rightarrow  s \ s \ | \ A$,  and highly ambiguous grammar $G_3$: $s \rightarrow s \ s \ s \ | \ A$.

\textbf{[Sparse]} Sparse graphs from~\cite{fan2018scaling} generated by the GTgraph graph generator, and emulates realistic sparse data.
Names of these graphs have a form \texttt{Gn-p}, where \texttt{n} represents the total number of vertices, probability that a pair of vertices is connected is \texttt{p}.
The query is the same generation query represented by the grammar $G_1$ (figure~\ref{fig:grammar_example}).
