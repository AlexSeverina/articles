\section{Introduction}

Context-Free Path Querying (CFPQ) is an actively developed area in graph database analysis.
CFPQ is also used for static code analysis~\cite{Reps,10.1145/193173.195287,Zheng}, RDF querying~\cite{10.1007/978-3-319-46523-4_38,MEDEIROS201975}, biological data analysis~\cite{cfpqBio}.

Most of research is focused on developping algorithms for CFPQ evaluation~\cite{hellingsRelational,ward2008distributed,cfpqBio,MEDEIROS201975,Azimov:2018:CPQ:3210259.3210264,Grigorev:2017:CPQ:3166094.3166104}, whereas specification languages for context-free queries are not investigated enough.
Best to our knowledge, only one extension for Sparql supports context-free constarints: cfSPARQL~\cite{10.1007/978-3-319-46523-4_38}.
There is also a proposal for CFPQ as a part of Cypher\footnote{Proposal with path pattern syntax for openCypher: \url{https://github.com/thobe/openCypher/blob/rpq/cip/1.accepted/CIP2017-02-06-Path-Patterns.adoc}.
It is shown that context-free constraints can be expressed with the proposed syntax. Access date: 30.03.2020} language, but there is no implementation for it yet.
We believe that more research should be conducted on the specification languages fo context-free constraints in graph querying.

It is worth noting that graph analysis is often only a part of a more complex system, usually implemented in a general-purpose language.
Since a graph query language is unsuitable to implement a whole system, there should be means of integration of them into general-purpose programming languages.
There are many ways to integrate them ranging from creating graph queries from string values of a general-purpose language to implementing a special embedded domain specific language, and even more sophisticated.

Although simple, the string manipulating approach does not provide a developper with any safety guarantees.
There is no way to ensure that a string generated by an application is a valid query or, in case it is not, to provide any feedback.
This makes string manipulating technique error prone, the code --- unclear and hard to maintain.

Safety of an embedded DSL entirely depends on its implementation.
Some general-purpose languages with powerfull type systems (such as \haskell{}, \ocaml{} or \scala{}) or the ones supporting hygienic macros (such as \scheme{} or \rust{}) facilitate creating safe and reliable DSLs.
Still, they typically lack full support of a development environment: it may be harder to debug queries or issues with composability may arise.

There is a general trend towards imposing more restricting type systems on programming languages.
Among many others are typing annotations for \python{} and \typescript{} code and nullability checks in \kotlin{}.
Typing graphs and query languages improves  readability and simplifies maintainance~\cite{10.1145/2076623.2076653}.

Parser combinators are the answer to the integration of parsing into a general-purpose programming language.
Recursive descend parsers are encoded as functions of the host language, while grammar constructions such as sequencing and choice are implemented as higher-order functions.
This idea was first introduced in~\cite{burge} and further developped in numerous works.
Notable development is monadic parser combinators~\cite{hutton1996monadic}.
In this approach, one can not only parse the input, but simultaneously run semantics calculation if parsing succeeds.
Paper~\cite{izmaylova2016practical} proposed the first monadic parser combinator library which solves the long-standing problem of inability to handle ambiguous and left-recursive grammars.
A library for graph querying was developped~\cite{10.1145/3241653.3241655} based on this work.
The core idea is to use generalized parser combinators as both a way to formulate a query and to execute it.
This approach inherits benefits of combinatory parsing: ease of code reuse, type safety guaranteed by the host language and, since the parser is simply a function, the integrated development support.

Besides integration, it can compute both the single-source and all pairs semantics, as well as execute user actions.
The~single-source semantics is relevant to many real-world applications, including manual data analysis.
It also may be less time-intensive, since on average it needs to expore only a subgraph of the input graph.
Many querying algorithms are only capable to compute all pairs reachability which makes them unsuitable for some applications.

In this paper we make the following contributions.
\begin{itemize}
  \item We demonstrate how to use combinatory-based graph querying on example.
  \item We illustrate such features of the approach as type-safety, flexibility (composability and generics), IDE support and computing user-defined actions.
  \item We evaluate single-source context-free path querying on some real-world RDFs.
  \begin{itemize}
    \item Based on our evaluation, the most common case in RDF context-free querying is when the number of paths in the answer set is big, but they are small.
    \item We demonstrate that the single-source CFPQ can feasibly be used to evaluate such queries.
    \item We conclude that there is a need for a further detailed analysis of both theoretical time and space complexity of single-source CFPQ.
  \end{itemize}
\end{itemize}
