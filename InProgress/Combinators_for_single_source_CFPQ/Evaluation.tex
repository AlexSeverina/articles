\section{Evaluation}

We evaluate Meerkat.Graph on single source context-free path querying scenario.
For evaluation we use Neo4j graph databese which was run on PC with the following configuration: CPU, RAM, OS, JVM.

Neo4j is integreted into application !!!!

Dataset contains two real-world RDFs: Geospecies which contains information about biological hierrarchy\footnote{\url{https://old.datahub.io/dataset/geospecies}. Access date: 12.11.2019.} and Enzime which is a part of UniProt database\footnote{Protein sequences data base: \url{https://www.uniprot.org/}. RDFs with data are avalable here: \url{ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/rdf}. Access date: 12.11.2019}.
Detailed description of these graphs is presented in table~\ref{tbl:datasetDetails}.
Note, that graphs was loaded into database fully, not only edges which laballed by relations used inqueryes.

\begin{table}[ht]
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
 Graph & \#V & \#E & \#SCO & \#T & \#NT & \#BT \\
 \hline
 Enzime &  &  &  &  & & \\
 Geospecies &  &  &  &  & & \\
 \hline
\end{tabular}
\caption{Details of graphs}
\label{tbl:datasetDetails}
\end{table}

Queries for evaluation are versions of same-generation query --- classical context-free query which is useful for hierarchy analysis.
All queryes in our evaluation a created by using functions which described in the section~\ref{!!!}. Namely we create and evaluate three queries $Q_1$, $Q_2$ and $Q)3$ as presented below.

\begin{lstlisting}
def q1 (startV) =
    val q =
        sameGen(makeBrs(RDFS__SUB_CLASS_OF ::
                        RDF__TYPE :: Nil))
    queryFromV(startV, q)
\end{lstlisting}

\begin{lstlisting}
def q2 (startV) =
    val q =
        sameGen(makeBrs(skos__narrowerTransitive :: Nil))
    queryFromV(startV, q)
\end{lstlisting}

\begin{lstlisting}
def q3 (startV) =
    val q =
        sameGen(makeBrs(skos__narrowerTransitive :: Nil))
    queryFromV(startV, q)
\end{lstlisting}

As you can see, once create a set of appropriate functions, one can easely construct new queryes.

For each graph and each query we run this query form each vertex from graph and measure elapsed time and required memory by using !!! tool.
Note, that mesured memory is allocated by JVM, not really used.


\textbf{Enzime RDF querying.} 
.

Results of evaluation are presented in figures~\ref{fig:enzime_time_per_paths} and~\ref{fig:enzime_mem_per_paths}.
Also we collect paths length destribution which is showed in figure~\ref{fig:pLength}.
We can see that prvided datasets contain relatively short paths which satisfie queryes.


\begin{figure}
\centering
  \subcaptionbox{Enzime\label{fig:pLengthEnzime}}
    {\includegraphics[width=0.23\textwidth]{data/enzime/enzime_path_per_length.pdf}}
\subcaptionbox{Geospecies\label{fig:pLengthGeospecies}}
{\includegraphics[width=0.23\textwidth]{data/geo/geo_path_per_length.pdf}}
\caption{Paths length destribution}\label{fig:pLength}
\end{figure}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{data/enzime/enzime_time_per_paths.pdf}
    \caption{Query execution time for Enzime dataset}
    \label{fig:enzime_time_per_paths}
  \end{center}
\end{figure}

Figure~\ref{fig:enzime_time_per_paths} shows dependency of query evaluation time on query answer size in terms of number of edge-different !!! paths.
First of all, we can see that evaluation time is linear on answer size.
Also we can see, that time which requred to evaluate query for one specific vertex is relatively small.
In our case it is less than 90ms.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{data/enzime/enzime_mem_per_paths.pdf}
    \caption{Query required memory for Enzime dataset}
    \label{fig:enzime_mem_per_paths}
  \end{center}
\end{figure}

Figure~\ref{fig:enzime_mem_per_paths} shows dependency of memory requred to evaluate qurey on query answer size in terms of number of uniqie paths.


\textbf{Geospecies RDF querying.}

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{data/geo/geo_time_per_paths.pdf}
    \caption{Query execution time for Geospecies dataset}
    \label{fig:geo_time_per_paths}
  \end{center}
\end{figure}

Here we can see !!!!

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{data/geo/geo_mem_per_paths.pdf}
    \caption{Query execution time for Geospaties dataset}
    \label{fig:geo_time_per_paths}
  \end{center}
\end{figure}

Finally, we can conclude that confext-free path querying in single source scenario can be efficiently evaluated by using !!! in case when number of paths in answer is big but its length is relatively small.
While all pairs scenario is still hard ~\cite{!!!}, single source scenarion, which is useful for manual or interactive data analysis, can be !!!
Also we can see that while theoretical time and space complexity of CFPQ algoritms at leas cubic, in demonstrated scenario real execution time and required memory is linear.
So, it is necessary to provide detailed time and space complexity analysis of algorithms.
