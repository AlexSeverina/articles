\section{Generalized Parser Combinators}

In~\cite{ScalaGraphParsing} showed that combinators techniques is applicable for graph travesing, but well-known problem of combinator with left recursion is not solved.
But this problew was solved in classical parser-combinators~\cite{Meerkat} and implemented in Meerkat library.
Meerkat library is a general parser combinators library implemented in Scala programming language; by using memoization, continuation-passing style and the ideas of Johnson~\cite{Johnson}, it supports arbitrary (left-recursive and ambigues) context-free specifications. 
This library implements classical set of combinators, supports action code specification, and provide \lstinline{syn} macro for custom handling of recursive nonterminal description.
Meercat creates compressed representation of parse forest (SPPF) which is useful for CFPQs results representation~\cite{GrigorevR16}. 
Time and space complexity of this soluton are cubic in worst case.

An example Meerkat specification of grammar~\ref{fig:anbnGrammar} is presented in~\ref{fig:anbnMeerkat}.

\begin{figure}[h]
\begin{lstlisting}
val S = syn("a" ~ S.? ~ "b")
\end{lstlisting}
\caption{Meercat specification of grammar~\ref{fig:anbnGrammar}}
\label{fig:anbnMeerkat}
\end{figure}


In~\cite{GrigorevR16} showed that generalized LL parsing algorithm~\cite{scott2010gll} can be generalized to CFPQs processing and this generalization prodices efficient solution which can provide structured represenataion of query result.
As the Meerkat library is closely related to the Generalized LL algorithm and since GLL can be generalized for context-free path querying, it is also possible to adapt Meerkat library for graph querying. 
It can be done by providing a function for retrieving the symbols which follow the specified position and utilizing it in the basic set of combinators.
Details described below.


\subsection{SPPF}

Structural representation. 
Derevation tree.
Forest for unambiguous grammars.
For graph too.
Shared Packed Parse Forest (SPPF)~\cite{SPPF} structure, description, usability for CFPQ.

Binarized Shared Packed Parse Forest (SPPF)~\cite{brnglr} compresses derivation trees optimally reusing common nodes and subtrees.
Version of GLL which utilizes this structure for parsing forest representation achieves worst-case cubic space complexity~\cite{gllParsingTree}.

Binarized SPPF can be represented as a graph in which each node has one of four types described below.
We denote the start and the end positions of substring as $i$ and $j$ respectively, and we call tuple $(i,j)$ an \textit{extension} of a node.

\begin{itemize}
    \item \textbf{Terminal node} with label $(i, T, j)$.
    \item \textbf{Nonterminal node} with label $(i, N, j)$. 
    This node denotes that there is at least one derivation for substring $\alpha=\omega[i..j-1]$ such that $N \Rightarrow^*_G \alpha, \alpha = \omega[i..j-1] $.
    All derivation trees for the given substring and nonterminal can be extracted from SPPF by left-to-right top-down graph traversal started from respective node.     
    \item \textbf{Intermediate node}: a special kind of node used for binarization of SPPF. These nodes are labeled with $(i,t,j)$, where $t$ is a grammar slot.
    \item \textbf{Packed node} with label $(N \rightarrow \alpha, k)$. 
    Subgraph with ``root'' in such node is one possible derivation from nonterminal $N$ in case when the parent is a nonterminal node labeled with $(<\mkern-9mu | \mkern-9mu> (i, N, j))$.

\end{itemize}

An example of SPPF is presented in figure~\ref{SPPF}.
