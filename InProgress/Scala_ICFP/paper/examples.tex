\section{Examples}
\label{sec:examples}

In this section we introduce and describe some examples of our library usage.
We show that combinators are expressive enough for realistic queries and allows to create generic queries easely.

\subsection{Complicated Query to Map}

Let's form a complex query for our city graph. 
Let us capture one city, let's say city with name $a$. 
Now having a city graph and captured vertex we would like to know all paths such if as $i$ city from begining of our path we visit country $X$ then as $i$ city from end of our path we visit country $X$ too. 
And also the middle city in our path is our captured city $a$.
In a terms of combinators we can define our path as shown on fig.~\ref{fig:pathQuery}.
Here \lstinline{reduceChoice} is a function which transforms a list of queries to one query which is formed by reducing given list with \lstinline{|} combinator.
The \lstinline{pathPart} query recursively defines a path of our way.
Also, \lstinline{middleCity} is a vertex query which parses our captured city $a$ and \lstinline{roadTo} query parses a \emph{roadTo} edge.

\begin{figure}[h]
\begin{lstlisting}
val countriesList = List("X", "Y")
val path = 
  (reduceChoice(countriesList.map(pathPart)) | 
    middleCity)
def pathPart(country: String) =
  syn(city(country) ~ roadTo ~ path ~ 
    roadTo ~ city(country))

val middleCity = V(_.value() == "a")
val roadTo = E(_.value() == "road_to")
def city(country: String) =
  V(_.country == country)
\end{lstlisting}
\caption{Path query}
\label{fig:pathQuery}
\end{figure}

\begin{figure}[h]
\begin{lstlisting}
def reduceChoice(xs: List[Nonterminal]) = 
  xs match {
    case x :: Nil     => x
    case x :: y :: xs => 
      syn(xs.foldLeft(x | y)(_ | _))
  }
\end{lstlisting}
\caption{Reduce choice function implementation}
\label{fig:reduceChoice}
\end{figure}

Now we would like, to get from our query only \lstinline{city} combinator result. 
For that purpose let us modify it to make return result. 
In our library we have a \lstinline{^} and \lstinline{&} functions for that. 
Then we will have definition of our combinators as presented in fig.~\ref{fig:fixedPathQ}.

\begin{figure}[h]
\begin{lstlisting}
val middleCity = 
  syn(V(_.value() == "a") ^^) & (List(_))
def pathPart(country: String) = syn(
  (city(country) ~ roadTo ~ 
    path ~ roadTo ~ city(country) & {
      case a ~ (b: List[_]) ~ Entity => 
        a +: b :+ c })
\end{lstlisting}
\caption{Fixed queries}
\label{fig:fixedPathQ}
\end{figure}

Now we execute our query. It is evident that for the graph presented on fig.~\ref{fig:graph} we can get only three paths which satisfies given criteria:
\begin{itemize}
\item single-vertex path $a$;
\item $b \rightarrow a \rightarrow d$
\item $c \rightarrow b \rightarrow a \rightarrow d \rightarrow e$
\end{itemize}

A simplified SPPF for this query is presented in Fig.~\ref{fig:sppf}: rounded rectangles represent nonterminals and other rectangles represent productions. 
Every rectangle contains a nonterminal name or a production rule, as well as start and end nodes of the path in the input graph derived from the corresponding rectangle. 
Gray rectangles are start nonterminals.

\subsection{Same Generation Query}

Yet another example of first order functions usage is generalisation of classical same generation query which is one of basic context-free path queries.
One of application of such queries is hierarchy analysing in RDF storages~\cite{CFGonRDF}.
Let suppose that we have RDF graphs with two pairs of relation (each pair is relation and its revers): (\emph{subClassOf}; $\text{\emph{subClassOf}}^{-1}$) and (\emph{type}; $\text{\emph{type}}^{-1}$).
We want to evaluate two queries which detect all pairs of nodes which are connected by path derivable in grammars $G_1$~(Fig.~\ref{grammarQ1}) and $G_2$ respectively~(Fig.~\ref{grammarQ2}). 


\begin{figure}[h]
   \centering
   \[
\begin{array}{rl}
   0: & S \rightarrow \text{\textit{subClassOf}}^{-1} \ S \ \text{\textit{subClassOf}} \\ 
   1: & S \rightarrow \text{\textit{type}}^{-1} \ S \ \text{\textit{type}} \\ 
   2: & S \rightarrow \text{\textit{subClassOf}}^{-1} \ \text{\textit{subClassOf}} \\ 
   3: & S \rightarrow \text{\textit{type}}^{-1} \ \text{\textit{type}} \\ 
\end{array}
\]
   \caption{Context-free grammar $G_1$ for query 1}
   \label{grammarQ1}
   \end{figure}

\begin{figure}[h]
   \centering
   \[
\begin{array}{rl}
   0: & S \rightarrow B \ \text{\textit{subClassOf}} \\ 
   0: & S \rightarrow \text{\textit{subClassOf}} \\ 
   1: & B \rightarrow \text{\textit{subClassOf}}^{-1} \ B \ \text{\textit{subClassOf}} \\
   2: & B \rightarrow \text{\textit{subClassOf}}^{-1} \ \text{\textit{subClassOf}} \\ 
\end{array}
\]
   \caption{Context-free grammar $G_2$ for query 2}
   \label{grammarQ2}        
   \end{figure}

   Of course, these queries can be written in Meerkat easely because it supports context-free queries: code is presented in Fig.~\ref{fig:query1Meerkat} and Fig.~\ref{fig:query2Meerkat}.

\begin{figure}[h]
\begin{lstlisting}
val query1: Nonterminal = syn(
   "subclassof-1" ~ query1.? ~ "subclassof" |
   "type-1" ~ query1.? ~ "type")
\end{lstlisting}
\caption{The same generation query (Query 1) in Meerkat}
\label{fig:query1Meerkat}
\end{figure}


\begin{figure}[h]
\begin{lstlisting}
val S = syn(
  "subclassof-1" ~ S ~ "subclassof")
val query2 = syn(S ~"subclassof")
\end{lstlisting}
\caption{The same generation query (Query 2) in Meerkat}
\label{fig:query2Meerkat}
\end{figure}

As you can see, grammars and code representations for these two queries looks pretty similar.
May we avoid code duplication and generalize them? 
Yes, we can and not only for these two queries.
The function \lstinline{sameGen} presented in Fig~\ref{fig:gen} is a generalization of the same generation query and is independent of the environment such as the input graph structure or other parsers and also uses a function \lstinline{reduceChoice} presented in \ref{fig:reduceChoice}.
It can be used for the creation of other queries, including the one presented in Fig~\ref{fig:query1Meerkat}: it is the result of the application of \lstinline{sameGen} to the appropriate relations (which can be treated as opening and closing brackets).
Another application of the \lstinline{sameGen} is a Query 2, which can be founded in Fig.~\ref{fig:query2Gen}.


\begin{figure}[h]
\begin{lstlisting}
def sameGen(brs) =
  reduceChoice(
    bs.map { case (lbr, rbr) => 
      lbr ~ syn(sameGen(bs).?) ~ rbr }) 
\end{lstlisting}
\caption{Generic function for the same generations query}
\label{fig:gen}
\end{figure}


\begin{figure}[h]
\begin{lstlisting}
val query1 = syn(sameGen(List(
    ("subclassof-1", "subclassof"),
    ("type-1", "type"))))
\end{lstlisting}
\caption{Query 1 as an application of \lstinline{sameGen}}
\label{fig:query1Gen}
\end{figure}


\begin{figure}[h]
\begin{lstlisting}
val query2 = syn(
  sameGen(List(("subclassof-1", "subclassof"))) ~
   "subclassof")
\end{lstlisting}
\caption{Query 2 as an application of \lstinline{sameGen}}
\label{fig:query2Gen}
\end{figure}


We show that parser combinators provide a simple and safe way to creation of generic queries.
By using this ability, it may be possible to create a library of \ ``standard templates'' for most popular generic queries like same generation query or for domain specific queries (for example, for specific static code analysis problem).


\subsection{Classical Movies Queries}

In order to demonstarte expressive power of our solution and to demonstrate more scenarios for 
semantic actions usage we preovide some examples of classical queries to movie database which 
represents movies, actors, directors, users and relationships between them.
All of queries can be found on a Neo4j tutorial page~\footnote{The set of classical queries to movie dataset in Cypher language: \url{https://neo4j.com/developer/movie-database/}. Access date: 16.01.2018.}.

Let's look at one of these examples written using Cypher language and how it transforms into Meerkat query
(fig.~\ref{fig:cypher_movie_query}).

\begin{figure}[h]
\begin{lstlisting}
MATCH (u:User {login: 'adilfulara'})-[:FRIEND]->
      (f:Person)-[r:RATED]->(m:Movie)
WHERE r.stars > 3
RETURN f.name, m.title, r.stars, r.comment
\end{lstlisting}
\caption{Mutual Friend recommendations query in Cypher}
\label{fig:cypher_movie_query}
\end{figure}

Firstly, we should define parsers that correspond to persons, movies and specific user.
Secondly, we should also create parsers corresponding to relations.
Then, we can get a full path parser using combination of previously defined primitives.
Finally, adding semantic action that extracts all needed data we get a complete path query.
Result is shown on fig.~\ref{fig:meerkat_movie_query}.
Using similar transformations we can write the most queries which can be defined using Cypher.


\begin{figure}[h]
\begin{lstlisting}
val adilfulara = 
    syn(V((e: Entity) => e.hasLabel("User") 
                && e.login == "adilfulara"))
val friend = 
    syn(E((e: Entity) => e.value() == "FRIEND"))

val person = 
    syn(V((e: Entity) => e.hasLabel("Person")) ^^)

val rated = 
    syn(E((e: Entity) => e.value() == "RATED") ^^)

val movie = 
    syn(V((e: Entity) => e.hasLabel("Movie")) ^^)

val query = 
    syn((adilfulara ~ friend ~ person ~ 
         rated ~ movie) &
    {case p ~ r ~ m => 
        (p.name, m.title, r.stars.asInstanceOf[Int],
         if (r.hasProperty("comment")) r.comment 
         else "")})

executeQuery(query, input)
  .filter({case (_, _, s, _) => s > 3})
\end{lstlisting}
\caption{Mutual Friend recommendations (Meerkat query)}
\label{fig:meerkat_movie_query}
\end{figure}

We show that our library is expressive enough to fromulate realistic queries. 
Also we demonstrate some cases of semantics actions usage.
Main difference from Cypher is that library provides only path querying mechanusms, so all additional logic such as
filtering, sorting or grouping must be implemented manually as a separated step.

Also, we detect that our library doesn't support incoming edges precessing which may be useful in some scenarios.