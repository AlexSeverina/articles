\section{Matrix-based multiple-source CFPQ algorithm}

 In this section we introduce two versions of multiple-source matrix-based CFPQ algorithm. This algorithm is a modification of Azimov's matrix-based algorithm for CFPQ and the idea is that we cut off those vertices from which we are not interested in paths.
 
 Let \mbox{$D = (V, E)$} be the input graph, \mbox{$G = (N, \Sigma, P, S)$} be the input grammar and $Src$ be the input set of vertices. For the multiple-source context-free path query evaluation, we must provide such a path from $R_A$ where the start node is from $Src$. In other words, for every \mbox{$n \in Src$} we want to find all node pairs \mbox{$(n,m)$} such that \mbox{$\exists n \pi m~(l(\pi) \in L(G_A))$}.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Multiple-source context-free path querying algorithm}
\label{lst:algo1}
\Function{MultiSrcCFPQ}{$D=(V,E), G=(N,\Sigma,P,S), Src$}
    \State{$T \gets \{T^A \mid  A \in N, T^A \gets \emptyset\}$}
    \Comment{Matrix in which every element is $\emptyset$}
    
    \State{$TSrc \gets \{TSrc^A \mid  A \in N \setminus S, TSrc^A \gets \emptyset\}$}
    \Comment{Matrix for input vertices in which every element is $\emptyset$}

    \ForAll{$ v \in Src$} \Comment{Input matrix initialization}
        \State{$TSrc^S_{v,v} \gets true$} 
    \EndFor

    \ForAll{$A \to x \in P$} \Comment{Simple rules initialization}
        \ForAll{$(v, x, to) \in E$}
            \State{$T^A_{v,to} \gets true$}
        \EndFor
    \EndFor

    \While{$T\ or\ TSrc\ is\ changing$} \Comment{Algorithm's body}
        \ForAll{$A \to B C \in P$}
            \State{$M \gets TSrc^A*T^B$}
            \State{$T^A \gets T^A + M*T^C$}
            \State{$TSrc^B \gets TSrc^B + TSrc^A$}
            \State{$TSrc^C \gets TSrc^C + $ \Call{getDst}{M}}
        \EndFor
    \EndWhile
    \State \Return T
\EndFunction

\\

\Function{getDst}{M}
    \State{$A \gets \emptyset$}
    \ForAll{$(v,to) \in V^2 \mid M_{v,to} = true$}
        \State{$A_{to,to} \gets true$}
    \EndFor
    \State \Return A
\EndFunction
\end{algorithmic}
\end{algorithm}

The operation of transitive closure calculation from Azimov's algorithm is supplemented with one more matrix multiplication which saves only vertices we are interested in.

It is useful to add data caching to improve the performance of processing large graphs. We provide one more version of algorithm which has memory optimization. It is noticed that every time we want to find all paths from the certain set of vertices, the first version of algorithm calculates everything from scratch. Since recalculating might take the significant amount of time, the second version is specified for such scenarios. This version stores all the vertices, the paths from which have already been calculated. 
\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Optimized multiple-source context-free path querying algorithm}
\label{lst:algo1}
\Function{MultiSrcCFPQSmart}{$index=(D, G, T, TSrc), Src$}
    \State{$TNewSrc \gets \{TNewSrc^A \mid  A \in N \setminus S, TNewSrc^A \gets \emptyset\}$}

    \ForAll{$v \in Src \mid index.TSrc_{v,v} = false$}
        \State{$TNewSrc^S_{v,v} \gets true$}
    \EndFor

    \While{$index.T\ or\ TNewSrc\ is\ changing$}
        \ForAll{$A \to B C \in P$}
            \State{$M \gets TNewSrc^A*index.T^B$}
            \State{$index.T^A \gets index.T^A + M*index.T^C$}

            \State{$TNewSrc^B \gets TNewSrc^B + TNewSrc^A \setminus index.TSrc^B$}
            \State{$TNewSrc^C \gets TNewSrc^C + $ \Call{getDst}{M}} $\setminus$ $index.TSrc^C$
        \EndFor
    \EndWhile
\EndFunction


\end{algorithmic}
\end{algorithm}

\subsection{Implementation Details}
 All of the above versions have been implemented$\footnote{GitHub repository with implemented algorithms: \url{https://github.com/JetBrains-Research/CFPQ_PyAlgo}, last accessed 28.08.2020}$ using GraphBLAS framework that allows you to represent graphs as matrices and work with them in terms of linear algebra. For convenience, all the code is written in Python using pygraphblas\footnote{GitHub repository of PyGraphBLAS library: \url{https://github.com/michelp/pygraphblas}}, which is Python wrapper around GraphBLAS API and based on SuiteSparse:GraphBLAS\footnote{GitHub repository of SuiteSparse:GraphBLAS library: \url{https://github.com/DrTimothyAldenDavis/SuiteSparse}}~\cite{SuiteSparse} --- the full implementation of GraphBLAS standart. This library is specialized for working with sparse matrices, which most often appear in real graphs.

\subsection{Algorithm Evaluation}

And comparison. With combinators, GLL (.NET version).

Evaluation setup.
Hardware basic description.

Graphs and queries from CFPQ\_Data\footnote{!!!}
Graphs and queries description: \#V, \#E, types of queries.

Tables.

Graphics (boxes). 1,2,4,8,16,32,50,100,500,1000,5000

Results.

Conclusion. 