\section{CFPQ Full-Stack Support}

In order to provide full-stack support of CFPQ it is necessatry to choose an appropriatr graph database.
It was shown by Arseniy Terekhov et al. in~\cite{10.1145/3398682.3399163} that matrix-based algorithm can be naturally integrated into RedisGraph graph database because both, the algorithm and the database, operates over matrix representation of graphs.
Moreover, RedisGraph supports Cypher as a query language and there is a proposal which describes Cypher extension which allows one to specify context-free constraints.
Thus we choose RedisGraph as a base for our solution.  


\subsection{Cypher Extending}
\label{subsec:cypher-extension}

The first what we should do is to extend Cypher parser to be able to express context-free constraints.
There is a description of the respective Cypher syntax extension\footnote{\label{cypher-proposal}Formal syntax specification: \url{https://github.com/thobe/openCypher/blob/rpq/cip/1.accepted/CIP2017-02-06-Path-Patterns.adoc\#11-syntax}. Access date: 19.07.2020.}, proposed by Tobias Lindaaker, but this syntax does not implement yet in Cypher parsers.

This extension introduces path patterns, which are powerful alternative to the original Cypher relationship patterns.
Path patterns allow one to express regular constrains over basic patterns such as relationship and node patterns.
Just like relationship patterns they can be specified in the \texttt{MATCH} clause between the node patterns.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Example of using a simple path pattern}
\label{lst:cypher-example-1}
\State MATCH (v)-/ [:a (:x) :b] | [:c (:y) :d] /->(to)
\State RETURN v, to
\end{algorithmic}
\end{algorithm}

An example of query in extended syntax with a simple path pattern is provided in listing~\ref{lst:cypher-example-1}.
In this example there are relationship patterns \lstinline{:a}, \lstinline{:b}, \lstinline{:c} \lstinline{:d} and node patterns \lstinline{(:x)}, \lstinline{(:y)}.
The square brackets are used for grouping parts of the pattern.
The $|$ symbol denotes alternative between corresponding paths and the blank denotes sequence of paths. So the result of executing the query on the labeled graph $D$ will be the following set of vertex pairs:

\begin{align*}
\{(v, to): \exists \pi = (v,r_1,u,r_2,to) \in \pi(D):& \\
\begin{sqcases}
    a \in \lambda_E(r_1), x \in \lambda_V(u), b \in \lambda_E(r_2)  \\
    c \in \lambda_E(r_1), y \in \lambda_V(u), d \in \lambda_E(r_2)
\end{sqcases}&\}
\end{align*}

Main feature which allows one to specify context-free constraints is a \textit{named path patterns}: one can specify a name for path pattern and after that use this name in other patterns, or in the same pattern.
Using this feature, structure of query is pretty similar to context-free grammar in the Extended Backus-Naur Form (EBNF)~\cite{!!!}.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Example of named path pattern}
\label{lst:cypher-example-2}
\State PATH PATTERN S = ()-/ [:a $\sim$S :b] | [:a :b] /->()
\State MATCH (v)-/ $\sim$S /->(to)
\State RETURN v, to
\end{algorithmic}
\end{algorithm}

An example of named path patterns is presented in listing~\ref{lst:cypher-example-2}.
Named patterns can be defined in the \texttt{PATH PATTERN} clause and referenced within any other path pattern.
In order to explain the semantics of the query, consider contest-free grammar $G=(N, \Sigma, P, S)$ with $N=\{S\}$, $\Sigma=\{a,b\}$ and $P=\{S \xrightarrow{} a b, S \xrightarrow{} aSb \}$.
\gsv{Then $L(G)=\{a^nb^n: n \in \mathbb{N}\}$ specifies restrictions on the path labels and query result on the graph $D$ will be the context free relation $R_{G, D}$}{What you want to say? In Russian.}. 

Thus this Cypher extension allows one express more complex queries including context-free path queries.
RedisGraph database supports subset of Cypher language and uses \texttt{libcypher-parser}\footnote{The \texttt{libcypher-parser} is an open-source parser library for Cypher query language. GitHub repository of the project: \url{https://github.com/cleishm/libcypher-parser}. Access date: 19.07.2020.} library to parse queries.
We extend this library by introducing new syntax proposed \footnoteref{cypher-proposal}. We implement\footnote{The modified libsypher-pareser library with support of syntax for path patterns: \url{https://github.com/YaccConstructor/libcypher-parser}. Access date: 19.07.2020.} full extension, not only part which is necessary for simple CFPQ. 

\subsection{RedisGraph Intro (TODO: move to introduction)}

Named path patterns described in~\autoref{subsec:cypher-extension} allows one to specify context-free constrains on the paths. In order to support the execution of these types of queries we need to extend backend of the RedisGraph database and integrate a suitable CFPQ algorithm into it. 

There are quite a few algorithms that solve CFPQ problem~\ref{!!!}, but their running time makes them unsuitable for practical use~\ref{Neo4J-fail}. Recent studies~\ref{NikitaMishin, simpleton} have shown that one can achieve high performance through the use of matrix-based algorithms. These studies were conducted to analyze the performance of the Rustam Azimov algorithm described in \autoref{subsec:rustam-algo} and have shown that it is acceptable for practical application.

Using the Rustam Azimov algorithm one can only find paths between all pairs of vertexes at once and in some cases it is quite wasteful. Queries to graph databases can be specified so that when they are executed, it is required to find paths from a given set of initial vertices. This set can be quite small due to the different filtering specified in the query. For example in the listing~\ref{lst:cypher-example-3} path pattern \colorbox{blue!10}{-/ $\sim$S /->} follows pattern \colorbox{blue!10}{(v)-[r]->(u)}. The WHERE clause specifies some arbitrary predicate \colorbox{blue!10}{p(v, r, u)} which also fixes a set of initial vertexes for a paths that must satisfy path pattern \colorbox{blue!10}{S}. Depending on this predicate, this set of vertexes can have different sizes and for proper practical use the running time of the CFPQ algorithm should be sensitive to this.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{...}
\label{lst:cypher-example-3}
\State PATH PATTERN S = ()-/ :A [$\sim$S | ()] :B /->()
\State MATCH (v)-[r]->(u)-/ $\sim$S /->(to)
\State WHERE p(v, r, u)
\State RETURN to
\end{algorithmic}
\end{algorithm}

The Multi-Source algorithm described in~\autoref{sec:multi-source-algo} is sensitive to the initial set of vertices and is therefore well suited for graph database query scenarios. In addition, it is based on matrix operations and works with graphs as sparse matrices, so it is suitable for integration in RedisGraph.

\subsection{RedisGraph extension}
This section describes the implementation of support for executing queries with the extended syntax in the RedisGraph. Throughout this section, we consider executing the example query from listing~\autoref{lst:cypher-example-3} for the graph $D_1$ from~\autoref{fig:example_input_graph}. $\mathcal{E}$ and $\mathcal{V}$ denotes boolean decompositions of adjacency and vertex label matrices of $D_1$ respectively. 

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Query with path patterns example}
\label{lst:cypher-example-3}
\State PATH PATTERN S = ()-/ [:c $\sim$S :d] | [:c (:y) :d] /->()
\State MATCH (v:x)-[:a | :c]->()-/ :b $\sim$S /->(to)
\State RETURN v, to
\end{algorithmic}
\end{algorithm}

\subsubsection{Execution plan building}
\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{execution-plan-building.png}
  \caption{Extension diagram for building a query execution plan}
  \label{fig:execution-plan-construction}
\end{figure}

In the RedisGraph the main part of processing a query is building its execution plan. Execution plan consists of operations that perform basic processing such as filtering, pattern matching, aggregation and result construction. The diagram of its construction is shown in~\autoref{fig:execution-plan-construction}. It can be divided into two parts ---\gsv{processing named and unnamed path patterns, which are described below}{Improve it!}.

Let`s consider the part that associated with unnamed path patterns. Unnamed path patterns relates to the pattern matching operations and is very similar to relationship patterns from the original Cypher. All pattern matching operations are derived from the MATCH clause that consists of relationship patterns and node patterns. In the example query there is a relationship pattern $r = $\lstinline{-[:a | c]->}, path pattern $p$ = \lstinline{-/ :b ~S /->} and node pattern $n = $\lstinline{(:x)}. In the first stage of processing, these patterns turn into an intermediate representation --- the \textit{query graph}. The nodes and edges of the query graph corresponds to node and relationship patterns. We extended query graph to be able to contain path patterns. Thus the query graph edges can be either relationship or path patterns, which are stored in a more convenient intermediate representation other than AST. The query graph for patterns $p, r$ and $n$ is shown in~\autoref{fig:query_graph}.

\begin{figure}[h]
    \centering        
    \begin{tikzpicture}[shorten >=0.5pt,auto]
       \node[state] (q_0)                        {$n$};
       \node[state] (q_1) [right=of q_0]         {};
       \node[state] (q_2) [right=of q_1]         {};
        \path[->]
        (q_0) edge  node {$r$} (q_1)
        (q_1) edge  node {$p$} (q_2);
    \end{tikzpicture}
    \caption{The example of input graph $\mathcal{G}$}
    \label{fig:query_graph}
\end{figure}

At the second stage, the query graph is translated into algebraic expressions over matrices. The abstract syntax of an algebraic expression is provided in~\autoref{fig:alg-expr}. Thus the algebraic expression is an expression with addition, multiplication and transposition operations whose operands are matrices. To support references to named paths patterns in algebraic expressions we added a matrix operand \textit{Ref(ref)} that stores a reference. In order to translate the query graph RedisGraph first linearizes it and then splits it into small paths. To support path patterns we extended the split processing so that each path pattern corresponds to exactly one path after query graph splitting. For example the query graph in~\autoref{fig:query_graph} is very simple and is divided into three patterns $n, r$ and $p$. After that, each path is translated into a single algebraic expression. We developed the semantics of path patterns in terms of algebraic expressions and implemented translation. For example, node pattern $n$ translates to $AlgExp(n) = \mathcal{V}^x$, relationship pattern $r$ to $AlgExp(r) = \mathcal{E}^a + \mathcal{E}^c$ and path pattern $p$ to $AlgExp(p) = \mathcal{E}^b * Ref(S)$.

% For example the query graph in .

\begin{figure}[H]
\caption{Algebraic expression abstract syntax}
\label{fig:alg-expr}
\begin{align*}
\begin{split}
AlgExpr= ~ &(AlgExpr + AlgExpr)~| \\
           &(AlgExpr * AlgExpr)~| \\
           &Transpose(AlgExpr)~| \\
           &Matrix~| \\
           &Ref(ref)        
\end{split}
\end{align*}
\end{figure}

After obtaining algebraic expressions they are used to construct execution plan operations. Each operation is derived from a single algebraic expression that is involved in the further execution of the corresponding operation. For example for the $AlgExp(r)$ and $AlgExp(n)$ will be created \textit{CondTraverse(AlgExp(r))} and \textit{LabelScan(AlgExp(n))} operations respectively which already existed in RedisGraph. For expressions that correspond to path patterns we created a new \textit{CFPQTraverse} operation. Thus algebraic expression of pattern $p$ will be stored in the new \textit{CFPQTraverse(AlgExp(p))} operation. During the query execution this operation performs path pattern matching and solves context-free path reachability problem if necessary. This completes the part of the query execution plan building which concerns unnamed path patterns.

Another processing that occurs during the execution plan construction and was supported by us is related to named path patterns. They are processed independently of the unnamed path patterns found in MATCH clause and don't produce execution plan operations. 

All named path patterns are collected from \lstinline{PATH PATTERN} clauses. In the example query there is a path pattern \textit{S = ()-/ [:c $\sim$S :d] | [:c (:y) :d] /->()}. Then this named path patterns translated into algebraic expressions and stored in the corresponding global context of the query --- \textit{path pattern context}. This storage provides mapping between the path pattern name and its algebraic expression and its relation and source matrices. Initially these matrices are empty and populated later in the execution stage. For the example query this storage will be as follows:
\begin{align*}
   \{ S  \xrightarrow{} \{ & expr \xrightarrow{} \mathcal{E}^c * Ref(S) * \mathcal{E}^d + \mathcal{E}^c * \mathcal{V}^y * \mathcal{E}^d, \\
                           & m_{rel} \xrightarrow{} \varnothing, \\
                           & m_{src} \xrightarrow{} \varnothing \} \}
\end{align*}

Thus after execution plan building we receive \textit{CFPQTraverse} operations that correspond to unnamed path patterns in MATCH clause and \textit{path pattern context} that stores all named path patterns from \lstinline{PATH PATTERN} clauses. Therefore we can proceed to the stage of execution plan evaluation.


\subsubsection{Execution plan evaluating}
\label{subsubsec:execution-plan-evaluating}

\begin{figure}[h!]
  \centering
  \includegraphics[width=\linewidth]{pictures/execution-plan-evaluation.png}
  \caption{CFPQTraverse and CondTraverse evaluation}
  \label{fig:execution-plan-evaluation}
\end{figure}

The remaining part of query processing is evaluation its execution plan. This section describes how the \lstinline{CFPQTraverse} operation is performed. For explanation, we use example graph $D_1$ from~\autoref{fig:example_input_graph} and execution plan operations $LabelScan(n)$, $CondTraverse(r)$ and $CfpqTraverse(p)$ that were obtained in the previous section for example query from listing~\autoref{lst:cypher-example-3}.

Let`s first consider the structure of the execution plan operations. Operations have parent-child relationships, so they are formed into a tree. For example, the part of execution plan that derived from example query is shown in~\autoref{fig:execution-plan-operations}. Each operation can consume a record from a child operation, process it and produce another one for the parent. Records contain information necessary for the parent operation, as well as everything to restore the response, such as identifiers of accumulated vertices and edges.

\begin{figure}[h]
    \centering        
    \begin{tikzpicture}[shorten >=0.5pt,auto]
       \node (q_0) [draw,thick,minimum width=2cm,minimum height=0.5cm]                        {LabelScan(AlgExp(n))};
       \node (q_1) [draw,thick,minimum width=2cm,minimum height=0.5cm, above=of q_0]                        {CondTraverse(AlgExp(r))};
        \node (q_2) [draw,thick,minimum width=2cm,minimum height=0.5cm, right=of q_1]                        {CFPQTraverse(AlgExp(p))};
        \path[->]
        (q_0) edge[bend left, left]  node {produce} (q_1)
        (q_1) edge[bend left, right] node {consume} (q_0)
        (q_1) edge[bend left, above] node {produce} (q_2)
        (q_2) edge[bend left, above] node {consume} (q_1);
    \end{tikzpicture}
    \caption{Example of part of the execution plan}
    \label{fig:execution-plan-operations}
\end{figure}

The \lstinline{CFPQTraverse} operation is based on \lstinline{CondTraverse} operation that already exists in the RedisGraph and performs a patterns matching. The activity diagram of this operations is shown in~\autoref{fig:execution-plan-evaluation} and described below. Actions that corresponds to \lstinline{CondTraverse} operation are highlighted in green, actions of the \lstinline{CFPQTraverse} operation that extend \lstinline{CondTraverse} are highlighted in blue.

The \lstinline{CondTraverse} works as follows. At first it consumes several records from the child operation and accumulates them in the buffer. Here each record corresponds to the path that built by the child operation. For simplicity we can presume that each record is the destination vertex of the path. For example for the graph $D_1$ the \textit{CondTraverse} from~\autoref{fig:execution-plan-operations} make \textit{LabelScan} operation to produce vertices with the label $X$ and then store the resulting set of vertices $\{1, 3\}$ in the buffer. The task of the \lstinline{CondTraverse} is to continue the path from this vertices in such way that the resulting path satisfies pattern corresponding to this operation. To do this \lstinline{CondTraverse} uses the algebraic expression obtained in the previous step. The resulting matrix of this expression represents all pairs of vertices between which there is a path satisfying the pattern. In order to find paths that start from given sources vertices \lstinline{CondTraverse} uses a filter matrix. This matrix is constructed from the destination vertices retrieved from the record buffer and resembles matrix from boolean decomposition of label vertex matrix. For example filter matrix of set $\{1, 3\}$ is $ r_{f}=\{(1, 1), (3, 3)\}$. Then algebraic expression $AlgExp(r)$ is multiplied to the left by $r_f$ and we get algebraic expression $r_f * AlgExp(r) = r_f * (\mathcal{E}^a + \mathcal{E}^c)$. Then this expression is optimized, including all distributivity rules applying. For example, for expression $r_f * (\mathcal{E}^a + \mathcal{E}^r)$ after all optimizations we get expression $r_f * \mathcal{E}^a + r_f * \mathcal{E}^r$. Only after that this expression is evaluated and we get the matrix $\{(1, 2), (3, 5)\}$. This matrix exactly corresponds to all paths of length one where the source vertex is labelled by $x$ and the edge is labeled by $a$ or $c$. Then this paths are passed to the parent operation, in our case to $CFPQTraverse$, by producing new records.

The \lstinline{CFPQTraverse} operation is arranged in the same way as \lstinline{CondTraverse} but performs some additional work. Since each \lstinline{CFPQTraverse} corresponds to path pattern, its algebraic expression may contain references to named path patterns. Therefore all named path patterns that the algebraic expression depends on must be processed. For this they are stored in the \textit{set of operation dependencies} during its initialization. In this case, dependencies are extracted recursively, so that references inside named path patterns are also extracted. For example, path pattern $p$ depends only on named path pattern $S$, so the dependency set of $CFPQTraverse(p)$ operation is $\{S\}$.

The \lstinline{CFPQTraverse} execution stage starts the same way as \lstinline{CondTraverse} one. First filter matrix is constructed from record buffer. For example, \lstinline{CFPQTraverse(p)} consumes several records from \lstinline{CondTraverse(r)}, extracts from them the set of destination vertices $\{2, 5\}$ and builds filter matrix $p_f = \{(2, 2), (5, 5)\}$. Then this matrix is embedded in the algebraic expression of operation in the same way as in \lstinline{CondTraverse} and we get new algebraic expression $p_f * AlgExp(p) = p_f * \mathcal{E}^b * Ref(S)$. After that for each reference in the algebraic expression we need to determinate the set of source vertices. This can be done during algebraic expression evaluation which we extended for this purpose.

\begin{algorithm}
\begin{algorithmic}[1]
\caption{Extension of multiplication evaluation}
\label{alg:multiplication-extension}
\Function{EvalMul}{$e_l:AlgExp,~e_r:AlgExp,~context$}
\State $M_l =$ \Call{Eval}{$e_l, context$}
\If {$r~is~Ref(ref)$}
    \State $context[ref].src \gets context[ref].src~+$ \Call{getDst}{$M_l$}
\EndIf
\State $...$ \Comment{Remaining original part of the EvalMul}
\EndFunction
\end{algorithmic}
\end{algorithm}

Specifically, we extended the multiplication operation as shown in the listing~\autoref{alg:multiplication-extension}. At first the left operand $e_l$ of multiplication is evaluated by \textbf{Eval} function to matrix $M_l$ in line $2$. Then if the right operand of the multiplication is a reference, we need to populate source matrix of corresponding named path pattern. In this case matrix $M_l$ specifies some set of destination vertices $\{j \mid M_l[i,j] = 1\}$ from which the path should continue. So we add this set to source matrix of named path pattern. For example, lets consider evaluation of $p_f * AlgExp(p) = p_f * \mathcal{E}^b * Ref(S)$. First, $p_f * \mathcal{E}^b$ is evaluated into matrix $M_l = \{(2, 3), (2, 6)\}$. It corresponds to edges starting from vertex $2$ and labeled by $b$. Then destination vertices $\{3, 6\}$ of $M_l$ are extracted and added to source matrix of named path pattern $S$. So after this evaluation the path pattern context becomes the following:
\begin{align*}\label{example-path-pattern-context}
   \{ S  \xrightarrow{} \{ & expr \xrightarrow{} \mathcal{E}^c * Ref(S) * \mathcal{E}^d + \mathcal{E}^c * \mathcal{V}^y * \mathcal{E}^d, \\
                           & m_{rel} \xrightarrow{} \varnothing, \\
                           & m_{src} \xrightarrow{} \{(3, 3), (6, 6)\} \} \}
\end{align*}
After that we have everything to run multiple-source CFPQ algorithm provided in listing~\autoref{alg:redisgraph-cfpq} to resolve all operation dependencies. This algorithm is slightly different from \textit{MultiSrcCFPQ} algorithm described in listing~\autoref{alg:algo1} and is a generalization of it. It receives the set of operation dependencies \textit{deps} and path pattern context $context$. The algorithm's task is to populate relation and source matrices of all named path pattern from $deps$. To do this on each iteration for all pattern from $deps$ this matrices are updated. Namely, first of all the algebraic expression is constructed from source matrix and algebraic expression of current pattern and then optimized in line~\textbf{5}. This is followed by substitution references in line~\textbf{6}, after which all references in the expression are replaced by relation matrices from $context$. At the end of iteration the resulting expression is evaluated and stored in relation matrix in line~\textbf{7}. These iterations continue as long as the context changes, i.e. at least one of the pattern matrices $m_{rel}$ or $m_{src}$ changes during iteration.

\begin{algorithm}
\begin{algorithmic}[1]
\caption{Multiple-source context-free path querying algorithm in terms of algebraic expressions}
\label{alg:redisgraph-cfpq}
\Function{MultiSrcCFPQAlgExp}{$deps,\ context$}
\While {$context~is~changing$}
    \ForAll{$p~\in deps$}
        \State $src \gets context[p].m_{src}$
        \State $expr \gets$ \Call{Optimize}{$src * context[p].expr$}
        \State \Call{FetchReferences}{$expr$, $ctx$}
        \State $context[p].m_{rel} \gets$ \Call{Eval}{$expr$}
    \EndFor
\EndWhile

\EndFunction
\end{algorithmic}
\end{algorithm}

After running this algorithm on the dependency set of \textit{CFPQTraverse} operation and path pattern context we receive relation matrices of all named path pattern, on which operation depends. For example, after running it on dependency set $\{S\}$, relation and source matrices of pattern $S$ will be as follows:

\begin{align*}
m_{rel} &= \{(3, 5), (3, 6), (4, 5), (4, 6), (5, 5), (5, 6)\} \\
m_{src} &= \{(3, 3), (4, 4), (5, 5)\}
\end{align*}

After that all references in the algebraic expression $p_f *$ \textit{Alg\-Exp(p)} are replaced with the relation matrices and we get algebraic expression $p_f * \mathcal{E}^b * context[S].m_{rel}$. Then this expression is evaluated to matrix $\{(3, 5), (3, 6)\}$ that corresponds to paths from 3rd vertex that satisfy the constraints specified by pattern $S$. Finally as well as \lstinline{CondTraverse}, \lstinline{CFPQTraverse} extracts desired paths from this resulting matrix and passes them to parent operation.

Therefore if we put together the results of all operations of execution plan the query from listing~\ref{lst:cypher-example-3} on graph $D_1$ return the set of vertices $\{(1, 5), (1, 6)\}$.

\subsection{Evaluation}

In order to demonstrate applicability of the provided extension for RedisGraph we evaluate the proposed solution on the subset of cases provided in the section~\ref{sect:py_algo_evaluation}.

For RedisGraph evaluation, we used a PC with Ubuntu 18.04 installed.
It has Intel Core i7-6700 CPU, 3.4GHz, and DDR4 64Gb RAM. 
RedisGraph with our extensions is installed form our GitHub repository\footnote{Sources of RedisGraph database with full-stack CFPQ support:\url{https://github.com/YaccConstructor/RedisGraph/tree/path_patterns_dev}. Access data: 19.07.2020.}. 

\subsubsection{Data preparing}

We use the same graphs which are presented in table~\ref{tbl:graphs_for_cfpq} to evaluate RedisGraph-based solution.

Graphs are loaded into RedisGraph database such that each vertex has a field \verb|id| which value is unique and is in $[0 \ldots |V|-1]$, where $|V|$ is a number of vertices in the graph to load.
This allows us to generate queries for specific chunk size using templates.
The template for the $g_1$ query is provided in listing~\ref{lst:query_pattern_g1}.
Here \texttt{\{id\_from\}} and \texttt{\{id\_to\}} are placeholders for lower and upper bounds for \verb|id|. The example of the exact query for chunk of size 16 is presented in listing~\ref{lst:query_g1}.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Cypher query pattern for $g_1$}
\label{lst:query_pattern_g1}
\State PATH PATTERN S =  \par
 \hskip\algorithmicindent ()-/ [<:SubClassOf [$\sim$S | ()] :SubClassOf] \par
 \hskip\algorithmicindent | [<:Type [$\sim$S | ()] :Type] /->()
\State MATCH (src)-/ $\sim$S /->() 
\State WHERE \{id\_from\} <= src.id and src.id <= \{id\_to\}
\State RETURN count(*)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Query $g_1$ in Cypher using the template from listing~\ref{lst:query_pattern_g1}}
\label{lst:query_g1}
\State PATH PATTERN S =  \par
 \hskip\algorithmicindent ()-/ [<:SubClassOf [$\sim$S | ()] :SubClassOf] \par
 \hskip\algorithmicindent | [<:Type [$\sim$S | ()] :Type] /->()
\State MATCH (src)-/ $\sim$S /->() 
\State WHERE 15 <= src.id and src.id <= 31
\State RETURN count(*)
\end{algorithmic}
\end{algorithm}

Queries generator for all three queries ($g_1$, $g_2$, and $geo$) was implemented and used to create queries for all chunks which are used in the previous experiment. 


\subsubsection{Evaluation results}

For evaluation we select $geo$ query for \textit{geospecies} graph as one of the hardest queries, and $g_1$ query for other graphs.
Time and memory consumption are measured for each chunk processing.
Results of time measurement are presented in figures~\ref{fig:redis_core_all}--\ref{fig:redis_gohierarchy_all}.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/core.pdf}
\caption{RedisGraph performance of \textit{core} graph}
\label{fig:redis_core_all}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/pathways.pdf}
\caption{RedisGraph performance of \textit{pathways} graph}
\label{fig:redis_pathways_all}
\end{figure}

\begin{figure}[h]core
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/enzyme.pdf}
\caption{RedisGraph performance of \textit{enzyme} graph}
\label{fig:redis_enzyme_all}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/go.pdf}
\caption{RedisGraph performance of \textit{go} graph}
\label{fig:redis_go_all}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/geospecies.pdf}
\caption{RedisGraph performance of \textit{geospecies} graph}
\label{fig:redis_geospecies_all}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/eclass_514en.pdf}
\caption{RedisGraph performance of \textit{eclass\_514en} graph}
\label{fig:redis_eclass_all}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/gohierarchy.pdf}
\caption{RedisGraph performance of \textit{gohierarchy} graph}
\label{fig:redis_gohierarchy_all}
\end{figure}

We can see, that results is comparable with one given in section~\ref{sect:py_algo_evaluation}. 
Processing time for all chunks, except chunk of size 10 000 for \textit{geospecies} graph (fig.~\ref{fig:redis_geospecies_all}) is less then 1 second.
Moreover, for chunks of size 16 processing median time is less then 0.1 second, except \textit{geospecies} graph.

Memory consumption is presented in !!!
La-la-la!!!!

Additionally, we measure the time required to process full graph (to solve all-pairs reachability problem) by chunks of size  !!!.
Also, we compare our solution with results of Arseniy Terekhov et al. from~\cite{10.1145/3398682.3399163} which were measured for RedisGraph deployed on the similar hardware and for the same graphs and queries. In~\cite{10.1145/3398682.3399163} Azimov's algorithm was naively integrated with RedisGraph storage without support of query language and other mechanisms such as lazy query evaluation.
Results are provide in the table~\ref{tbl:redis_full_graph_processing}.

\begin{table}
{
\caption{Full graph processing time by RadisGraph with chunks of size !!!, time is measured in seconds (\textbf{Chunks} --- the proposed solution, \textbf{Full} --- results from~\cite{10.1145/3398682.3399163})}
\label{tbl:redis_full_graph_processing}
\small
\rowcolors{2}{black!2}{black!10}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Graph                       & \#V       & \#E      & Query  & Chunks  &  Full  \\
\hline
\hline
core                        & 1323     & 3636       & $g_1$  & 0.027  &  0.004 \\ 
pathways                    & 6238     & 18 598     & $g_1$  & 0.028  &  0.011 \\ 
gohierarchy                 & 45 007   & 980 218    & $g_1$  & 0.205  &  0.091 \\ 
enzyme                      & 48 815   & 117 851    & $g_1$  & 0.058  &  0.018 \\ 
eclass\_514en               & 239 111  & 523 727    & $g_1$  & 0.198  &  0.067 \\ 
geospecies                  & 450 609  & 2 311 461  & $geo$  & 27.824 &  7.146 \\
go                          & 582 929  & 1 758 432  & $g_1$  & 0.711  &  0.604 \\ 
\hline
\end{tabular}
}
\end{table}

We can see, that chunk-by-chunk processing is 2--7 times slower, but it is still require reasonable time.
For example, it requires more than 200 times less time than solution of Jochem Kuijpers et al.~\cite{Kuijpers:2019:ESC:3335783.3335791} which is based on Neo4j and requires more than 6000 seconds.
Moreover, while solution from~\cite{10.1145/3398682.3399163} requires huge amount of memory (more than 16Gb for \textit{geospecies} graph and $geo$ query), our solution requires only !!! in the same scenario.
Thus it is more suitable for general-purpose graph databases.

Finally we can conclude that provided 