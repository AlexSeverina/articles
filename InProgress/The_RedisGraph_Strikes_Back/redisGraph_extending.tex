\section{CFPQ Full-Stack Support}

In order to provide full-stack support of CFPQ it is necessatry to choose an appropriate graph database.
It was shown by Arseniy Terekhov et al. in~\cite{10.1145/3398682.3399163} that matrix-based algorithm can be naturally integrated into RedisGraph graph database because both, the algorithm and the database, operates over matrix representation of graphs.
Moreover, RedisGraph supports Cypher as a query language and there is a proposal which describes Cypher extension which allows one to specify context-free constraints.
Thus we choose RedisGraph as a base for our solution.  


\subsection{Cypher Extending}
\label{subsec:cypher-extension}

The first what we should do is to extend Cypher parser to be able to express context-free constraints.
There is a description of the respective Cypher syntax extension\footnote{\label{cypher-proposal}Formal syntax specification: \url{https://github.com/thobe/openCypher/blob/rpq/cip/1.accepted/CIP2017-02-06-Path-Patterns.adoc\#11-syntax}. Access date: 19.07.2020.}, proposed by Tobias Lindaaker, but this syntax does not implement yet in Cypher parsers.

This extension introduces path patterns, which are powerful alternative to the original Cypher relationship patterns.
Path patterns allow one to express regular constrains over basic patterns such as relationship and node patterns.
Like relationship patterns, they can be specified in the \texttt{MATCH} clause.

Main feature which allows one to specify context-free constraints is a \textit{named path patterns}: one can specify a name for path pattern and after that use this name in other patterns, or in the same pattern.
Named patterns can be defined in the \texttt{PATH PATTERN} clause.
Using this feature, structure of query is pretty similar to context-free grammar in the Extended Backus-Naur Form (EBNF)~\cite{EBNF_ISO}.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Query based on example grammar $G_1$ (eq.~\ref{eqn:g1_example}) in Cypher with path patterns}
\label{lst:cypher_example}
\State PATH PATTERN S = ()-/ [:c $\sim$S :d] | [:c (:y) :d] /->()
\State MATCH (v:x)-[:a | :c]->()-/ :b $\sim$S /->(to)
\State RETURN v, to
\end{algorithmic}
\end{algorithm}


The example of query which uses named path patters is presented in listing~\ref{lst:cypher_example}. 
This query is based on context-free grammar $G_1$ (eq.~\ref{eqn:g1_example}). 
Namely, path patter with name \texttt{S} specifies exactly the same constraint that specified by the grammar $G_1$. 
The \texttt{MATCH} clause uses pattern \texttt{S} in complex constraint which says that path of interest should starts in the vertex with label \texttt{x}, than in should goes throw edge with label \texttt{a} or \texttt{c}, and the end of path is a sequence of edges which starts from \texttt{b} and tail of this sequence matches with \texttt{S}.  

For the example graph $D_1$ this query returns the next pairs of vertices \texttt{(v, to)} (as specified in \texttt{RETURN} clause): !!!!

Thus this Cypher extension allows one express more complex queries including context-free path queries.
RedisGraph database supports subset of Cypher language and uses \texttt{libcypher-parser}\footnote{The \texttt{libcypher-parser} is an open-source parser library for Cypher query language. GitHub repository of the project: \url{https://github.com/cleishm/libcypher-parser}. Access date: 19.07.2020.} library to parse queries.
We extend this library by introducing new syntax proposed.
Note that we implement\footnote{The modified libsypher-pareser library with support of syntax for path patterns: \url{https://github.com/YaccConstructor/libcypher-parser}. Access date: 19.07.2020.} full extension, not only part which is necessary for simple CFPQ. 

\subsection{RedisGraph Extending}

This section describes the implementation of support for executing queries with the extended syntax in the RedisGraph. Throughout this section, we consider executing the example query from listing~\autoref{lst:cypher-example-3} for the graph $D_1$ from~\autoref{fig:example_input_graph}. $\mathcal{E}$ and $\mathcal{V}$ denotes boolean decompositions of adjacency and vertex label matrices of $D_1$ respectively. 

In the RedisGraph the main part of processing a query is building its execution plan. Execution plan consists of operations that perform basic processing such as filtering, pattern matching, aggregation and result construction. The diagram of its construction is shown in~\autoref{fig:execution-plan-construction}. It can be divided into two parts ---\gsv{processing named and unnamed path patterns, which are described below}{Improve it!}.

 In the first stage of processing, these patterns turn into an intermediate representation --- the \textit{query graph}. The nodes and edges of the query graph corresponds to node and relationship patterns. We extended query graph to be able to contain path patterns. Thus the query graph edges can be either relationship or path patterns, which are stored in a more convenient intermediate representation other than AST.


At the second stage, the query graph is translated into algebraic expressions over matrices. The abstract syntax of an algebraic expression is provided in~\autoref{fig:alg-expr}. Thus the algebraic expression is an expression with addition, multiplication and transposition operations whose operands are matrices. To support references to named paths patterns in algebraic expressions we added a matrix operand \textit{Ref(ref)} that stores a reference. 

% For example the query graph in .

\begin{figure}[H]
\caption{Algebraic expression abstract syntax}
\label{fig:alg-expr}
\begin{align*}
\begin{split}
AlgExpr= ~ &(AlgExpr + AlgExpr)~| \\
           &(AlgExpr * AlgExpr)~| \\
           &Transpose(AlgExpr)~| \\
           &Matrix~| \\
           &Ref(ref)        
\end{split}
\end{align*}
\end{figure}

After obtaining algebraic expressions they are used to construct execution plan operations. Each operation is derived from a single algebraic expression that is involved in the further execution of the corresponding operation. For example for the $AlgExp(r)$ and $AlgExp(n)$ will be created \textit{CondTraverse(AlgExp(r))} and \textit{LabelScan(AlgExp(n))} operations respectively which already existed in RedisGraph. For expressions that correspond to path patterns we created a new \textit{CFPQTraverse} operation. Thus algebraic expression of pattern $p$ will be stored in the new \textit{CFPQTraverse(AlgExp(p))} operation. During the query execution this operation performs path pattern matching and solves context-free path reachability problem if necessary. This completes the part of the query execution plan building which concerns unnamed path patterns.


\subsubsection{Execution plan evaluating}
\label{subsubsec:execution-plan-evaluating}

\begin{figure}[h!]
  \centering
  \includegraphics[width=\linewidth]{pictures/execution-plan-evaluation.png}
  \caption{CFPQTraverse and CondTraverse evaluation}
  \label{fig:execution-plan-evaluation}
\end{figure}

The remaining part of query processing is evaluation its execution plan. This section describes how the \lstinline{CFPQTraverse} operation is performed. For explanation, we use example graph $D_1$ from~\autoref{fig:example_input_graph} and execution plan operations $LabelScan(n)$, $CondTraverse(r)$ and $CfpqTraverse(p)$ that were obtained in the previous section for example query from listing~\autoref{lst:cypher-example-3}.

Let`s first consider the structure of the execution plan operations. Operations have parent-child relationships, so they are formed into a tree. For example, the part of execution plan that derived from example query is shown in~\autoref{fig:execution-plan-operations}. Each operation can consume a record from a child operation, process it and produce another one for the parent. Records contain information necessary for the parent operation, as well as everything to restore the response, such as identifiers of accumulated vertices and edges.

\begin{figure}[h]
    \centering        
    \begin{tikzpicture}[shorten >=0.5pt,auto]
       \node (q_0) [draw,thick,minimum width=2cm,minimum height=0.5cm]                        {LabelScan(AlgExp(n))};
       \node (q_1) [draw,thick,minimum width=2cm,minimum height=0.5cm, above=of q_0]                        {CondTraverse(AlgExp(r))};
        \node (q_2) [draw,thick,minimum width=2cm,minimum height=0.5cm, right=of q_1]                        {CFPQTraverse(AlgExp(p))};
        \path[->]
        (q_0) edge[bend left, left]  node {produce} (q_1)
        (q_1) edge[bend left, right] node {consume} (q_0)
        (q_1) edge[bend left, above] node {produce} (q_2)
        (q_2) edge[bend left, above] node {consume} (q_1);
    \end{tikzpicture}
    \caption{Example of part of the execution plan}
    \label{fig:execution-plan-operations}
\end{figure}


After that we have everything to run multiple-source CFPQ algorithm provided in listing~\autoref{alg:redisgraph-cfpq} to resolve all operation dependencies. This algorithm is slightly different from \textit{MultiSrcCFPQ} algorithm described in listing~\autoref{alg:algo1} and is a generalization of it. It receives the set of operation dependencies \textit{deps} and path pattern context $context$. The algorithm's task is to populate relation and source matrices of all named path pattern from $deps$. To do this on each iteration for all pattern from $deps$ this matrices are updated. Namely, first of all the algebraic expression is constructed from source matrix and algebraic expression of current pattern and then optimized in line~\textbf{5}. This is followed by substitution references in line~\textbf{6}, after which all references in the expression are replaced by relation matrices from $context$. At the end of iteration the resulting expression is evaluated and stored in relation matrix in line~\textbf{7}. These iterations continue as long as the context changes, i.e. at least one of the pattern matrices $m_{rel}$ or $m_{src}$ changes during iteration.

\begin{algorithm}
\begin{algorithmic}[1]
\caption{Multiple-source context-free path querying algorithm in terms of algebraic expressions}
\label{alg:redisgraph-cfpq}
\Function{MultiSrcCFPQAlgExp}{$deps,\ context$}
\While {$context~is~changing$}
    \ForAll{$p~\in deps$}
        \State $src \gets context[p].m_{src}$
        \State $expr \gets$ \Call{Optimize}{$src * context[p].expr$}
        \State \Call{FetchReferences}{$expr$, $ctx$}
        \State $context[p].m_{rel} \gets$ \Call{Eval}{$expr$}
    \EndFor
\EndWhile

\EndFunction
\end{algorithmic}
\end{algorithm}

After running this algorithm on the dependency set of \textit{CFPQTraverse} operation and path pattern context we receive relation matrices of all named path pattern, on which operation depends. For example, after running it on dependency set $\{S\}$, relation and source matrices of pattern $S$ will be as follows:

\begin{align*}
m_{rel} &= \{(3, 5), (3, 6), (4, 5), (4, 6), (5, 5), (5, 6)\} \\
m_{src} &= \{(3, 3), (4, 4), (5, 5)\}
\end{align*}

After that all references in the algebraic expression $p_f *$ \textit{Alg\-Exp(p)} are replaced with the relation matrices and we get algebraic expression $p_f * \mathcal{E}^b * context[S].m_{rel}$. Then this expression is evaluated to matrix $\{(3, 5), (3, 6)\}$ that corresponds to paths from 3rd vertex that satisfy the constraints specified by pattern $S$. Finally as well as \lstinline{CondTraverse}, \lstinline{CFPQTraverse} extracts desired paths from this resulting matrix and passes them to parent operation.

Therefore if we put together the results of all operations of execution plan the query from listing~\ref{lst:cypher-example-3} on graph $D_1$ return the set of vertices $\{(1, 5), (1, 6)\}$.

\subsection{Evaluation}

In order to demonstrate applicability of the provided extension for RedisGraph we evaluate the proposed solution on the subset of cases provided in the section~\ref{sect:py_algo_evaluation}.

For RedisGraph evaluation, we used a PC with Ubuntu 18.04 installed.
It has Intel Core i7-6700 CPU, 3.4GHz, and DDR4 64Gb RAM. 
RedisGraph with our extensions is installed form our GitHub repository\footnote{Sources of RedisGraph database with full-stack CFPQ support:\url{https://github.com/YaccConstructor/RedisGraph/tree/path_patterns_dev}. Access data: 19.07.2020.}. 

\subsubsection{Data preparing}

We use the same graphs which are presented in table~\ref{tbl:graphs_for_cfpq} to evaluate RedisGraph-based solution.

Graphs are loaded into RedisGraph database such that each vertex has a field \verb|id| which value is unique and is in $[0 \ldots |V|-1]$, where $|V|$ is a number of vertices in the graph to load.
This allows us to generate queries for specific chunk size using templates.
The template for the $g_1$ query is provided in listing~\ref{lst:query_pattern_g1}.
Here \texttt{\{id\_from\}} and \texttt{\{id\_to\}} are placeholders for lower and upper bounds for \verb|id|. The example of the exact query for chunk of size 16 is presented in listing~\ref{lst:query_g1}.

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Cypher query pattern for $g_1$}
\label{lst:query_pattern_g1}
\State PATH PATTERN S =  \par
 \hskip\algorithmicindent ()-/ [<:SubClassOf [$\sim$S | ()] :SubClassOf] \par
 \hskip\algorithmicindent | [<:Type [$\sim$S | ()] :Type] /->()
\State MATCH (src)-/ $\sim$S /->() 
\State WHERE \{id\_from\} <= src.id and src.id <= \{id\_to\}
\State RETURN count(*)
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\floatname{algorithm}{Listing}
\begin{algorithmic}[1]
\caption{Query $g_1$ in Cypher using the template from listing~\ref{lst:query_pattern_g1}}
\label{lst:query_g1}
\State PATH PATTERN S =  \par
 \hskip\algorithmicindent ()-/ [<:SubClassOf [$\sim$S | ()] :SubClassOf] \par
 \hskip\algorithmicindent | [<:Type [$\sim$S | ()] :Type] /->()
\State MATCH (src)-/ $\sim$S /->() 
\State WHERE 15 <= src.id and src.id <= 31
\State RETURN count(*)
\end{algorithmic}
\end{algorithm}

Queries generator for all three queries ($g_1$, $g_2$, and $geo$) was implemented and used to create queries for all chunks which are used in the previous experiment. 


\subsubsection{Evaluation results}

For evaluation we select $geo$ query for \textit{geospecies} graph as one of the hardest queries, and $g_1$ query for other graphs.
Time and memory consumption are measured for each chunk processing.
Results of time measurement are presented in figures~\ref{fig:redis_core_all}--\ref{fig:redis_gohierarchy_all}.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/core.pdf}
\caption{RedisGraph performance of \textit{core} graph}
\label{fig:redis_core_all}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/pathways.pdf}
\caption{RedisGraph performance of \textit{pathways} graph}
\label{fig:redis_pathways_all}
\end{figure}

\begin{figure}[h]core
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/enzyme.pdf}
\caption{RedisGraph performance of \textit{enzyme} graph}
\label{fig:redis_enzyme_all}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/go.pdf}
\caption{RedisGraph performance of \textit{go} graph}
\label{fig:redis_go_all}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/geospecies.pdf}
\caption{RedisGraph performance of \textit{geospecies} graph}
\label{fig:redis_geospecies_all}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/eclass_514en.pdf}
\caption{RedisGraph performance of \textit{eclass\_514en} graph}
\label{fig:redis_eclass_all}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{data/raw_redis/gohierarchy.pdf}
\caption{RedisGraph performance of \textit{gohierarchy} graph}
\label{fig:redis_gohierarchy_all}
\end{figure}

We can see, that results is comparable with one given in section~\ref{sect:py_algo_evaluation}. 
Processing time for all chunks, except chunk of size 10 000 for \textit{geospecies} graph (fig.~\ref{fig:redis_geospecies_all}) is less then 1 second.
Moreover, for chunks of size 16 processing median time is less then 0.1 second, except \textit{geospecies} graph.

Memory consumption is presented in !!!
La-la-la!!!!

Additionally, we measure the time required to process full graph (to solve all-pairs reachability problem) by chunks of size  !!!.
Also, we compare our solution with results of Arseniy Terekhov et al. from~\cite{10.1145/3398682.3399163} which were measured for RedisGraph deployed on the similar hardware and for the same graphs and queries. In~\cite{10.1145/3398682.3399163} Azimov's algorithm was naively integrated with RedisGraph storage without support of query language and other mechanisms such as lazy query evaluation.
Results are provide in the table~\ref{tbl:redis_full_graph_processing}.

\begin{table}
{
\caption{Full graph processing time by RadisGraph with chunks of size !!!, time is measured in seconds (\textbf{Chunks} --- the proposed solution, \textbf{Full} --- results from~\cite{10.1145/3398682.3399163})}
\label{tbl:redis_full_graph_processing}
\small
\rowcolors{2}{black!2}{black!10}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Graph                       & \#V       & \#E      & Query  & Chunks  &  Full  \\
\hline
\hline
core                        & 1323     & 3636       & $g_1$  & 0.027  &  0.004 \\ 
pathways                    & 6238     & 18 598     & $g_1$  & 0.028  &  0.011 \\ 
gohierarchy                 & 45 007   & 980 218    & $g_1$  & 0.205  &  0.091 \\ 
enzyme                      & 48 815   & 117 851    & $g_1$  & 0.058  &  0.018 \\ 
eclass\_514en               & 239 111  & 523 727    & $g_1$  & 0.198  &  0.067 \\ 
geospecies                  & 450 609  & 2 311 461  & $geo$  & 27.824 &  7.146 \\
go                          & 582 929  & 1 758 432  & $g_1$  & 0.711  &  0.604 \\ 
\hline
\end{tabular}
}
\end{table}

We can see, that chunk-by-chunk processing is 2--7 times slower, but it is still require reasonable time.
For example, it requires more than 200 times less time than solution of Jochem Kuijpers et al.~\cite{Kuijpers:2019:ESC:3335783.3335791} which is based on Neo4j and requires more than 6000 seconds.
Moreover, while solution from~\cite{10.1145/3398682.3399163} requires huge amount of memory (more than 16Gb for \textit{geospecies} graph and $geo$ query), our solution requires only !!! in the same scenario.
Thus it is more suitable for general-purpose graph databases.

Finally we can conclude that provided 