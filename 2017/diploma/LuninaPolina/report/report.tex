% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
\documentclass[14pt]{matmex-diploma}
%\documentclass[14pt]{matmex-diploma-custom}
\usepackage{listings}

\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Математическое обеспечение и администрирование информационных систем},
    title              = {Поддержка кортежей и структур в библиотеке Brahma.FSharp},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {coursework},
    position           = {студента},
    group              = 243,
    author             = {Лунина Полина Сергеевна},
    supervisorPosition = {к.\,ф.-м.\,н., ст. преп.},
    supervisor         = {Григорьев С.\,В.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
В программировании часто встречаются задачи, позволяющие получить значительный выигрыш в производительности при использовании массово-параллельных архитектур. Одной из самых распространенных является GPGPU — техника использования GPU для общих вычислений, обычно выполняемых CPU. Существуют различные реализации этой техники, основанные на разных языках программирования и предназначенные для выполнения на разных процессорах, например, OpenCL или CUDA. OpenCL (Open Computing Language)~\cite{opencl} — фреймворк для написания программ, связанных с параллельными вычислениями на различных графических и центральных процессорах. OpenCL относится к низкоуровневым языкам, и поэтому он не очень удобен при непосредственном использовании.

Существуют инструменты, позволяющие использовать возможности OpenCL с помощью высокоуровневых языков программирования, например, PyOpenCL, FSCL, JavaCL и другие. Одним из таких инструментов является написанная на языке F\# библиотека Brahma.FSharp~\cite{brahma}, основанная на транслировании F\# quotation в OpenCL.

В настоящий момент в библиотеке Brahma.FSharp реализована поддержка примитивных типов и массивов. Однако в задачах, решаемых при помощи распараллеливания, часто удобно использовать такие типы, как структуры и кортежи, позволяющие представить данные в виде набора переменных различных типов. В Brahma.FSharp не поддерживаются кортежи и существует только частичная реализация поддержки структур.

В данной работе реализована поддержка кортежей и структур и добавлены некоторые функции для их использования.

\section{Постановка задач}
Цель данной работы — реализация поддержки кортежей и структур в библиотеке Brahma.FSharp. Для достижения цели были выделены следующие задачи:
\begin{itemize}
\item изучение библиотеки Brahma.FSharp;
\item изучение особенностей языка OpenCL;
\item реализация поддержки структур и кортежей в Brahma.FSharp;
\item тестирование;
\item добавление примеров и описания на официальный сайт.
\end{itemize}

\section {Обзор}
Помимо Brahma.FSharp существуют другие библиотеки на F\# для интеграции вычислений на графических процессорах: FSCL~\cite{fscl} и Alea GPU~\cite{aleagpu}. В библиотеке Alea GPU реализована трансляция структур, а в  FSCL — структур и кортежей.

В Brahma.FSharp уже реализована трансляция, механизм работы с памятью, а также некоторые функции для обработки примитивных типов данных и массивов. В программах, написанных на F\#, также широко применяются кортежи и структуры, и было бы полезно наличие их поддержки и для параллельных вычислений на GPGPU.

Одной из особенностей языка OpenCL является отсутствие такого типа данных, как кортеж, что требует поиска новых решений для реализации их трансляции на FSharp, например, с использованием существующих в OpenCL структур.

\section {Основная часть}
В данном разделе описаны детали реализации поддержки кортежей и структур в библиотеке Brahma.FSharp.
 
\subsection {Поддержка структур в Brahma.FSharp}
Использование структур в библиотеке реализовано следующим образом: 
\begin{itemize}
\item объявление структуры на F\# транслируется в соответствующее объявление на OpenCL; 
\item при инициализации нового экземпляра структуры на стороне OpenCL создается объект специально созданного типа StructType с доступом к полям структуры, который переводится в структуру, поддерживаемую OpenCL;
\item структура загружается в буфер памяти соответствующего размера.
\end{itemize}

На момент начала работы в библиотеке существовала частичная реализация поддержки структур. Было проведено тестирование и исправлены обнаруженные ошибки при инициализации новой структуры. Таким образом, стало возможным создание структуры с несколькими конструкторами, имеющими разное количество аргументов, например такой:
\begin{lstlisting}
[<Struct>]
type s =
    val x: int 
    val y: int
    new (x1, y1) = {x = x1; y = y1} 
    new (x1) = {x = x1; y = 0}
\end{lstlisting}
Инициализировать новый экземпляр такой структуры можно следующими способами:
\begin{lstlisting}
let a = new s(1)
let a = new s(1, 2) 
\end{lstlisting}
Однако сложные конструкторы, использующие создание новой структуры без присвоения ей имени, т.е. 
\begin{lstlisting}
let a = (new s(1)).x + 4 
\end{lstlisting}
в данный момент недоступны.

Также был рассмотрен вариант передачи структур на GPU по ссылке, однако это не позволило бы создавать массивы структур, так как в OpenCL нельзя использовать указатели на указатели. Кроме того, изучение спецификации OpenCL 1.2 показало невозможность объявления структуры, полем которой является массив. 

Таким образом, в результате данной работы в библиотеке Brahma.FSharp стали доступны: объявление структур, инициализация новых структур вне и внутри kernel-функции, передача в качестве аргументов функции, обращение к полям по имени и их изменение, создание структур с несколькими конструкторами от разного количества аргументов и использование  массивов структур.
\subsection {Поддержка кортежей в Brahma.FSharp}
В языке OpenCL нет такого типа данных, как кортеж, поэтому поддержка кортежей была реализована с помощью нескольких скрытых от пользователя преобразований в структуры следующим образом:
\begin{itemize}
\item в отличие от структур, типы элементов кортежа никак не объявляются до непосредственного его появления в программе, поэтому при каждом появлении нового кортежа происходит проверка на существование объявления кортежа с такими же типами элементов и, при отсутствии, он объявляется как структура с именем tuple + уникальный номер;
\item в трансляторе создан тип TupleType, представляющий собой надстройку над типом StructType с зафиксированными именами полей (“\_1”, “\_2” и т. д.);
\item для загрузки в память кортеж необходимо перевести в структуру следующим образом: задана специальная структура с полями обобщенного типа (struct t2<T1, T2>), конструктор которой может принимать переменные любого типа; в ходе выполнения определяются типы элементов кортежа, и на их основе создается экземпляр вышеописанной структуры, который и помещается в память.
\end{itemize}

В данной работе была реализована возможность доступа к элементам с помощью стандартных функций fst, snd и отдельно реализованных функций first, second и third. Важной деталью реализации последних трех функций является то, что хотя их трансляция производится исключительно по имени, необходимо обработать вызов шаблона TupleGet. При этом вызове в связи с особенностью платформы .NET происходит преобразование функции в метод, что приводит к ошибке с несоответствием входных данных, т.е элементы кортежа воспринимаются как несколько отдельных объектов. Данная проблема была решена с использованием сигнатур — специальных конструкций в F\#, определяющих типы входных и выходных данных функции.

Таким образом, была реализована поддержка кортежей из двух и трех элементов, а именно: передача их в качестве аргументов функций, возможность доступа к элементам, создание новых кортежей внутри функции и использование массивов кортежей.

\section {Эксперименты}
В системе NUnit была протестирована основная функциональность реализованных возможностей, а именно:
\begin{itemize}
\item объявление структур;
\item инициализация структур и создание кортежей вне и внутри kernel-функции и передача в качестве аргументов;
\item доступ к полям структур и элементам кортежей;
\item объявление массивов кортежей и структур.
\end{itemize}

% У заключения нет номера главы
\section*{Заключение}
В рамках данной работы были получены следующие результаты:
\begin{itemize}
\item изучены принципы работы библиотеки Brahma.FSharp;
\item изучены особенности языка OpenCL;
\item реализована поддержка структур и кортежей в Brahma.FSharp;
\item проведено тестирование;
\item на официальный сайт добавлены примеры использования новых возможностей и описание.
\end{itemize}
В качестве дальнейшего развития возможны:
\begin{itemize}
\item реализация поддержки кортежей из большего количества элементов;
\item возможность задания структуры, содержащей массив;
\item возможность применения функций fst и snd к кортежу, объявленному в виде let (a,b) = (1,2);
\item расширение возможностей использования конструкторов структур;
\item реализация механизма передачи массива кортежей с CPU на GPU и обратно.
\end{itemize}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
