\documentclass[14pt]{matmex-diploma-custom}
\usepackage{enumitem}
\usepackage{amsmath}

% * <svitkovsergey@gmail.com> 13:38:37 13 Dec 2016 UTC+0300:
% ping
\begin{document}
\filltitle{ru}{
    chair              = {Кафедра Системного программирования},
    title              = {Реализация поиска путей с КС-ограничениями в рамках библиотеки YC.QuickGraph},
    type               = {coursework},
    position           = {студента},
    group              = 344,
    author             = {Свитков Сергей Андреевич},
    supervisorPosition = {ст. преп, к. ф-м. н.},
    supervisor         = {Григорьев С.\,В.},
}
\maketitle
\tableofcontents
\section*{Аннотация}
	Большинство промышленных языков для написания запросов к графовым базам данных являются регулярными. Но регулярные языки не применимы в ряде задач, поэтому актуальным является создание контекстно-свободного (далее --- КС) языка запросов. Существуют работы по этой теме, но они в основном теоретические. В данной работе рассматривается практическая реализация механизма контекстно-свободных запросов к ориентированным графам с помеченными ребрами для платформы .NET. Результатом работы является библиотека, предоставляющая набор функций для написания КС-запросов к графам. Полученные результаты могут быть применены в проектах, использующих C\# или F\#.

\section*{Введение}
	Модель представления данных в виде ориентированных графов с метками на ребрах имеет широкую область применения и используется в биоинформатике, социальных исследованиях (например, при представлении социальных графов), semantic web, при реализации графовых баз данных. 
	
	При наличии представления данных в виде определенной структуры становится актуальным вопрос их обработки, а именно --- получения из всего набора только тех данных, которые представляют какой-либо конкретный интерес. Для этого используются языки запросов. Существует множество промышленных языков запросов к графам, например Gremlin\cite{Gremlin}, Cypher\cite{Cypher}, и т.д.. Но данные языки являются регулярными, а значит, не могут применяться в некоторых задачах. Например, при разборе генеалогического дерева, встречаются строки вида \(parent^nchild^n\). Такие строки нельзя распознать с помощью регулярной грамматики, но можно с помощью КС-грамматики с правилами вывода \(N \to parent\,child, \,N \to parentN\, child\). 
	
	Существуют работы, предлагающие различные подходы к реализации КС-запросов к графам, например \cite{sevon2008subgraph}, \cite{hellings2014conjunctive}. Но большая часть работ по данной теме представляет только теоретические сведения о возможных подходах к реализации, а те, что реализованы на практике, имеют довольно ограниченный функционал или же слишком узкую специализацию. Так, в работе \cite{hellings2014conjunctive} результатом запроса является КС-отношение --- тройка вида \((n, m, N)\), где \(n\) и \(m\) --- вершины, связанные путем, выводимым из нетерминала \(N\). Другой пример формата представления результата запроса встречается в работе \cite{sevon2008subgraph}. В данном случае это граф, включающий в себя только те ребра, которые встречаются хотя бы в одном пути, который выводим из грамматики, заданной в запросе. Исходя из этого, становится понятно, что класс задач, решаемых с помощью КС-запросов, является весьма обширным. Поэтому хотелось бы иметь библиотеку, средства которой позволят не только писать КС-запросы к графам, но и представлять результат в желаемой форме. Для того, чтобы такая библиотека была широко используема на практике, она должна быть реализована на одной из популярных платформ. Одной из таких платформ является .NET. Для реализации такой библиотеки требуются инструменты, которые позволяли бы работать с графами, задавать КС-запросы к ним, а также осуществлять синтаксический анализ. 
	
	Для .NET существует ряд библиотек для работы с графами, например \cite{graphsharp}, \cite{agl}, но наиболее известной является \cite{quickgraph}, однако, работа над ней прекращена в 2011 году. На кафедре Системного Программирования с 2015 года ведется разработка и поддержка библиотеки YC.QuickGraph\cite{YC.QuickGraph}, являющейся обновленной реализацией \cite{quickgraph}. В данной библиотеке имеется достаточный набор средств для работы с графами, поэтому используем ее. В качестве алгоритма для синтаксического анализа графов было решено использовать GLL\cite{gll}, поскольку он имеет хорошую асимптотику и может обрабатывать все КС-грамматики, в том числе и лево-рекурсивные, а так же в рамках работы \cite{ragRelaxedParsing} был реализован и интегрирован в YaccConstructor \cite{YaccConstructorPage} --- наборе инструментов для решения различных задач синтаксического и лексического анализа, реализованном для платформы .NET. 
	
	Исходя из написанного выше, было принято решение реализовать библиотеку, используя .NET как основную платформу, YC.QuickGraph --- как средство для работы с графами и YaccConstructor в качестве набора инструментов. Результат работы позволяет осуществлять КС-запросы к ориентированным графам с помеченными ребрами, представляя результат в виде подграфа, пути, КС-отношения.
	
\section{Постановка задачи}
    Исходя из сформулированных во введении проблем, была поставлена цель работы:
	\begin{itemize}
	    \item Реализовать механизм поиска путей с КС-ограничениями как расширение библиотеки YC.QuickGraph
	\end{itemize}
	Так же были поставлены задачи для достижения цели:
	\begin{itemize}
	    \item Спроектировать архитектуру решения
        \item Реализовать расширение библиотеки YC.QuickGraph
        \item Опубликовать результат в виде NuGet-пакета
	\end{itemize}

\section{Используемая терминология}
    Перед начало обзора сформулируем несколько опредений, которые будут использованы в дальнейшем.
	
	Под ориентированным графом с метками на ребрах будем понимать тройку множеств \(G\,=\,(V,\,E,\,L)\), где \(V\) --- множество вершин, \(E\) --- множество ребер, \(L\) --- множество меток над ребрами.
	
	Под грамматикой будем понимать четверку множеств \(Gr\,=\,(N,\,T,\,P,\,S)\), где \(N\) --- множество нетерминальных, \(T\) --- множество терминальных символов, \(P\) --- правила вывода, \(S\) --- стартовый нетерминал.

	Под контекстно-свободным запросом к ориентированному графу с метками на ребрах будем понимать поиск таких строк из меток на ребрах, которые выводимы в задаваемой в качестве запроса контекстно-свободной грамматике.

\section{Обзор предметной области}
	Контекстно-свободные (далее --- КС) запросы к ориентированным графам с помеченными ребрами применимы для решения широкого класса задач. Существует ряд работ, посвященных этой теме, но их результаты в основном теоретические, или же имеют слишком узкую специализацию. Так же следует отметить отсутствие реализаций для крупных платформ. Далее будут рассмотрены существующие решения в данной области, а так же средства, которые использовались в ходе работы.
	\subsection{Graph Parsing}
	Данная область синтаксического анализа имеет прямое отношение к теме работы, поскольку синтаксический анализ графа, как правило, является одним из шагов любого алгоритма, исполняющего запрос к графу. Однако в этой секции будут рассмотрены, преимущественно, работы, посвященные реализации инструментов для исполнения запросов в целом, нежели реализации алгоритмов для синтаксического анализа графов.
		\subsubsection{Conjunctive Context-Free Path Queries}
		В данной работе рассматривается построение обобщения существующего регулярного языка запросов к графам с помеченными ребрами CRPQ до языка CCFPQ, средства которого позволяют задавать КС-запросы. Расширение позволяет использовать КС-грамматики вместо регулярных выражений для поиска интересующих путей в графе. Предлагаемый в статье алгоритм использует CYK для синтаксического анализа графов, разбирая выражения грамматики снизу вверх. Результатом исполнения запроса является КС-отношение --- тройка вида (n, m, N), где n, m --- вершины, а N --- нетерминал, из которого выводим путь из вершины n в вершину m. К минусам данной работы можно отнести отсутствие практической реализации и возможность представления результата запроса лишь в одном формате.
		\subsubsection{Subgraph Queries by Context-free Grammars}
		Данная работа рассматривает вопрос о применении КС-запросов в различных задачах биоинформатики. Предложенный в статье подход подразумевает поиск связного подграфа, порождаемого множеством путей, строки из меток на которых выводимы из задаваемой в качестве запроса КС-грамматики. Для синтаксического анализа используется Earley parser \cite{}. Авторами было проведено тестирование алгоритма, предлагаемого в статье, как на случайно сгенерированных, так и на реальных данных. Эксперименты проводились на компьютере с 1GB оперативной памяти, в качестве ОС использовался Linux. Графы, на которых проводилось тестирование алгоритма, генерировались со следующими ограничениями: фиксированный размер в 10000 вершин, изменяемое ограничение на максимальную длину пути, а так же регулируемая вероятность существования ребра между двумя вершинами. Например, запрос к сгенерированному графу с максимальной длиной пути в 9 вершин выполняется около 200 секунд. Эксперименты, поставленные на реальных данных, показали, что для графа с максимальной длиной пути, равной 8 вершинам, время работы алгоритма может достигать 250 секунд. Таким образом, единственный формат представления результата, а также довольно большое время исполнения запроса, являются основными причинами, по которым результаты данной работы едва ли применимы на практике. 
		\subsubsection{Ослабленный синтаксический анализ динамически формируемых выражений на основе алгоритма GLL}
		Работа Анастасии Рагозиной, написанная на кафедре СП Математико-Механического факультета СПбГУ, не предлагает решений для написания КС-запросов к графам, но в рамках данной работы был реализован алгоритм для синтаксического анализа динамически формируемого кода на основе алгоритма GLL. Предложенный в работе алгоритм позволяет обрабатывать входные данные большого размера и может быть использован, например, при поиске подпоследовательностей в метагеномных сборках. Так же была доказана корректность и завершаемость алгоритма. Следует отметить, что результатом работы алгоритма является лес разбора, представляемый в виде SPPF\cite{sppf}. Поскольку имея SPPF, можно представить результат запроса в нескольких формах, просто используя преобразования, а так же учитывая наличие реализации алгоритма для платформы .NET в проекте YaccConstructor, было принято решение использовать результаты работы автора при реализации предлагаемой библиотеки.
% * <svitkovsergey@gmail.com> 13:54:22 13 Dec 2016 UTC+0300:
% Нужно ли что-то подробно рассказывать про GLL?
	\subsection{YaccConstructor}
	    YaccConstructor --- исследовательский проект лаборатории языковых инструментов JetBrains, применимый для исследования и решения различных задач синтаксического и лексического анализа. Поддержка и разработка проекта осуществляется как работниками лаборатории, так и студентами. Проект имеет одноименный инструмент с открытыми исходниками, который включает в себя большое количество компонентов, таких, как язык спецификаций грамматик YARD, алгоритмы для преобразования грамматик, алгоритмы для синтаксического анализа графов и др. Большая часть компонент проекта YaccConstructor реализованы для платформы .NET на языке F\#. Поскольку проект имеет модульную архитектуру, его компоненты могут быть использованы независимо.
	    
	    Более подробно рассмотрим такие средства YaccConstructor, как YARD, IL, GLL. YARD --- язык спецификаций грамматик, позволяющий задавать различные типы грамматик (атрибутные, в нормальной форме Бэкуса-Наура, конъюнктивные).
	\subsection{YC.QuickGraph}
	    make quickgraph great again.
\section{Постановка задачи}
1
\section{Основная часть}
1
\section{Эксперименты}
1
\section*{Заключение}
1
\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{coursework}

\end{document}