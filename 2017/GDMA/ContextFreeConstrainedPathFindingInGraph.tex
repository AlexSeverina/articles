%compile with xelatex --shell-escape ContextFreeConstrainedPathFindingInGraph.tex

% v2-acmtog-sample.tex, dated March 7 2012
% This is a sample file for ACM Transactions on Graphics
%
% Compilation using 'acmtog.cls' - version 1.2 (March 2012), Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - March 2012
\documentclass[runningheads,a4paper]{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
 % V1.2

%\acmVolume{VV}
%\acmNumber{N}
%\acmYear{YYYY}
%\acmMonth{Month}
%\acmArticleNum{XXX}
%\acmdoi{10.1145/XXXXXXX.YYYYYYY}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
%\usepackage{gnuplottex}
\usepackage{tikz}
\usepackage{mathtools}

\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{textcomp}

\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}


\begin{document}

\newtheorem{mytheorem}{Theorem}
%\newtheorem{lemma}{Lemma}

\algrenewcommand\algorithmicindent{0.5em}
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}

\algtext*{EndSwitch}
\algtext*{EndCase}
\algtext*{EndWhile}% Remove "end while" text
\algtext*{EndIf}% Remove "end if" text
\algtext*{EndFor}% Remove "end for" text
\algtext*{EndFunction}% Remove "end function" text

\newif\ifboldnumber
\newcommand{\boldnext}{\global\boldnumbertrue}

% Default definition is \footnotesize#1:
\algrenewcommand\alglinenumber[1]{%
  \footnotesize\ifboldnumber\bfseries\fi\global\boldnumberfalse#1:}


\makeatletter
\def\@copyrightspace{\relax}
\makeatother

%\title{Generalized LL Parsing for Context-Free Constrained Path Search Problem}
%\title{Structural representation of result for context-free path query problem}
%\title{Generalized LL for context-free path query problem}
%\title{Context-free path query with Structural representation of result}
%\title{Generalized LL for Context-free path query with Structural representation of result}
\title{Context-Free Path Querying with Structural Representation of Result}

\sloppy

%\numberofauthors{2}

\author{
       Semyon Grigorev\\
       \and
       Anastasiya Ragozina\\
}

\institute{Saint Petersburg State University, 7/9 Universitetskaya nab.\\ St. Petersburg, 199034 Russia \\
\email{semen.grigorev@jetbrains.com},
\email{ragozina.anastasiya@gmail.com}
}

\maketitle

\begin{abstract}
Graph data model and graph databases are very popular in various areas such as bioinformatics, semantic web, and social networks.
One specific problem in the area is a path querying with constraints formulated in terms of formal grammars.
The query in this approach is written as grammar, and paths querying is graph parsing with respect to given grammar.
There are several solutions to it, but they are based mostly on CYK or Earley algorithms which have some restrictions in comparison with another parsing techniques, but usage of advances parsing techniques for graph parsing is still an open problem.
In this paper we propose a graph parsing technique which based on generalized top-down parsing algorithm (GLL) and allows one to build such representation with respect to given grammar in polynomial time and space for arbitrary context-free grammar and graph.

\keywords{Graph database, path query, graph parsing, context-free grammar, top-down parsing, GLL, LL}

\end{abstract}


% A category with the (minimum) three required fields
%\category{Information Systems}{Database Management}{Query Languages}
%A category including the fourth, optional field follows...
%\category{Theory of computation}{Formal languages and automata theory}{Grammars and context-free languages}

%\terms{Languages, Algorithms}



\section{Introduction}
Graph data model and graph data bases are very popular in various areas such as bioinformatics, semantic web, social networks, etc.
Extraction of paths which satisfy specific constraints may be useful for investigation of graph structured data and for detection of relations between data items.
One specific problem---path querying with constraints---is usually formulated in terms of formal grammars and is called formal language constrained path problem~\cite{FLCpathProblem}.

Classical parsing techniques can be used to solve formal language constrained path problem.
It means that such technique can be used for more common problem---graph parsing. 
Graph parsing may be required in graph data base querying, formal verification, string-embedded language processing, and another areas where graph structured data is used. 

Though constrains formulated in terms of regular languages is widely used, using of more powerful context-free grammars for graph querying is in active research: recent results is context-free extension for SPARQL~\cite{CFGonRDF} and research of Jelle Hellings~(\cite{Hellings16,ConjCFPathQuery}).

Existing solutions in context-free graph querying field usually employ such parsing algorithms as CYK or Earley(for example~\cite{ConjCFPathQuery,CFGonRDF,GraphQueryWithEarley}). 
These algorithms are pretty simple, and impose different restrictions.
For example, in case of CYK, the input grammar should be transformed to Chomsky normal form (CNF) which leads to grammar size increase. 
Result is a performance decreasing, because parsing time significantly depends on grammar size.
In case of using such parsing algorithms as GLR and GLL there is no need to transform a grammar to CNF for these algorithms.
Thus, advanced parsing techniques allow us to improve performance of parsing in some cases, but graph processing with advanced parsing algorithms~\cite{Grune} is an open question~\cite{Hellings16}.

Despite the fact that there is a set of path querying solutions~\cite{GraphQueryWithEarley,ConjCFPathQuery,QueryGraphWithData,RegularDBQuery}, query result exploration is still a challenge~\cite{hofman2015separabilityForRegQueryDebugging}, as also a simplification of complex query debugging, especially for context-free queries.
In~\cite{Hellings16} annotated grammar proposed as possible solution: this representation is finite for any input data and contains information which can be useful for detailed result exploration.
At the same time, classical parsing techniques provide another representation---derivation tree---which contains exhaustive information about parsed sentence structure in terms of specified grammar, and looks more native for grammar based analysis.
In this work we show that finite derivation forest may be constructed for arbitrary graph and context-free grammar.

%Graph parsing can also be used to analyze dynamically generated strings or string-embedded languages.

%String variable in a program may gets multiple values in run time.
%In order to convey statical analysis, value set of string variable can be over-approximated with regular language which is represented as a finite automaton.
%Moreover, to check a syntactic correctness of dynamically generated strings, one should check that all generated strings (all paths from start states to final states in the given automaton) are correct with respect to the given context-free grammar. 

%There are solutions to this problem: GLR-based checker of string-embedded SQL queries~\cite{Alvor1,Alvor2}, parser of string-embedded languages~\cite{relaxedRNGLR} based on RNGLR parsing algorithm.
%RNGLR-based algorithm allows to construct derivation forest (i.e. the set of derivation trees) for all correct paths in the input automaton.

We make the following contributions in this paper.
\begin{enumerate}
\item We propose a graph parsing algorithm based on generalized top-down parsing algorithm---GLL~\cite{scott2010gll}---and provide its time and space complexity estimations. 
For graph $M=(V,E,L)$ space complexity is $O(|V|^3 + |E|)$ and time complexity is $O\left(|V|^3*\max\limits_{v \in V}\left(deg^+\left(v\right)\right)\right)$.
Thus we answer on first and second questions which are stated in~\cite{Hellings16}: yes, we can use advanced parsing techniques for graph parsing, and we can use top-down parsing algorithm for goal-oriented queries evaluation.
\item We propose a graph parsing algorithm which allows one to construct finite representation of parse forest which contains derivation trees for all matched paths in graph. We show how this representation can be used for realistic problems solving.
\item We implement proposed algorithm and in evaluation we show that advanced parsing techniques allow to increase performance (up to 1000 times in some cases) in comparison with CYK-based implementation, proposed in~\cite{CFGonRDF}.
\end{enumerate}

\input{Preliminaries.tex}
\input{Gll.tex}
\input{MotivExample.tex}
\input{Evaluation.tex}
\input{Conclusion.tex}
\input{Acknowledgments.tex}


\bibliographystyle{abbrv}
\bibliography{ContextFreeConstrainedPathFindingInGraph}

\end{document}
