1: Добрый день. Меня зовут Екатерина, я сотрудник лаборатории языков инструментов JetBrains на математико-механическом факультете СПбГУ. Сегодня я вам расскажу о библиотеке Ostap, предоставляющей синтаксическое расширение языка OCaml для создания парсер-комбинаторов с поддержкой левой рекурсии

2: Синтаксическим анализом (или парсингом) называется процесс сопоставления последовательности лексем -- символов -- с некоторой спецификацией языка, например грамматикой. В случае, если данная последовательность лексем действительно является предложением языка, осуществляется построение дерева разбора, отражающего синтаксическую структуру предложения. 

3: Существует множество различных подходов к реализации синтаксических анализаторов. Один из них -- парсер-комбинаторы -- пришел к нам из мира функционального программирования. Данный подход реализует нисходящий разбор, то есть построение дерева разбора начинается со стартового нетерминала и продолжается до тех пор, пока не будет порождена исследуемая строка. В рамках подхода обычно предоставляется несколько базовых парсер-комбинаторов, используя которые можно систематически порождать все более и более сложные анализаторы. Помимо этого, возможно вычислять семантические действия непосредственно во время синтаксического анализа, не осуществляя построения деревьев разбора. Одним из существенных преимуществ подхода является возможность анализировать не только контекстно-свободные языки, но так же некоторые контекстно-зависимые. Например, можно легко написать синтаксический анализатор кода, чувствительного к идентации -- количеству пробельных символов, стоящих перед лексемой (например, haskell или python). 

4: Давайте обсудим, как устроены парсер-комбинаторы. Парсер-комбинаторы это функции, которые, будучи примененными к данной строке, анализируют некоторый ее префикс, после чего возвращают оставшийся суффикс вместе с результатом анализа. На этом суффиксе запускается анализ "следующим" анализатором и такой процесс осуществляется до тех пор, пока вся строка не окажется проанализирована. Иногда анализ данным парсером завершается ошибкой, тогда результатом анализа возвращается Failed. Итого, парсер имеет тип функции из типа входного потока 's в результат, параметризованный типом входного потока, типом результата и типом вспомогательной информации, необходимой для лучшей сигнализации об ошибках анализа. Результатом является тип-объединение с вариантами успешного и неуспешного завершения анализа (Parsed и Failed) соответсвенно. 

5: Самыми элементарными парсерами являются следующие функции. Функция empty, которая разбирает пустую строку. Она всегда завершается успешно, не поглощая ни одного символа из входного потока. Вторая функция -- fail -- всегда завершается неудачей. Функция lift нужна для того, чтобы (* кажется, в контексте данного доклада она ни к чему, выкинуть *). Функция return возвращает переданный ей первым аргументом результат x, не поглощая ни одного символа со входной строки. Из такого сорта базовых парсеров, используя три базовых комбинатора можно реализовать синтаксические анализаторы целевого языка. Базовыми комбинаторами являются комбинаторы последовательного применения двух парсеров, альтернативного применения, и комбинатор map. 

6: Первый комбинатор -- комбинатор последовательности -- осуществяет последовательный вызов двух парсеров, переданных ему как аргументы. Если анализ первым завершился успешно, то проихзводится анализ вторым. В данном комбинаторе происходит важное действие: результат работы первого парсера передается второму, что позволяет учитывать контекст, тем самым позволяя парсить некоторые контекстно-зависимые языки.

7: Второй комбинатор -- комбинатор альтернативы -- осуществляет анализ либо первым, либо вторым анализатором -- соответствует альтернативе в контекстно свободных грамматиках. Сначала вызывается первый анализатор, и только если разбор им завершился неудачно, проверяется, можно ли данную строку разобрать вторым анализатором. 

8: Давайте посмотрим пример описания спецификации языка при помощи парсер-комбинаторов. На данном слайде показан анализатор для разбора языка, состоящего из цепочек символов a произвольной длины. Анализатор для данного языка -- я назвала его a -- Это альтернатива между анализатором, который разбирает пустую строку и последовательностью из двух анализаторов: один из которых разбирает один символ 'a', а второй является рекурсивным вызовом самого себя. (Пока все очень похоже на классические КС грамматики)

9: Парсер-комбинаторы позволяют осуществлять семантические действия. Для этого используется комбинатор map. Он осуществляет применение переданной ему аргументом функции f к результату синтаксического анализа, если он был успешным, и просто возвращает ошибку, если она произошла. 

10: при помощи этих комбинаторов можно реализовать вспомогательные, более сложные комбинаторы, например, проверяющие, что данная строка парсится или нет данным анализатором (Комбинатор opt), или комбинатор many для проверки, что данная строка парсится последовательным применением данного парсера 0 или сколь угодно много раз. Используя такие вспомогательные комбинаторы, можно писать куда более лаконичные спецификации языков. Например, язык последовательностей из символов a можно написать как применеине комбинатора many к парсеру одиночного символа. 

11: Конечно, непосредственно писать парсеры, используя базовый набор комбинаторов, может быть обременительно, поэтому в нашей библиотеке реализовано синтаксического расширение языка OCaml. Расширение позволяет реализовывать спецификацию языка в формате, напоминающим БНФ. В данном случае, например, реализован анализатор языка арифметических выражений с операциями сложения и умножения, осуществляющий построение дерева разбора в удобном нам формате. результаты работы каждого используемого парсера можно именовать и использовать при подсчете семантики (в примере такими именами являются x и y). 

12: Теперь представим себе ситуацию разработки анализатора некоторого языка. В нашем языке арифметические операции возможны между целыми числами, а возможны между числами с плавающей точкой. Мы можем написать две спецификации соответствующих языков, однако, мы могли значительно сократить количество кода, а значит, и количество потенциальных ошибок, переиспользуя все, что не относится к анализу непосредственно чисел. 

13: Такого сорта переиспользование легко реализовать при помощи парсеров высшего порядка. Напомню, синтаксчиеские анализаторы в данном контексте -- функции высшего порядка, а поэтому можно написать парсер для арифметических выражений с бинарными операциями, параментризуемый анализатором операндов, тогда требуемые два парсера -- всего лишь применения парсера выражений к парсеру целых чисел и чисел с плавающей точкой соответственно. 

14: Однако у парсер-комбинаторов есть недостатки. Среди них унаследованная от нисходящего анализа невозможность обрабатывать леворекурсивные правила. Например, в случае парсера выражений, для того, чтобы проанализировать строку при помощи парсера e, нам нужно проанализировать строку при помощи парсера e, а для этого нужно проанализировать ее при помощи парсера e... Таким образом анализатор зацикливается, не способный считать ни один символ со входного потока. При этом, удаление левой рекурсии, во-первых, значительно усложняет спецификацию языка, так еще и негативно влияет на свойство композициональности анализаторов. 

15: Конечно, в мире сделано многое для поддержки левой рекурсии в парсер-комбинаторах. Например, работа Frost показывает, что за счет ограничения количества леворекурсивных вызовов длиной непрочитанного суффикса строки, можно анализировать неоднозначные леворекурсивные грамматики. К сожалению, данный подход невозможно масштабировать на случай, когда длина входного потока не известна, или если какие-то нетерминалы порождают пустые строки. Другой подход, предложенный Warth, предлагает использовать мемоизацию для поддержки левой рекурсии в одной из реализаций подхода парсер-комбитнаторов. Данный подход требует, чтобы все леворекурсивные парсеры были парсерами первого порядка. Также существует, на данный момент наиболее честный способ для обработки леворекурсивных правил, предложенная Измайловой и другими библиотека Meerkat. Данный подход использует Continuation Passing Style и мемоизацию для обеспечения завершаемости разбора. Данный подход, однако, фиксирует конкретную семантику для анализаторов. 

16: В смежной области, называющейся Parsing Expression Grammars, тоже сущесвтует подход для поддержки левой рекурсии. В данном случае осуществляется динамический поиск такого числа леворекурсивных вызовов, что будет возможен анализ максимально длинного префикса. Данный подход также использует мемоизацию, поддерживает явную, неявную и взаимную рекурсию, однако также требует, чтобы парсер был первого порядка. 
 
17: В нашей библиотеке мы используем предложенное Medeiros-ом решение, дополняя его специальным комбинатором fix, необходимым для поддержки парсеров высшего порядка. Обратите внимание на пример. Тут записана наиболее естественная спецификация грамматики арифметических выражений с бинарной операцией плюс и операндами, разбираемыми парсером p. E при этом -- парсер высшего порядка, параментризуемый парсером для операндов. В данной спецификации в первой альтернативе парсер e вызывается дважды, будучи применен к одному и тому же параметру. Механизм частичного применения, к сожалению, породит в данный момент две различных функции, что не позволит нам понять, что тут происходит рекурсивный вызов. При помощи комбинатора неподвижной точки fix, мы можем избавиться от необходимости частично применять e к аргументу. Как только мы переходим к такой записи, в первой альтернативе у нас фигурируют только уже сформировавшиеся парсеры первого порядка, на которых как раз хорошо отрабатывает подход Medeiros, позволяя нам поддержать леворекурсивные парсеры высшего порядка. 

18: Итого, сегодня была представлена библиотека парсер-комбинаторов и синтаксическое расширение для языка OCaml, а также рассказано, как была реализована поддержка леворекурсивных анализаторов, позволяющая использовать парсеры высшего порядка, необходимые для лучше композициональности. К сожалению, сложность работы решения на данный момент растет экспоненционально с глубиной вложенности леворекурсивных вызовов, исследование возможности избавления от экспоненты является предметом для дальнейшего исследования. Спасибо за внимание, я буду рада ответить на ваши вопросы.  










