\section{Связь задачи генерации строк с синтаксическим анализом графов для КС-языков}

Рассмотрим задачу синтаксического анализа графа $G = (Q, \Sigma, \delta)$ с использованием контекстно-свободной грамматики $C = (N, \Sigma, P)$ и различных семантик запроса.

\textbf{\textit{Relational} семантика запроса.} Зафиксируем нетерминал $a \in N$ и вершины графа $m, n \in Q$. При использовании данной семантики запроса необходимо проверить пустоту КС-языка $L(C,a) \cap L(G,m,n)$. Чтобы использовать для этой задачи генератор строк, необходимо построить КС-грамматику, порождающую язык $L(C,a) \cap L(G,m,n)$. В качестве такой грамматики используется аннотированная грамматика $C_{G} = (N_{G}, \Sigma, P_{G})$. А построив данную грамматику мы автоматически решаем поставленную задачу. Действительно, если $a[m,n] \notin N_{G}$, то $L(C,a) \cap L(G,m,n) = \emptyset$, а если $a[m,n] \in N_{G}$, то $L(C,a) \cap L(G,m,n) \ne \emptyset$. Поэтому нет необходимости в применении генератора строк для поиска ответа на запрос с \textit{relational} семантикой.

\textbf{\textit{All-path} семантика запроса.} Зафиксируем нетерминал $a \in N$ и вершины графа $m, n \in Q$. В данной вариации задачи синтаксического анализа графов необходимо предъявить все такие пути из вершины $m$ в вершину $n$, что метки на их ребрах образуют строку из языка $L(C,a)$. Совокупность всех строк, порождаемых такими путями, будет являться КС-языком $L(C,a) \cap L(G,m,n)$. Чтобы использовать генератор строк этого языка, необходимо построить КС-грамматику его порождающую. В качестве такой грамматики используется аннотированная грамматика $C_{G} = (N_{G}, \Sigma, P_{G})$. Причем, в работе~\cite{azimov-spbu-hellings2} эту грамматику и предлагают в качестве ответа на запрос с \textit{all-path} семантикой. Одно из преимуществ данного решения заключается в том, что имеется возможность компактно хранить бесконечное множество путей, которое может возникнуть при наличии цикла в графе $G$. Поэтому нет необходимости в применении генератора строк для поиска ответа на запрос с \textit{all-path} семантикой. Но генератор строк может быть использован для получения конкретных строк пользователем из КС-грамматики $L(C,a) \cap L(G,m,n)$. Это похоже на использование следующей (\textit{single-path}) семантики запроса, но в ней выдается один путь (и, соответственно, одна строка), когда здесь можно последовательно выдавать все новые строки из языка $L(C,a) \cap L(G,m,n)$.

Таким образом, в рассматриваемой задаче имеется возможность использовать генератор строк аннотированной КС-грамматики $C_{G}$, порождающей язык $L(C,a) \cap L(G,m,n)$. Как уже было замечено, $L(C,a) \cap L(G,m,n) \ne \emptyset \Leftrightarrow a[m,n] \in N_{G}$. Поэтому после построения аннотированной грамматики можно сразу определить пуст ли язык $L(C,a) \cap L(G,m,n)$. Необходимость применения генератора строк остается только в случае $L(C,a) \cap L(G,m,n) \ne \emptyset$. Поэтому далее считаем, что $L(C,a) \cap L(G,m,n) \ne \emptyset$, и будем исследовать возможность применения генератора строк КС-языка $L(C,a) \cap L(G,m,n)$ для последовательного предоставления отдельных строк пользователю.

Будем генерировать строку, соответствующую одному из пяти видов ограничений, представленных на рис.~\ref{azimov-spbu-tasks}. Во всех случаях имеется ограничение сверху (лексикографическое или по длине строки), что позволяет свести задачу генерации строк заданного языка к конечному числу проверок на принадлежность строк этому языку. А так как рассматриваемый лексикографический порядок в работе~\cite{azimov-spbu-Okhotin} также упорядочивает строки по длине, то во всех пяти видах ограничений мы ограничиваем генерируемую строку длиной сверху. Поэтому чтобы гарантировать генерацию строки, необходимо знать строку минимальной длины из рассматриваемой грамматики (или лексикографически наименьшую строку). Для КС-грамматик существует алгоритм, позволяющий находить строку минимальной длины, что и используется в работе~\cite{azimov-spbu-Okhotin} для генерации строк КС-языка и в работе~\cite{azimov-spbu-hellings2} в задаче синтаксического анализа графов с использованием \textit{single-path} семантики запроса. Поэтому при последовательной генерации строк мы сначала решим задачу для \textit{single-path} семантики как и в работе~\cite{azimov-spbu-hellings2}, а после, меняя ограничения, сможем генерировать новые строки. Таким образом, каждый раз будет решаться задача для \textit{single-path} семантики, но предъявляться будет не строка наименьшей длины, а строка наименьшей длины из еще не рассмотренных строк.

\textbf{\textit{Single-path} семантика запроса.} Зафиксируем нетерминал $a \in N$ и вершины графа $m, n \in Q$. При использовании данной семантики запроса необходимо проверить пустоту КС-языка $L(C,a) \cap L(G,m,n)$ и, если он не пуст, то предъявить путь из вершины $m$ в вершину $n$, такой что метки на ребрах этого пути образуют строку из языка $L(C,a)$. В качестве такого пути в работе~\cite{azimov-spbu-hellings2} было решено использовать путь, соответствующий строке наименьшей длинны языка $L(C,a) \cap L(G,m,n)$. Как и в случае \textit{all-path} семантики запроса сначала строится аннотированная грамматика $C_{G} = (N_{G}, \Sigma, P_{G})$, и если она порождает не пустой язык, то в ней ищется строка минимальной длины, которая и будет соответствовать искомому пути в графе G.

Так как построение аннотированной грамматики и строки минимальной длины КС-языка $L(C,a) \cap L(G,m,n)$ необходимо для использования рассматриваемой генерации строк этого языка из работы~\cite{azimov-spbu-Okhotin}, то алгоритм решения задачи синтаксического анализа графов с использованием \textit{single-path} семантики запроса, предложенный в работе~\cite{azimov-spbu-hellings2}, и является примером использования генерации строки из КС-языка $L(C,a) \cap L(G,m,n)$.