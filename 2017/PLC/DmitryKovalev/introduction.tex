\section*{Введение}
Современные языки программирования общего назначения поддерживают возможность работы со строковыми литералами, позволяя формировать из них выражения при помощи строковых операций. Строковые выражения могут создаваться динамически, с использованием таких конструкций языка, как циклы и условные операторы. 
Данный подход широко используется, например, при формировании SQL-запросов к базам данных из программ, написанных на Java, C$\#$ и других высокоуровневых языках (листинг \ref{lst:example}).

\begin{figure}[h]	
	\vspace{-10pt}
	\lstset{language=[Sharp]C,
		showstringspaces=false,
		basicstyle=\small,
		keywordstyle=\bfseries,,	
	}
	\begin{lstlisting}[caption={Динамически формируемый SQL-запрос}, label={lst:example}, captionpos=b]
private void Example (bool cond) {
    string columnName = cond ? "name" : "address";
    string queryString = 
        "SELECT id, " + columnName + " FROM users";
    Program.ExecuteImmediate(queryString);
}
	\end{lstlisting}
	\vspace{-10pt}
\end{figure}

Недостаток такого метода генерации кода заключается в том, что формируемые выражения, с точки зрения компилятора, являются обычными строками и не проходят статические проверки на корректность и безопасность, что приводит к ошибкам времени исполнения и усложняет разработку и сопровождение системы. 
Включение обработки динамически формируемых строковых выражений в фазу статического анализа осложняется тем, что такие выражения, в общем случае, невозможно представить в виде линейного потока, который принимают на вход традиционные алгоритмы лекического/синтаксического анализа. 

%Недостаток этого метода заключается в том, что динамически формируемое выражение, в общем случае, невозможно представить в виде линейного потока токенов и, следовательно, компилятор не может произвести синтаксический/семантический анализы таких выражений с целью проверки их корректности и безопасности, что приводит к ошибкам времени исполнения и усложняет разработку и сопровождение системы.

%Недостаток этого метода заключается в том, что формируемое выражение, с точки зрения компилятора, является обычной строкой и, следовательно, не проходит статические проверки на корректность и безопасность, что приводит к ошибкам времени исполнения и усложняет разработку и сопровождение системы. 
%Использование классических методов статического анализа, таких как синтаксический разбор, для динамически формируемых выражений невозможно, так как, в общем случае, они не представимы в виде линейного потока, который принимают на вход традиционные алгоритмы. 

Для решения данной проблемы были разработаны различные методы статического анализа множества значений формируемого выражения. Как правило, язык, на котором написана исходная программа, тьюринг-полон, что делает невозможным проведение точного анализа. Поэтому распространенным подходом является построение некоторой аппроксимации рассматриваемого множества. Ряд предложенных ранее решений использует для анализа \textit{регулярную аппроксимацию} --- множество строк, генерируемых программой, аппроксимируется сверху регулярным языком, и анализатор работает с его компактным представлением, таким как регулярное выражение или конечный автомат.
%Один из подходов к построению такой аппроксимации основан на стандартных методах анализа потоков данных (dataflow analysis) --- значения строковых переменных, участвующих в генерации выражения, описываются при помощи набора dataflow-уравнений, которые извлекаются из соответствующего участка кода. 
%Эти уравнения, в зависимости от дальнейшего метода анализа, могуть быть непосредственно решены, либо интерпретированы как контекстно-свободная грамматика, которая задает язык, содержащий в себе все строки --- возможные результаты исполнения исходного кода.   

В магистерской диссертации \cite{gll_reg} был описан алгоритм, позволяющий проводить синтаксический анализ регулярной аппроксимации (конечного автомата, представленного в виде графа) множества значений динамически формируемого выражения. Основой для данного алгоритма служит алгоритм обобщенного синтаксического анализа Generalized LL (GLL, \cite{gll}).
Такой подход позволяет получать конечное представление леса разбора \cite{sppf} корректных строк, содержащихся в аппроксимации множества значений выражения. Это представление может быть использовано для проведения более сложных видов статического анализа и для целей реинжиниринга.

%Один из других подходов к анализу динамически формируемого кода, абстрактный синтаксический анализ \cite{a_lr}, использует в качестве аппроксимации набор dataflow-уравнений, которые извлекаются из участка кода, описывающего построение строкового выражения. 
%Эти уравнения могут быть интерпретированы как контекстно-свободная грамматика, которая задает язык, содержащий в себе все строки --- возможные результаты исполнения исходного кода. Такая аппроксимация позволяет описать множество значений выражения более точно, чем регулярная.

В данной статье будет представлен алгоритм синтаксического анализа, который основан на описанной выше модификации GLL, но работает с более точной, чем регулярная, контекстно-свободной аппроксимацией множества значений динамически формируемого выражения. Использование более точной аппроксимации позволяет снизить количество ложных синтаксических ошибок, возникающих в результате того, что аппроксимирующее множество может содержать строки, осутствующие среди значений искомого выражения.

%В данной статье будет представлен алгоритм синтаксического анализа, который основан на описанной модификации GLL, но работает с более точной, чем регулярная, аппроксимацией множества строк --- значений динамически формируемого выражения. Наш подход заключается в использовании 

%В данной статье будет представлен алгоритм синтаксического анализа контекстно-свободной аппроксимации множества значений динамически формируемого выражения, который основан на описанной выше модификации GLL-алгоритма.
%Для получения КС-аппроксимации мы использовали dataflow-уравнения такого же вида, как и авторы абстрактного синтаксического анализа. Входными данными для нашего алгоритма является представление КС-грамматики, соответствующей уравнениям, в виде графа. Подробнее об этом представлении будет рассказано в статье. 