% !TeX spellcheck = russian-aot
% !TeX encoding = UTF-8
% ----------------------------------------------------------------

\documentclass [a4paper] {article}

% ----------------------------------------------------------------
% Required packages

\usepackage [T2A] {fontenc}
\usepackage [utf8] {inputenc}
\usepackage [english, russian] {babel}

\usepackage {url}
\usepackage [style=gost-numeric] {biblatex}

\addbibresource {kovalev-spbu-biblio.bib}

% ----------------------------------------------------------------
% Title settings

\title %
  {Динамически формируемый код: синтаксический анализ \\ контекстно-свободной аппроксимации}

\author %
{%
  Ковалев~Д.\,А., \url {dmitry.kovalev-m@ya.ru} \and %
  Григорьев~С.\,В., \url {semen.grigorev@jetbrains.com} \\
  Санкт-Петербургский государственный университет, \\
  Россия, 199034, Санкт-Петербург, Университетская наб. 7/9; \\
  Лаборатория языковых инструментов JetBrains
}%

\date {}

% ----------------------------------------------------------------
\begin {document}
% ----------------------------------------------------------------

\maketitle

\begin {abstract}
	Многие программы в процессе работы формируют из строк исходный код на некотором языке программирования и передают его для исполнения в соответствующее окружение (пример --- dynamic SQL). 
	Для статической проверки корректности динамически формируемого выражения используются различные методы, одним из которых является синтаксический анализ регулярной аппроксимации множества значений такого выражения.
	Аппроксимация может содержать строки, не принадлежащие исходному множеству значений, в том числе синтаксически некорректные. 
	Анализатор в данном случае сообщит об ошибках, которые на самом деле отсутствуют в выражении, генерируемом программой.
	В докладе будет описан алгоритм синтаксического анализа более точной, чем регулярная, контекстно-свободной аппроксимации динамически формируемого выражения.
  \\ \textbf {Ключевые слова:} синтаксический анализ, динамически формируемый код, контекстно-свободные грамматики, GLL, GFG, dynamic SQL
\end {abstract}

Современные языки программирования общего назначения поддерживают возможность работы со строковыми литералами, позволяя формировать из них выражения при помощи строковых операций. 
Строковые выражения могут создаваться динамически, с использованием таких конструкций языка, как циклы и условные операторы. 
Данный подход широко используется, например, при формировании SQL-запросов к базам данных из программ, написанных на Java, C$\#$ и других высокоуровневых языках.

Недостаток такого метода генерации кода заключается в том, что формируемые выражения не проходят статические проверки на корректность и безопасность, что приводит к ошибкам времени исполнения и усложняет  сопровождение системы. 
Включение обработки динамически формируемых строковых выражений в фазу статического анализа осложняется тем, что такие выражения, в общем случае, невозможно представить в виде линейного потока, который принимают на вход традиционные алгоритмы лекcического/синтаксического анализа. 

Для решения данной проблемы были разработаны специальные методы статического анализа множества значений формируемого выражения. 
Как правило, язык, на котором написана исходная программа, тьюринг-полон, что делает невозможным проведение точного анализа.
Ряд существующих методов использует для анализа \textit{регулярную аппроксимацию} --- множество строк, генерируемых программой, аппроксимируется сверху регулярным языком, и анализатор работает с его компактным представлением, таким как регулярное выражение или конечный автомат.

В магистерской диссертации \cite{kovalev-spbu-gll_reg} был описан алгоритм, позволяющий проводить синтаксический анализ регулярной аппроксимации (детерминированного конечного автомата) множества значений динамически формируемого выражения. Основой для данного алгоритма служит алгоритм обобщенного синтаксического анализа Generalized LL (GLL, \cite{kovalev-spbu-gll}).
Такой подход позволяет получать конечное представление множества деревьев вывода (SPPF, \cite{kovalev-spbu-sppf}) корректных строк, содержащихся в аппроксимации. Это представление может быть использовано для проведения более сложных видов статического анализа и для целей реинжиниринга.

GLL позволяет работать с произвольными КС-грамматиками, в том числе неоднозначными. 
Такая возможность достигается путем использования специальной структуры стека (GSS) и механизма \textit{дескрипторов}. Дескриптор хранит в себе информацию о состоянии анализатора в определенный момент времени, достаточную для продолжения процесса анализа с этого момента.
Оригинальный GLL-алгоритм был модифицирован для работы с нелинейным входом (конечный автомат представляется в виде графа).
Дескрипторы нового алгоритма хранят номер вершины входного графа вместо позиции в линейном потоке. 
Также, на шаге исполнения просматривается не единственный входной символ, а все ребра, исходящие из текущей вершины.

Мы расширили описанный подход, изменив алгоритм таким образом, чтобы он мог обрабатывать более точную, чем регулярная, \textit{контекстно-свободную аппроксимацию} значений динамически формируемого выражения. 
Использование более точной аппроксимации позволяет снизить количество ложных синтаксических ошибок, возникающих в результате того, что аппроксимирующее множество содержит строки, осутствующие среди значений искомого выражения. 
Под контекстно-свободной аппроксимацией здесь подразумевается грамматика, описывающая контекстно-свободный язык, который содержит в качестве подмножества возможные значения выражения. 
Идея использования такой аппроксимации была заимствована из существующих в данной области работ \cite{kovalev-spbu-phpsa, kovalev-spbu-a_lr}. 

Наш алгоритм принимает на вход графовое представление аппроксимирующей  КС-грамматики. В качестве такого представления был выбран Grammar Flow Graph (GFG, \cite{kovalev-spbu-gfg}). 
Алгоритм последовательно обходит узлы GFG, производя синтаксический анализ порождаемых им строк. 
Для правильного построения таких строк алгоритм должен манипулировать дополнительным стеком. Информация о текущей вершине данного стека  записывается в дескрипторы. 
Другой особенностью работы с GFG является то, что он, в отличие от регулярной аппроксимации --- детерминированного конечного автомата, допускает возможность неоднозначного выбора пути обхода. 
Подобная ситуация возникает при наличии в исходной грамматике нескольких продукций, содержащих в левой части одинаковый нетерминал. 
Механизм дескрипторов позволяет решать проблему недетерминированного выбора пути --- для каждого из возможных вариантов создается отдельный дескриптор, который добавляется в очередь исполнения.

Алгоритм был реализован на языке программирования F$\#$ в рамках проекта YaccConstructor. Исходный код доступен по ссылке: \url{ https://github.com/YaccConstructor/YaccConstructor}. Результаты проведенных синтетических тестов показали снижение количества ложных синтаксических ошибок при анализе динамически формируемого кода. В дальнейшем планируется провести аппробацию на реальных данных.
Задача синтаксического анализа графов также возникает в области биоинформатики \cite{kovalev-spbu-gll_reg}. 
Предполагается, что наш алгоритм может увеличить производительность анализа метагеномных сборок за счет использования более компактного представления входных данных --- из конечного автомата, описывающего сборку, может быть извлечена КС-грамматика \cite{kovalev-spbu-cf_extr}, графовое представление которой содержит меньше состояний.

\printbibliography

% ----------------------------------------------------------------
\end {document}
% ----------------------------------------------------------------

\endinput

% End of File
