\documentclass[sigconf]{acmart}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{balance}

\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{mathtools}

\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{verbatim}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08emT\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

%\AtBeginDocument{%
%  \providecommand\BibTeX{{%
%    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

\setcopyright{acmcopyright}
\copyrightyear{2020}
\acmYear{2020}
\setcopyright{rightsretained}
\acmConference[SIGMOD'20]{Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data}{June 14--19, 2020}{Portland, OR, USA}
\acmBooktitle{Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data (SIGMOD'20), June 14--19, 2020, Portland, OR, USA}
\acmDOI{10.1145/3318464.3384400}
\acmISBN{978-1-4503-6735-6/20/06}



\settopmatter{printacmref=true}
\begin{document}
\fancyhead{}

\title{Context-Free Path Querying via Matrix Equations}

\author{Yuliya Susanina}
\affiliation{%
  \institution{Saint Petersburg State University}
  \streetaddress{7/9 Universitetskaya nab.}
  %\city{St. Petersburg}
  %\state{Russia}
  \postcode{199034}
}
\affiliation{
  \institution{JetBrains Research}
  \streetaddress{Primorskiy prospekt 68-70, Building 1}
  \city{St. Petersburg}
  \country{Russia}
  \postcode{197374}
}
\email{jsusanina@gmail.com}


%\author{Semyon Grigorev}
%\affiliation{%
%    \institution{Saint Petersburg State University}
%    \streetaddress{7/9 Universitetskaya nab.}
%    \city{St. Petersburg}
%    \state{Russia}
%    \postcode{199034}
%}
%\affiliation{
%  \institution{JetBrains Research}
%  \streetaddress{Universitetskaya nab., 7-9-11/5A}
%  \city{St. Petersburg}
%  \country{Russia}
%  \postcode{199034}
%}
%\email{s.v.grigoriev@spbu.ru}
%\email{semen.grigorev@jetbrains.com}



%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Context-free path querying (CFPQ) widely used for graph-structured data analysis in such areas as bioinformatics, static code analysis, graph databases.
  It is crucial to develop highly efficient algorithms for CFPQ since the size of the input data is typically large.
  Computational mathematics may be useful because of both rich theoretical foundations and constantly improving modifications.
  We show how to reduce GFPQ evaluation to solving systems of matrix equations over $\mathbb{R}$ --- a problem for which there exist high-performance solutions.
  Also, we demonstrate the applicability of our approach to real-world data analysis.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Information systems~Query languages for non-relational engines</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Theory of computation~Formal languages and automata theory</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10002950.10003714.10003715.10003719</concept_id>
  <concept_desc>Mathematics of computing~Computations on matrices</concept_desc>
  <concept_significance>300</concept_significance>
  </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Information systems~Query languages for non-relational engines}
\ccsdesc[500]{Theory of computation~Formal languages and automata theory}
\ccsdesc[300]{Mathematics of computing~Computations on matrices}


\keywords{context-free path querying; graph databases; context-free grammar; nonlinear matrix equations; newton method}

\maketitle

\section{Introduction}

Context-free path querying (CFPQ)---a way to specify path constraints in terms of context-free grammars---is gaining popularity in many areas, e. g. bioinformatics~\cite{sevon2008subgraph}, graph databases~\cite{yannakakis1990graph,Medeiros:2018:EEC:3167132.3167265,Kuijpers:2019:ESC:3335783.3335791} or static code analysis~\cite{Reps,zhang2013fast}.
CFPQ is more expressive than the more commonly used regular languages constrained path query and therefore forms a promising research area.
Although many different algorithms for CFPQ have been proposed~\cite{RDF,Medeiros:2018:EEC:3167132.3167265,azimov2018context,Verbitskaia:2018:PCC:3241653.3241655,10.1007/978-3-319-91662-0_17}, recent research shows that real-world data handling is still a problem~\cite{Kuijpers:2019:ESC:3335783.3335791}.

Recent experiment~\cite{mishin2019evaluation} demonstrates a promising way to get high-performance CFPQ: reduce the problem to well-established problem for which high-performance solutions are available.
One such reduction was proposed by Rustam Azimov~\cite{azimov2018context} who showed that CFPQ can be reduced to Boolean matrix multiplication.
This way we, can offload the most computationally intensive calculations to high-performance libraries for matrix processing, which utilizes GPGPUs and other modern hardware.

On the other hand, there are several results of applying linear algebra methods to logic programming~\cite{sato2017linear, aspis2018linear}.
In~\cite{sato2017linear} it is shown that the evaluation of a subset of Datalog queries can be reduced to matrix equation solving.
This way one can use numerical linear algebra and computational mathematics to improve the performance of query evaluation.
If we adapt this technique for CFPQ, we can employ high-performance algorithms for numerical analysis and equation solving to improve the performance of CFPQ.
Approximate computational methods can also accelerate CFPQs processing.
And most importantly, the popularity of artificial intelligence techniques pushed the development and improvement of many efficient libraries for numerical computing.

In this work we propose a new way to reduce CFPQ to a problem with available high-performance solutions: we show that CFPQ can be reduced to solving the systems of equations over real numbers $\mathbb{R}$.
We also assess the feasibility of using both accurate and approximate methods of computational mathematics, such as a Newton method with high-performance implementations.
The evaluation of our approach on a set of conventional benchmarks shows that it is comparable with the matrix-based approach and applicable for real-world data processing.

\section{Preliminaries}

Context-free grammar (CFG) is a triple $G=(N, \Sigma, R)$, where $N$ is a set of nonterminal symbols, $\Sigma$ is a set of terminal symbols and $R$ is a set of productions of the followings form: $A \to \alpha$, $\alpha \in (N \cup \Sigma)^*$.
$\mathcal{L}(G_S)$ denotes a language specified by CFG $G$ with respect to $S \in N$: $\mathcal{L}(G_S) = \{\omega \mid S \Rightarrow_{G}^{*} \omega\}$.

Directed graph is a triple $D = (V,E,\sigma)$, where $V$ is a set of vertices, $\sigma \subseteq \Sigma$ is a set of labels, and a set of edges $E\subseteq V\times \sigma \times V$.
Denote a path from the node $m$ to the node $n$ in graph $D$ as $m\lambda n$, where
$\lambda$ is the unique word, obtained by concatenating the labels of the edges along this path.
$P$ is a set of all paths in $D$.

CFPQ problem with relational semantics (according Hellings~\cite{hellings2014conjunctive}) is for a graph $D$ and a CFG $G$, to find \emph{context-free relations} $R_A \subseteq V \times V$ such that for each $A \in N$: $R_A = \{(m, n) \mid m\lambda n \in P, \lambda \in \mathcal{L}(G_A)\}.$
Every relation $R_A$ is finite, so it can be represented as a Boolean matrix: $(T_A)_{i,j} = 1 \iff (i,j) \in R_A$.

\section{Equation-Based Approach}

We reduce CFPQ to equation solving similarly to the way Taisuke Sato reduces Datalog program evaluation to linear algebra~\cite{sato2017linear}.
But unlike Sato, we also decide to consider nonlinear cases and draw attention to the approximate computational methods.

For a given graph and grammar, each terminal and nonterminal specifies a finite relation $R_A$ which can be represented as a Boolean matrix.
After that for each production of form $$N_i \to \beta^0_0 \dots \beta^0_k \mid \ldots \mid \beta^l_0 \dots \beta^l_m, \beta^i_j \in \Sigma \cup N$$ we can create an equation $$T_{N_i} = T_{\beta^0_0}\cdot \ldots \cdot T_{\beta^0_k} + \ldots + T_{\beta^l_0}\cdot \ldots \cdot T_{\beta^l_m}$$

For example, a simple query for describing the $a^nb^n$ language cannot be expressed using some regular grammar, we should use context-free one: $S \rightarrow aSb \mid ab$. 
Boolean matrix equation for this grammar is
\begin{center}
\(
\left.
\begin{array}{l}
T_S = T_AT_ST_B + T_AT_B
\end{array}
\right.
\)
\end{center}

We can solve this equation by na\"ive iterative process:
\begin{center}
\(
\left.
\begin{array}{l}
T_S^0 = \mathbf{0} \\
T_S^{k+1} = T_a T_S^k T_b + T_a T_b
\end{array}
\right.
\)
\end{center}

To be able to apply advanced numerical techniques we can consider another equation over $\mathbb{R}$:

\begin{center}
\(
\left.
\begin{array}{l}
\mathcal{T}_S = \epsilon(T_A \mathcal{T}_S T_B + T_A T_B)
\end{array}
\right.
\)
\end{center}

For the equation we can construct a matrix series $\{ \mathcal{T}_S^{k}\}$:

\begin{center}
\(
\left.
\begin{array}{c}
\mathcal{T}_S^0 = \mathbf{0} \\
\mathcal{T}_S^{k+1} = \epsilon(T_A \mathcal{T}_S^k T_B + T_A T_B)
\end{array}
\right.
\)
\end{center}

It converges to $\mathcal{T}_S^*$ when $\mathcal{T}_S^{k} \leq \textbf{1}$ as a monotonically increasing series of matrices with an upper bound.
It can be proved that $((\mathcal{T}_S^{k+1})_{ij} > 0 \iff (T_S^{k+1})_{ij} = 1)$ and $ceil(\mathcal{T}_S^*) = T_S^*$, where $ceil(x)$ returns the least integer greater or equal to $x$~\cite{sato2017linear}.

So, for each rule of the form $$N_i \to \beta^0_0 \dots \beta^0_k \mid \ldots \mid \beta^l_0 \dots \beta^l_m, \beta^i_j \in \Sigma \cup N$$ we can generate an equation
$$\mathcal{T}_{N_i} = \epsilon_{N_i}(T_{\beta^0_0}\cdot \ldots \cdot T_{\beta^0_k} + \ldots + T_{\beta^l_0}\cdot \ldots \cdot T_{\beta^l_m}), $$ where $\epsilon_{N_i}$ is chosen such that $\mathcal{T}_{N_i}^{k} \leq \textbf{1}$ for each $k$.
In real-world cases, we deal with the systems of matrix equations because grammars contain more than one nonterminal.
The equations are either linear or nonlinear.

\textbf{Linear Equations.}
If the input CFG is linear, each equation is of the form of generalized Sylvester equation: $\sum_{i = 1}^{k} A_iXB_i = C$.
For $k = 1, 2$ we can solve it in $\mathcal{O}(|V|^3)$~\cite{Bartels:1972:SME:361573.361582}.
Otherwise, for $k > 2$ it can be reduced using Kronecker product to solving a linear system $Ax = b$, where $A$ is a matrix of size $(|V|^2 \times |V|^2)$ and time required to compute its solution is $\mathcal{O}(|V|^6)$ or $\mathcal{O}(|V|^{4 + 2\omega})$ using more efficient matrix multiplication algorithms (where $\mathcal{O}(n^{2+\omega})$ is a complexity of the most performant $n\times n$ matrix multiplication algorithm).
The use of sparse matrix representation and approximate methods can be very efficient for solving the equations of this type~\cite{bouhamidi2008}.

For the system of equations, we construct the dependency graph $D_G = (V_G, E_G)$ for nonterminals of a given grammar $G$ and split the set of the equations into disjoint subsets accordingly to the set of strongly connected components in $D_G$, which can be found in $\mathcal{O}(|V_G| + |E_G|)$~\cite{tarjan1972}.
Then we solve our system in stages, for each subset.

\textbf{Nonlinear Equations.}
For the nonlinear case we can rewrite each equation of the form $X = \Psi(X)$ to the equivalent $F(X) = X - \Psi(X) = 0$ and use Newton's method for nonlinear functions root finding:

\begin{center}
%\(
%\left.
%\begin{array}{c}
%F(X) = \mathbf{0}
%\end{array}
%\right.
%\)

\(
\left.
\begin{array}{l}
X_{i+1} = X_i - (F'(X_i))^{-1}F(X_i)
\end{array}
\right.
\iff
\left\{
\begin{array}{l}
F'(X_i)H_i = - F(X_i) \\
X_{i+1} = X_i + H_i
\end{array}
\right.
\)
\end{center}

We start iterations from $X_0$ as an initial guess, in our case $X_0 = $ \textbf{0}, as our solution is a matrix of small positive numbers.
The convergence of this method is quadratic which means that the solution finding can be significantly faster.
Even as it is necessary to solve an equation for $H_i$ (also generalized Sylvester equation) on each iteration step, the majority of high-performance implementations do not compute the Jacobian inverse and use its approximate value~\cite{knoll2004jacobian}.

The main difficulty in using Newton's method is choosing an appropriate $\epsilon$; to ensure the least positive solution for nonlinear equations $\epsilon$ must be smaller than $\frac{1}{|V|}$.


\section{Evaluation}

The equation-based approach for CFPQ was implemented and evaluated on \textbf{Query 2} from~\cite{azimov2018context}.
The equation constructed for this query were solved on the CPU by using two functions from Python package \textit{scipy}~\cite{scipy}:
\textit{spsolve} (\textbf{sSLV}) to solve as a sparse linear system
and
\textit{optimize.newton\texttt{\_}krylov} (\textbf{dNWT}) to find a root of a function.

\begin{table}[h]
\centering
\caption{Evaluation results for Query 2 (in ms)}
\label{tbl2}
\begin{tabular}{ | c | c || c | c || c | c | c |}
\hline
Ontology    & |V| & dNWT & sSLV & dGPU & sCPU &  sGPU \\
\hline
\hline
bio-meas    & 341 &  284 & 35   & 276  & 91  & 24\\
people-pets & 337 &  73  & 49   & 144  & 38  & 6\\
funding     & 778 &  502 & 184  & 1246 & 344 & 27\\
wine        & 733 &  791 & 171  & 722  & 179 & 6\\
pizza       & 671 &  334 & 161  & 943  & 256 & 23\\
\hline
\end{tabular}

\end{table}

We compare (Table~\ref{tbl2}) our solution with the first matrix-based algorithm implementations described in~\cite{azimov2018context} and conclude that the equation-based approach can be applied to the real-world data and is compared to the matrix-based algorithm.
Moreover, we can improve the performance by the means of parallel techniques for matrix operations.

\section{Conclusion and future work}

We proposed a new approach for context-free path querying, based on solving the systems of equations over $\mathbb{R}$.
The evaluation of our approach on a set of conventional benchmarks showed its applicability for the real-world data analysis.

Another direction is to determine the subclasses of (system of) polynomial equations the solution of which can be reduced to CFPQ and try to construct a bidirectional reduction between CFPQ and these subclasses, thereby finding efficient solutions for both these problems.



\begin{acks}
The research was supported by the Russian Science Foundation grant 18-11-00100.
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\balance
\bibliography{main}

\end{document}
\endinput