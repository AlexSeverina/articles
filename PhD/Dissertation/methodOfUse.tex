\chapter{Метод реинжиниринга информационных систем, использующих дмнамически формируемые выражения}

В данной главе изложен метод проведения реинжинирига информационных систем, использующих строковые встроенные языки (string-embedded languages~\cite{Alvor1}). Рассмотрены основные типы задач, решаемых при реинжиниринге, указаны особенности обработки встроенных языков при их решении. Основной акцент сделан на обработку динамически формируемого SQL-кода, однако изложенный метод может быть адаптирован к обработке систем, использующих другие встроенные языки.

\section{Особенности}

Реинжиниринг информационных систем~\cite{reengANT} как правило является комплексным мероприятием, которое может в ключать в себя различные шаги, такие как анализ кода и его изучение, его рефактоинг, трансформацию, перенос на другие программно-аппаратные платформы. При этом часто проводится комплексный анализ многокомпонентной системы целиком, что приводит к необходимости уитывать различные особенности системы и работать с разнородными артефактами: документацией, исходным кодом, конфигурационными скриптами, скриптами баз данных и т.д. Всвязи с высокой сложностью такого анализа, ренжиниринг, как правило, является автоматизированным, а не полностью автоматическим процесс, что означает возможность (и необходимость) активного участия человека. Это позволяет использовать инструменты, которые не приводят сразу к получению конечнго результата, однако минимизируют ресурсы, необходимые для решения задачи. Например, может оказаться, что в системе присутствуют файлы особого формата и для их автоматической обработки потребуется создание уникального инструмента, что потребует значительных ресурсов. Однако объём этих файлов мал и их ручной анализ прост. В ситуации, когда затраты на создание инструмента значительно выше затрат на ручной анализ с тем же качеством результата, часто оказывается выгоднее отказаться от создания инструмента.

С одной стороны, динамически формируемый код может содержать важную информацию о системе. Например, в динамически формируемых SQL-запросах могут содержаться сведения о схеме данных и особенностями работы с базой данных, не извлекаемые из внешнего кода. С другой стороны, при активном использовании динамически формируемый код является сущьностью, требующей отдельного внимания при обработке системы и, следовательно, должен быть учтён, например, при оценки сложности системы, часто проводимой на начальных этапах при определении сроков и стоимости работ.

Системы используют строковые встроенные языки с разной интенсивностью и разными способами. В зависимости от характера использования встроенных языков меняются требования к автоматизации их обработки: необходима ли инструментальная поддержка или ручная обработка потребует меньше ресурсов, чем создание или освоение инструмента, какими именно инструментами пользоваться в тех или иных случаях.

Метода не обнаружено. Надо предложить свой.


\section{Метод}

Как было сказано ранее, встроенным языком может оказаться любой язык, однако на практике достаточно широко распространено использование днамически формируемого SQL-кода и генерация HTML-страниц. Использование динамически формируемого кода на других языках встречается реже. Поэтому далее описан метод реинжиниринга систем, использующих встроенный SQL, однако он может быть адаптирован и к обработке систем, использующих другие встроенные языки.

Большая картинка.

\begin{enumerate}
  \item \textbf{Анализ целей и задач.}
  
  Проанализировать цели и задачи. От того, какие задачи необходимо решать, напрямую зависит выбор инструментов. Основные классы задач затрагивающих динамически формируемый код, которые можно выделить на данном этапе, приведены ниже.
  
  \begin{itemize}
    \item Оценка качества кода и его сложности, что часто сводится к подсчёту некоторых формальных метрик кода.
    \item Анализ надёжности системы, поиск различного рода уязвимостей и ошибок.
    \item Извлечение или восстановлени утраченных знаний о системе и её изучение.
    \item Трансформация исходной системы: рефакторинг, перенос на новые программно-аппаратные системы.
  \end{itemize}
  
  При этом необходимо проанализировать конечные цели реинжиниринга. Особенно важен данный шаг при необходимости решать задачи трансформации динамически формируемого кода. Например, если целью является как можно более быстрое получение работающей системы, дальнейшее развитие которой не планируется, то можно пожертвовать качаством кода результирующей системы, что может существенно упростить её обработку. Однако, если после выполнения трансформаций планируется активная разработка или поддержка полученной системы, то необходимо получить результирующий код как можно более привычный для разработчиков системы. Это упростит дальнейшую работу с ним, позволит уменьшить затраты на обучение крманды, поиск новых специалистов.
  
  Например, при трансляции хранимого SQL-кода, активно использующего динамический SQL, с одного языка на другой, важно сохранить однородность. Особенно если планируется дальнейшее развитие системы. Это обусловлено тем, что различные диалекты SQL содержат большое количество особенностей и разработчики на SQL часто оказываются специалистами достаточно узкого профиля. Таким образом, наличие двух различных диалектов в место одного, может усложнить набор команды. Более того, в процессе разработки необходимость переключаться между несколькими диалектами так же может вызвать трудности.
  
  Таким образом, необходимо ответить на следующий вопрос: планируется ли активное изменение системы после её реинжиниринга, если он включает трансформации.
  
  \item \textbf{Первичный анализ проекта.} На данном этапе необходимо проанализировать исходный код системы и выяснить характеристики встроенного текстового кода. Для этого, как правило, можно использовать стандартные средства анализа программного кода. Однако, скорее всего они будут требовь модификации, по этому необходимо иметь доступ к исходному коду. Необходимо оценить следующие характеристики.
  \begin{itemize}
    \item Клоичество точек выполнения встроенного кода. Как правило, за выполнение выражений на встроенном языке отвечают характрные языковые конструкции, например \verb| execute immediate| в языке T-SQL. следовательно, необходимо оценить количество таких конструкций. Для грубой оценки можно использовать простой текстовый поиск (если такой поиск говорит о полном отсутствии конструкций, то дальнейший анализ можно не проводить). Для более точной оценки необходимо использовать структурное представление кода, чтобы, например, не учитывать код, находящийся в комментариях. Получить структурное представление и доступ к нему можно с помощью библиотек синтаксического анализа соответствующего языка.
    
    \item Сложность формирования строковых выражений. Прежде всего необходимо определить наличие динамически формируемого кода и оценить сложность его формирования, так как в случае использования только константных строковых литеалов не потребуется специальных инструментов для анализа встроенного кода.
    
    Для данной оценки можно использовать протягивания констант. Его необходимо модифицировать таким образом, чтобы он отдельно обрабатывал выражения, отвечающие за формирование кода, и собирал о них следующую информацию о процессе формрования кода как для каждой точки выполнения, так и для всей системы вцелом.
    \begin{itemize}
      \item Количество конкатенаций.
      \item Количество операторов ветвления: \verb|if-then-else|, \verb|switсh-case| и т.д.
      \item Количество строковых функций: \verb|replace|, \verb|substring| и т.д.
      \item Количество циклов, как ``явных'' (\verb|while|, \verb|for|), так и организованных с помощью рекурсии.
      \item Количество переменных, значение для которых нельзя полностью вычислить статически (например, они получают значение из пользовательского входа).
      \item Факт формирования кода в телах более чем одного метода/процедуры. Необходимость межпроцедурного анализа.
    \end{itemize}
  \end{itemize}
  
  \item \textbf{Роль динамически формируемого кода в системе.} На данном шаге необходимо определить, какую роль в функционировании системы играют динамически формируемые запросы. Возможны следующие существенно различные ситуации.
  \begin{itemize}
    \item Использование динамически формируемого кода является один из основных элементов дизайна системы. 
    \item Динамически формируемый код используется как вспомогательное средство. Чаще всего явным признаком такой ситуации является его малое количество или полное отсутствие. Однако, это не всегда так. Возможна ситуация, когда динамически формируемых код достаточно активно используется для реализации служебной и вспомогательной функциональности. Тот факт, что данная функциональность не является основной для системы, может позволить обращать меньше внимания, например, на производительность результатов трансформации соответствующего кода.
  \end{itemize}
  
  \item \textbf{Возможности доступа к исходной системе в реальных условиях.} Возможность изучения системы в реальных условиях может дать большое количество полезной информации, которую трудно или дажен невозможно получить другими способами, так как даже тесты часто не воспроизводят реальное функционирование системы. Однако он часто оказывается невозможным или крайне затруднённым, что вызывается, с одной стороны вопросами безопасности, с другой стороны надёжностью, так как гарантировать, что внесённые изменения не отразатся на работоспособности системы часто затруднительно.  
  \begin{itemize}
    \item Есть ли доступ к системе, работающей в реальных условиях? Чтение определённых журнальных файлов, перехват сообщений на каком-либо уровне, доступ к реальной базе данных.
    \item Возможен ли запуск модифицированной системы в реальных условиях? Если мы можем запустить модифицированную систему, то важно убедиться, что будет возможность получить обратно собранную информацию.
    \item Модификации какого рода разрешены? Что можно собирать, а что нельзя.
  \end{itemize}
  
  \item \textbf{Анализ требований к производительности и потреблению ресурсов.} Можем ли мы позволить себе дополнительные накладные расходы? Ответ на данный вопрос особенно важен при выборе между статическим и динамическим анализом.
  
  \item \textbf{Анализ особенностей конкретного вншнего и встроенного языков.} Про мёржи, селекты и прочее.
  
  \item \textbf{Выбор подхода.} Статика или динамика~\cite{OpenSystem}. Когда всё проанализировано можно решить, какой подход предпочтительнее. Может быть и смешанный подход. Например, мёржи. В статике их инструментирование, а в динамике уже приведение к окончательному виду.
  
  \item \textbf{Выбор инструмента.} Учёт особенности задач и особенности инструментов, конекста работы.
  
\end{enumerate}

Изложенный метод позволяет что-то там чделать и может быть адаптирован как к системам, использующим к другие встроенные языки, так и к системам с несколькими встроенными языками, так как их обработка может проводиться независимо. 

\clearpage
