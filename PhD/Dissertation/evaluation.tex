\chapter{Эксперименты, ограничения, обсуждение} \label{chaptEval}

В рамках экспериментального исследования и апробации проводилось, в основном, изучение предложенного в данной работе алгоритма синтаксического анализа, архитектуры реализованного инструментария и предложенного метода, так как это является основными результатами данной работы. Так как многие свойства алгоритма либо формально доказаны в рамках работы, либо непосредственно следуют из доказанных свойств и описания (например, завершаемость и корректность на определённых классах входных данных), то интерес при экспериментальном исследовании представляет сравнение с инструментами, реализующими аналогичный алгоритм и оценка производительности.


\section{Экспериментальная оценка алгоритма}\label{SyntTestsEvalDescr}

Алгоритм синтаксического анализа динамически формируемых выражений, описанный выше, был протестирован на нескольких сериях синтетических тестов, цель которых~--- убедиться в приемлемой производительности алгоритма на практически значимых входных данных. Анализ промышленного проекта по миграции базы данных с MS-SQL Server 2005 на Oraclе 11gR2 показал, что запросы часто формируются конкатенацией фрагментов, каждый из которых формируется с помощью ветвлений или циклов. Ниже приведена эталонная грамматика $G_t$, использованная в этих тестах.

$$
\begin{array}{crcl}
& start\_rule &::=& s \\
& s & ::= & s \mbox{\texttt{ PLUS }} \mbox{\texttt{n}}\\
& n & ::= & \mbox{\texttt{ONE | }} \mbox{\texttt{TWO | }} \mbox{\texttt{THREE | }} \mbox{\texttt{FOUR | }} \\
&   &     & \mbox{\texttt{FIVE | }} \mbox{\texttt{SIX | }} \mbox{\texttt{SEVEN}}
\end{array}
$$

Входные данные представляли собой конечные автоматы над алфавитом терминальных символов грамматики $G_t$, построенные с помощью конкатенации базовых блоков. Предполагается, что такие графы могут быть получены в результате построения регулярной аппроксимации по некоторой программе и выполнения её лексического анализа. В данном случае базовый блок --- это шаблонный конечный автомат, который используется для построения тестовых конечных автоматов. Каждая серия тестов характеризовалась тремя параметрами: 

\begin{itemize}
  \item $height$~--- количество ветвлений в базовом блоке;
  \item $length$~--- максимальное количество повторений базовых блоков;
  \item $isCycle$~--- наличие в базовом блоке циклов (если ложь, то используются базовые блоки, изображённые на рисунке~\ref{block}, если истина~--- то изображённые на рисунке~\ref{block_loop}).
\end{itemize}

\begin{figure}[h!]
 \centering
 \includegraphics[width=15cm]{pics/block.pdf}
 \caption{Базовый блок без циклов при $height=3$}
 \label{block}
\end{figure}

\begin{figure}[h!]
 \centering
 \includegraphics[width=15cm]{pics/block_loop.pdf}
 \caption{Базовый блок, содержащий цикл, при $height=3$}
 \label{block_loop}
\end{figure}

Замеры проводились на вычислительной станции со следующими характеристиками.
\begin{itemize}
\item Операционная система: Microsoft Windows 8.1 Pro
\item Тип системы: x64-based PC
\item Процессор: Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz, 3601 Mhz, 4 Core(s), 8 Logical Processor(s)
\item Объём оперативной памяти: 16.0 GB
\end{itemize}

Чтобы выявить зависимость времени от размера входных данных, тесты проводились сериями. Каждая серия объединяет набор из $500$ тестов, каждый из которых содержит одинаковое количество ветвлений в базовом блоке. При этом количество повторений блока совпадает с порядковым номером теста, то есть $length=i$ для $i$-того теста. Для каждого теста измерялось время, затраченное на синтаксический анализ. Измерения проводились 10 раз, после чего усреднялись. График, представленный на рисунке~\ref{diffheights}, иллюстрирует зависимость времени, затрачиваемого на синтаксический анализ, от количества повторения базового блока и количества ветвлений в каждом из них. Можно заметить, что время, затрачиваемое на анализ, растёт линейно, в зависимости от размера входного графа. График на рисунке~\ref{CycleVsLinear} показывает, что наличие циклов в графе, при одинаковом значении параметра $height$, увеличивает продолжительность анализа, при этом зависимость времени от размера графа остаётся линейной.

\begin{figure}[h!]
 \centering
 \includegraphics[width=15cm]{pics/diffheights.png}
 \caption{Зависимость времени работы алгоритма от размера входного графа при $isCycle=false$}
 \label{diffheights}
\end{figure}

\begin{figure}[h!]
 \centering
 \includegraphics[width=15cm]{pics/heigh4.png}
 \caption{Зависимость времени работы алгоритма от размера входного графа и наличия в нем циклов при $height=4$}
 \label{CycleVsLinear}
\end{figure}


\section{Апробация в промышленном проекте по реинжинирингу}

Реализованный инструментарий был апробирован в рамках промышленного проекта по миграции базы данных с MS-SQL Server 2005 на Oraclе 11gR2, что позволило апробировать как предложенную архитектуру, так и протестировать некоторые части инструментария на реальных данных.

Обрабатываемая система состояла из 850 хранимых процедур и содержала около 2,6 миллионов строк кода. В ней присутствовало 2430 точек выполнения динамических запросов, из которых больше 75\% могли принимать более одного значения и при их формировании использовалось от 7 до 212 операторов. При этом среднее количество операторов для формирования запроса равнялось 40~\cite{Syrcose}.

Так как анализатор T-SQL был разработан ранее в рамках проекта, в котором происходило внедрение, то для создания анализатора встроенного SQL была использована готовая грамматика и по ней построен синтаксический анализатор. Построение регулярной аппроксимации и лексический анализ также были реализованы ранее в рамках основного проекта и были переиспользованы. Возможность использования компонент, созданных не в рамках YC.SEL.SDK, показало преимущества разделения шагов анализа.

Далее были реализованы функции вычисления метрик и вывода результата, после чего полученная функциональность была встроена в существующую цепочку обработки основного кода. В результате работы реализованных функций формировался отчёт, пример которого приведён в таблице~\ref{tbl:metrics}

Тесты проводились на вычислительном устройстве с параметрами, эквивалентными указанным в разделе~\ref{SyntTestsEvalDescr}. В ходе экспериментов измерялись следующие характеристики для каждой точки выполнения динамически формируемого запроса.

\begin{itemize}
  \item Время обработки t в миллисекундах. Проводилось 10 запусков, время анализа усреднялось. 
  \item Размер входного конечного автомата: количество состояний \#Q и количество переходов \#T.
  \item Размер построенного SPPF: количество вершин \#V и количество рёбер \#E.
  \item Результат анализа: $+$ --- завершился успешно, $-$ --- завершился с ошибкой, T --- завершён по таймауту.
\end{itemize} 


\begin{table} [htbp]
  \centering
  \parbox{14cm}{\caption{Распределение динамически формируемых SQL-запросов по времени обработки}\label{tbl:timing}}
  \begin{tabular}{| p{8cm} || p{3cm} | p{3cm}l |}
  \hline                               
  \hline
  Категория &\centering Количество запросов &\centering Время обработки (минуты) & \\
  \hline 
  Содержат корректные выражения                  &\centering  2188         &\centering  14& \\
  Не содержат ни одного корректного выражения    &\centering  240          &\centering  9& \\
  Обработка завершена по таймауту                &\centering  1            &\centering  4&  \\
  \hline
  \textbf{Всего}                                 &\centering \textbf{2430} &\centering \textbf{27} & \\
  \hline
  \hline
  \end{tabular}
\end{table}

Результаты измерений времени работы представлены в таблице~\ref{tbl:timing}. Алгоритм успешно завершил работу на 2188 входных графах, аппроксимирующих множества значений запросов. Ручная проверка входных графов, на которых алгоритм завершался с ошибкой, показала, что они действительно не содержали ни одного корректного в эталонном языке выражения. Причиной этого стала либо некорректная работа лексического анализатора, либо наличие в выражениях конструкций, не поддержанных в существующей грамматике. Так как лексический анализатор и грамматика были полностью заимствованы из оригинального проекта, то наличие этих ошибок не является недоработками алгоритма синтаксического анализа. Общее время синтаксического анализа составило 27 минут, из них 13 минут было затрачено на разбор графов, не содержащих ни одного корректного выражения. Из них 256 секунд --- обработка одного графа (5747 рёбер и 3897 вершин), прерванная по таймауту. Дальнейшие значения приводятся только для графов, которые удалось проанализировать. 604 из этих графов прождали ровно одно значение и анализировалось не более 1 миллисекунды. На разбор 1790 графов ушло не более 10 миллисекунд. На анализ двух графов было затрачено более 2 минут: 152,215 и 151,793 секунд соответственно. Первый граф содержал 2454 вершин и 54335 рёбер, второй~--- 2212 вершин и 106020 рёбер. Распределение входных графов по промежуткам времени, затраченных на анализ, приведено на графике на рисунке~\ref{distr}.

\begin{figure}[H]
  \centering
 \includegraphics[width=0.95\textwidth]{pics/distr.png}
 \caption{Распределение запросов по времени анализа}
 \label{distr}
\end{figure}


\begin{table} [htbp]
  \centering
  \parbox{13cm}{\caption{Пример отчёта по результатам запуска синтаксического анализа на реальной системе}\label{tbl:metrics}}
  \begin{tabular}{| r | c | c | c | c | c | c |}
  \hline                               
  \hline
  \multirow{2}{*}{\textnumero} &\multirow{2}{*}{t(мс)} &\multirow{2}{*}{r} &\multicolumn{2}{c}{DFA} &\multicolumn{2}{|c|}{SPPF} \\
  \cline{4-7} 
                               &                   &                   & \#Q     & \#T          & \#V         &         \#E \\ 
  \hline 
1  &6      &$+$ &75  &76	  &1074	   &1075	  \\
2  &73     &$+$ &104 &806   &18786	 &26377	  \\
3  &64     &$+$ &79  &750	  &17237	 &23954	  \\
4	 &15982  &$+$ &817 &32281 &920618	 &1885112	\\
5	 &3      &$+$ &108 &107	  &996	   &995	    \\
6	 &256000 & T  &3897&5747  &0  	   &0   	  \\
7	 &28360  &$+$ &924 &41408 &1315491 &2794517 \\
8	 &17     &$+$ &236 &506	  &4608	   &5165	  \\
9	 &207    &$+$ &928 &2249  &38709	 &57352	  \\
10 &110    &$+$ &390 &942	  &14757	 &21805	  \\
11 &111    &$+$ &377 &967	  &14812	 &21902	  \\
12 &262    &$+$ &764 &1907  &33332	 &49955	  \\
13 &3      &$+$ &117 &116	  &1093 	 &1092	  \\
14 &3      &$+$ &92  &92	  &1391	   &1391	  \\
  \hline
  \hline

  \end{tabular}
\end{table}



Тестирование на реальных данных показало, что предложенный в работе алгоритм синтаксического анализа применим для синтаксического анализа регулярной аппроксимации множества значений динамически формируемых выражений, используемых в коде промышленных информационных систем. Также данная апробация показала, что предложенная архитектура SDK позволяет использовать отдельные компоненты независимо и комбинировать их. Результаты успешно внедрены в проект компании ЗАО ``Ланит-Терком''.


\section{Сравнение с инструментом Alvor}

Единственным доступным инструментом, производящим синтаксический анализ динамически формируемого кода, является Alvor~\cite{Alvor1, Alvor2}. Данный инструмент реализует  близкий к представленному в работе подход: независимые шаги анализа, что позволяет легко выделить синтаксический анализ, который основан на GLR-алгоритме. Существенным отличием от разработанного алгоритма является то, что Alvor не строит деревья вывода. Важным для успешного проведения измерений является то, что исходный код Alvor опубликован, что позволяет модифицировать его таким образом, чтобы измерять параметры выполнения конкретных методов. 

Так как Alvor не предоставляет платформы для простой реализации поддержки новых языков, то для сравнения было выбрано подмножество языка SQL, общее для Alvor и реализованного в рамках апробации инструмента. Отсутствие возможности быстро построить новый анализатор на основе Alvor помешало сравнению на реальных данных, так как даже только спецификация грамматики T-SQL является задачей, требующей большого количества времени. По этой причине сравнение производилось на синтетических тестах, которые строились по принципу, аналогичному изложенному в разделе~\ref{SyntTestsEvalDescr}.  

Так как Alvor на вход принимает регулярное выражение, называемое \textit{абстрактной строкой}~\cite{Alvor2}, а анализатор, созданный на основе YC.SEL.SDK --- конечный автомат, то был реализован генератор, который по входным параметрам создают файл с абстрактной строкой и с описанием соответствующего автомата в формате DOT. Примеры тестовых входов для одинаковых входных параметров для инструмента на YC.SEL.SDK и Alvor представлены на рисунке~\ref{fig:YCInput} и листинге~\ref{!!!}  соответственно.

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.95\textwidth]{pics/YCvsAlvor.png}
 \caption{Входной граф для синтаксического анализатора на базе YC.SEL.SDK при $height=2$}
 \label{fig:YCInput}
\end{figure}

Результаты измерений при $height=2$ представлены на графике~\ref{fig:YCInput}. Видно, что время работы анализатора Alvor экспоненциальна относительно количества повторений базового блока и растёт быстрее времени работы анализатора на основе YC.SEL.SDK.

\begin{figure}[h!]
 \centering
 \includegraphics[width=0.95\textwidth]{pics/YCvsAlvor.png}
 \caption{Сравнение производительности Alvor и синтаксического анализатора на базе YC.SEL.SDK при $height=2$}
 \label{fig:YCvsAlvor}
\end{figure}


\section{Разработка расширений для поддержки встроенных языков}

На основе YC.SEL.SDK и YC.SEL.SDK.ReSharper, которые были представлены ранее, в рамках апробации были реализованы расширения к ReSharper, которые предоставляют поддержку для  двух встроенных языков языков: подмножества T-SQL и Calc. Реализация данных расширений также являлась апробацией предложенной архитектуры разработанного инструментального пакета.

В рамках данного шага апробации были созданы лексические спецификации и грамматики соответствующих языков. Исходный код описаний опубликован в открытом доступе: \url{https://github.com/YaccConstructor/YC.GrammarZOO}. Далее, с помощью генераторов из разработанного инструментария, по этим грамматикам построены синтаксические анализаторы, а по лексическим спецификациям --- лексические анализаторы.

При создании расширений был также апробирован механизм построения регулярной аппроксимации. Для построения графа потока управления внешнего вода использовалась функциональность ReSharper SDK. Затем полученный граф переводился в обобщённое представление, по которому строилась регулярная аппроксимация средствани разработанного инструмента.

После того, как отдельные части были готовы, они были объединены в готовый плагин на основе YC.SEL.SDK.ReSharper. В результате было получено два расширения, предоставляющие поддержку соответствующих языков и ядро, содержащее общую, независимую от языков, функциональность, связанную прежде всего с обеспечением взаимодействия между ReSharper и реализованными расширениями.

Расширения предоставляют следующую функциональность: подсветка синтаксиса (рисунок~\ref{fig:sHiglighting}), подсветка парных (рисунок~\ref{fig:braces}) элементов. Для языка Calc также реализована статическая диагностика семантических ошибок, а именно поиск использования необъявленных переменных, что показывает, с одной стороны, возможность непосредственного использования SPPF для проведения анализа динамически формируемого кода, а с другой --- возможность реализации дополнительной функциональности, не являющейся общей функциональностью SDK.

Статический поиск использования необъявленных переменных показан на 
рисунке~\ref{fig:undeclaredVars}. В данном примере переменная \verb|x| объявляется в одной из веток условного оператора и не объявляется в другой, что может привести к ошибке в точке использования, о чём и сообщено пользователю.

\begin{figure}[H]
  \centering
 \includegraphics[width=0.95\textwidth]{pics/multilanguages_light.png}
 \caption{Пример подсветки синтаксиса для нескольких встроенных языков: SQL и Calc}
 \label{fig:sHiglighting}
\end{figure}

\begin{figure}[H]
 \centering
 \begin{subfigure}[b]{0.47\textwidth}
  \includegraphics[width=\textwidth]{pics/brackets_one_to_many_light.png}
  \caption{Одной открывающей скобке соответствует несколько закрывающих}
  \label{fig:brOneToMany}
  \end{subfigure}
  ~
 \begin{subfigure}[b]{0.47\textwidth}
  \includegraphics[width=\textwidth]{pics/brackets_one_to_one.png}
  \caption{Одной закрывающей скобке соответствует одна открывающая}
  \label{fig:brOneToone}
 \end{subfigure}

 \caption{Пример подсветки парных скобок}
 \label{fig:braces}
\end{figure}

\begin{figure}[H]
  \centering
 \includegraphics[width=0.65\textwidth]{pics/undefined_variable.png}
 \caption{Пример статического обнаружения семантических ошибок для языка Calc}
 \label{fig:undeclaredVars}
\end{figure}

\begin{figure}[H]
  \centering
 \includegraphics[width=0.95\textwidth]{pics/sql_calc_cycle.png}
 \caption{Пример межпроцедурной обработки встроенных языков}
 \label{fig:interProc}
\end{figure}

Расширения опубликованы в виде готовых к использованию бинарных пакетов. Функциональность, отвечающая за поддержку каждого языка, распространяется в виде самостоятельного бинарного пакета и может быть независимо подключена или отключена. Структура пакетов представлена на рисунке~\ref{fig:packagesStructure}.

\begin{figure}[H]
  \centering
 \includegraphics[width=0.90\textwidth]{pics/RshPluginsPackages.png}
 \caption{Структура пакетов расширений для ReSharper, предоставляющих поддержку встроенных T-SQL и Calc}
 \label{fig:packagesStructure}
\end{figure}

Дополнительно в результате разработки расширений было подтверждено, что анализаторы языков могут быть использованы независимо. Например, анализаторы, разработанные в рамках расширений для ReSharper, используются в тестах не связанных с ReSharper. Это показывает, что независимость шагов обработки динамически формируемых выражений позволяет гибко переиспользовать компоненты, реализующие эти шаги, что является плюсом реализованного решения.

\section{Ограничения}

Используемые подходы и алгоритмы накладывают ограничения на платформу и разрабатываемые на её основе инструменты. Обсуждению этих ограничений посвящён данный раздел.

Множество, являющееся аппроксимацией множества значений динамически формируемого выражения, принимаемое на вход алгоритмом синтаксического анализа должно быть регулярным множеством. То есть аппроксимация задаёт регулярный язык, в то время как генерируемый программой может быть регкурсивно-перечислимым. Это означает, что за на этапе построения аппроксимации будет происходить потеря точности. Например, нехвостовая рекурсия точно не выразима в терминах регулярных множеств. Точность построения конкретной регулярной аппроксимации зависит от конкретного алгоритма, используемого для этого. алгоритм может реализовывать или не реализовывать межпроцедурный анализ, поддерживать или не поддерживать строковые операции, разными способами обрабатывать пользовательский ввод и другие ситуации, когда значение выражения вычислить невозможно. В рамках рассматриваемой платформы реализован алгоритм позволяющий поддерживать межпроцедурный анализ и строковые операции. 

Эталонный язык должен быть описан детерминированной контекстно-свободной грамматикой. Большинство языков программирования могут быть описаны такой грамматикой. Однако, с одной стороны, бывают исключения, например C++. С другой стороны, в документации языка программирования может быть приведена недетеминированная грамматика, а её приведение к детерминированной может потребовать значительных усилий. 

Вопросы быстродействия инструментов, созданных на основе зависят от контекста их использования. Если при реинжиниринге допустимо проведение длительных анализов, то для многих инструментов, используемых  в средах разработки, время отклика критично.  Особенно это важно для функциональности, работающей в режиме ``на лету'': подсветка синтаксиса, автодополениее, подсказки. Так как платформа создавалась с ориентацией на создание инструментов для реинжинирига, то некоторые компоненты направлены на увеличение точности анализа, возможно, в ущерб производительности. Примером такой компоненты может служить компонента построения регулярной аппроксимации, которая реализовывает алгоритм, который гарантирует построение приближения сверху, учитывает циклы и строковые функции~\cite{RegOverApprox}. Это повышает точность анализа, однако производительность может оказаться слишком низкой для использования в IDE. С другой стороны, при создании инструмента для IDE возможно заменить построение аппроксимации на более легковесное, но менее точное. Например в инструменте Alvor~\cite{Alvor2}, предназначенном прежде всего для интерактивной работы в среде разработки, предлагается такой алгоритм.  При этом важно, что возможности платформы позволяют комбинировать различные реализации компонент, так как они независимы. То есть можно использовать один и тот же синтаксический анализатор с разными вариантами лексичекого для получения требуемых характеристик результирующего инструмента. С другой стороны, текущая реализация содержит возможности для различного рода оптимизаций: некоторые алгоритмы могут быть ускорены с помощью распараллеливания, выбор оптимальных структур данных, например для конечных автоматов, активно использующихся в рамках платформы, является темой отдельного исследования~\cite{DataStructureForFA}.

Систематическое исследование работы с SPPF находится на начальной стадии даже в контексте обобщённого синтаксического анализа~\cite{SPPF2015}. В рамках же анализа динамически формируемых выражений исследований в этом направлении не обнаружено. По этой причине в рамках данной работы реализован только прототип библиотеки, позволяющей решать некоторые задачи, например, поиск необъявленных переменных, над SPPF в общем виде. Теоретическое исследование данного вопроса является отдельной задачей. С другой стороны, было доказано, что из построенного SPPF извлекаемы деревья вывода для любых цепочек из аппроксимации, а с деревьями можно работать с помощью стандартных методов. 

\clearpage
