\section*{Введение}
Организация взаимодействия между разнородными частями информационной системы --- задача достаточно сложная. Примерами таких компонент могут служить базы данных, браузеры и элементы, реализующие логику приложения. 
Один из первых способов взаимодействия между этими компонентами, получивший широкое распространение благодаря своей гибкости и простоте, основан на передаче текстовых команд на языке, поддерживаемом системой, 
к которой идёт обращение. Части команд обычно хранятся в строковых литералах из которых в процессе работы программы формируется команда, передаваемая на выполнение. Примерами использования динамически 
формируемых строковых выражений могут служить динамические SQL-запросы к базам данных в java-коде или динамическое формирование HTML-страниц (листинги~\ref{lst:dsql1},~\ref{lst:JsJava},~\ref{lst:PhPSqlHtml}).   

\fvset{frame=lines,framesep=5pt,fontsize=\small}\

\begin{listing}
    \begin{pyglist}[language=sql,numbers=left,numbersep=5pt]

CREATE PROCEDURE [dbo].[MyProc]  @TABLERes   VarChar(30)
AS
    EXECUTE ('INSERT INTO ' + @TABLERes + ' (sText1)' +
             ' SELECT ''Additional condition: '' + sName' +
             ' from #tt where sAction = ''1000000''')
GO
    \end{pyglist}
\caption{Код с использованием динамического SQL}
\label{lst:dsql1}
\end{listing} 
 
\fvset{frame=lines,framesep=5pt}
\begin{listing}
    \begin{pyglist}[language=java,numbers=left,numbersep=5pt]
import javax.script.*;  
public class InvokeScriptFunction {  
    public static void main(String[] args) throws Exception {  
        ScriptEngineManager manager = new ScriptEngineManager();  
        ScriptEngine engine = manager.getEngineByName("JavaScript");  
        // JavaScript code in a String  
        String script = 
            "function hello(name) { print('Hello, ' + name); }";  
        // evaluate script  
        engine.eval(script);  
        // javax.script.Invocable is an optional interface.  
        // Check whether your script engine implements or not!  
        // Note that the JavaScript engine implements
        // Invocable interface.  
        Invocable inv = (Invocable) engine;  
        // invoke the global function named "hello"  
        inv.invokeFunction("hello", "Scripting!!" );  
    }  
}
    \end{pyglist}
\caption{Вызов JavaScript из Java}
\label{lst:JsJava}
\end{listing}


\fvset{frame=lines,framesep=5pt}
\begin{listing}
    \begin{pyglist}[language=php,numbers=left,numbersep=5pt]

<?php
    // Embedded SQL
    $query = 'SELECT * FROM ' . $my_table; 
    $result = mysql_query($query);
    
    // HTML markup generation
    echo "<table>\n";
    while ($line = mysql_fetch_array($result, MYSQL_ASSOC)) {
        echo "\t<tr>\n";    
        foreach ($line as $col_value) {
            echo "\t\t<td>$col_value</td>\n";
        }
        echo "\t</tr>\n";
    }
    echo "</table>\n";
?>
    \end{pyglist}
\caption{Использование нескольких встроенных в PHP языков (MySQL, HTML)}
\label{lst:PhPSqlHtml}
\end{listing}


Несмотря на развитие метапрограммирования, техник порождающего программирования (generative programming), ORM-технологий, использование в языках программирования динамически формируемых строковых 
выражений все еще широко распространено. Популярность такого подхода связана также с тем, что выполнение динамически формируемых строк требует существенно меньших накладных расходов, чем применение, 
например, ORM, что позволяет существенно улучшить производительность системы.

Однако использование динамически формируемых строковых выражений сопряжено с рядом трудностей. Их конструирование часто происходит с применением конкатенации в циклах, ветках условных операторов или 
рекурсивных процедурах и их композициях, что порождает множество различных значений для каждого выражения в момент выполнения. При этом фрагменты кода на встроенных языках воспринимаются компилятором 
исходного языка как простые строки, не подлежащие дополнительному анализу. Таким образом, стандартные средства не позволяют проводить даже простой синтаксический анализ динамически формируемых выражений. 
Невозможность статической проверки корректности формируемого выражения приводит к высокой вероятности возникновения ошибок во время выполнения программы. В худшем случае такая ошибка не приведет к прекращению 
работы приложения, что указало бы на проблемы, однако целостность данных при этом может оказаться нарушена. Более того, использование динамически формируемых выражений затрудняет как разработку информационных 
систем, так и реинжиниринг уже созданных. Распространённой практикой при написании кода является использование интегрированных сред разработки, производящих подсветку синтаксиса и автодополнение, 
сигнализирующих о синтаксических ошибках, предоставляющих возможность проводить рефакторинг кода. Такая функциональность значительно упрощает процесс разработки и отладки приложений и её реализация не 
только для основного языка, но и для встроенных языков будет полезной для разработчиков. Для задач реинжинирига важно иметь возможность изучать систему и модифицировать её, сохраняя функциональность. 
Наличие динамически формируемых выражений затрудняет решение данных задач. Например, при наличии встроенного SQL нельзя точно ответить на вопрос о том, с какими элементами базы данных не взаимодействует система, 
и  удалить их, не проанализировав все динамически формируемые выражения. При переносе такой системы на другую СУБД необходимо гарантировать, что для всех динамически формируемых выражений значение в момент 
выполнения будет корректным кодом на языке новой СУБД, что требует трансляции встроенных запросов~\cite{Syrcose}. 

Решение большинства перечисленных выше задач требует проведения синтаксического анализа. Более того, многие задачи требуют не только ответа на вопрос принадлежности некоторому языку всех генерируемых 
программой предложений, но и построения леса разбора. Так как множество значений выражения может быть бесконечным и сами предложения могут быть бесконечными, то проведение анализа наивным образом с явным 
построением леса разбора невозможно. Данная проблема затрагивается в исследованиях Kyung-Goo Doh~\cite{AbstrParsing, LRAbstrParsing, LRAbstrParsingSema}, в которых предлагается комбинация анализа потока данных и синтаксического анализа на основе LR-алгоритма. 
В работах поднимается вопрос семантического анализа встроенных языков и предлагается использовать классический для LR-анализа механизм атрибутных грамматик, однако, опускается вопрос ресурсоёмкости данного 
подхода при нетривиальном анализе. Вместе с тем, в работах А. Бреслава~\cite{Alvor1, Alvor2} рассматривается подход, основанный на построении регулярной аппроксимации множества возможных значений динамически формируемых 
выражений и последующем анализе с использованием обобщённого LR-алгоритма. Однако этот вопрос изучен не полностью: не рассмотрено хранение результатов разбора с использованием сжатого представления леса 
вывода и повышение эффективности самого синтаксического анализа при полном использовании структурированного в виде графа стека и механизмов управления им.

В данной работа представлен алгоритм синтаксического анализа произвольного регулярного множества, основанный на механизмах обобщённого синтаксического LR-анализа. В результате анализа строится компактная 
структура данных, содержащая деревья разбора всех элементов множества, для которых возможен вывод, пригодная для дальнейшего семантического анализа.