\documentclass{mais}
\usepackage{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[mag=1000,a4paper,left=2.2cm,right=3.0cm,top=3.0cm,bottom=3.0cm]{geometry} % ,noheadfoot
\usepackage{graphicx}
\usepackage{amsfonts,amssymb,amscd,amsmath,amsthm}
\usepackage{mathrsfs}
\usepackage{epsf}
\usepackage{wrapfig}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{epstopdf}

%% поля, заполняемые редакцией
\date{20 декабря}\ydate{2012}%дата получения
\firstpage{5}%начальная страница статьи


%% поля, заполняемые автором
\title{Инструментальная поддержка встроенных языков в интегрированных средах разработки}

\author{Григорьев~С.\,В.\footnote{Работа выполнена при финансовой поддержке гранта ... }}%Фамилия И.О. автора, ссылки на поддержку
\authorcr{Григорьев~С.\,В.} %Фамилия И.О. автора для строки с авторским знаком

\UDC{517.9} %Номер УДК
\shorttitle{Краткое название статьи для колонтитула}
\entitle{English Title}%Название статьи на английском языке. Каждое значимое слово пишется с большой буквы
\enauthor{Grigorev~S.\,V.}


\affiliationen {\small P.G.~Demidov Yaroslavl State University, Sovetskaya str., 14, Yaroslavl, 150000, Russia}

\affiliation{\small Ярославский государственный университет  им.~П.\,Г.~Демидова\\150000 Россия, г. Ярославль, ул. Советская, 14}
%указывается официальное название места работы и официальный почтовый адрес
%%%%% места работы двух и более авторов разделяются знаком "\\ "
\email{ivanov@mail}

%информация об авторах
\authorinform{\\{\textbf{Иванов Иван Иванович}}, \\Ярославский государственный университет им.~П.Г.~Демидова,\\
канд. физ.-мат. наук, доцент
}

\keywords{аттрактор,  бифуркация}
\enkeywords{attractor, bifurcation}

\enabstract{
Complex information systems are often implemented using more than one programming language. Sometimes this variety takes form of one host and one or few string-embedded languages. Textual representation of clauses in a string-embedded language is built at run time by a host program and then analyzed, compiled or interpreted by a dedicated runtime component (database, web browser etc.) Most general-purpose programming languages may play role of the host; one of the most evident examples of string-embedded language is dynamic SQL which was specified in ISO SQL standard and is supported by the majority of DBMS. Standard IDE functionality such as code completion or syntax highlighting can really helps developers who use this technique. There are several tools providing this functionality, but they all process only one concrete string-embedded language and cannot be easily extended for supporting other language. We present a platform which allows to easily create tools for string-embedded language processing. We also demonstrate a plug-in for ReSharper based on this platform which provides code highlighting and static errors checking for string-embedded languages in C\# (TSQL, JSON). 
}%Аннотация на английском языке, соответствующая аннотации на русском языке, объем не менее 12-15 строк формата нашего журнала (необходимое требование для международных баз данных)


%%%%Макросы необходимые автору
\def\W{\overset{\circ}{W}}
\newcommand{\ve}{\varepsilon}
\newcommand{\eps}{\varepsilon}

\renewcommand{\Re}{\operatorname{Re}}
\renewcommand{\Im}{\operatorname{Im}}

\newtheorem{theor}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{dfn}{Определение}
%%%%%Макросы необходимые автору

\begin{document}
\maketitle

\begin{abstract}
%Подробная аннотация, сжато отражающая содержание статьи. Объем аннотации - не менее 12-15 строк формата нашего журнала (необходимое требование для международных баз данных)
Complex information systems are often implemented using more than one programming language. Sometimes this variety takes form of one host and one or few string-embedded languages. Textual representation of clauses in a string-embedded language is built at run time by a host program and then analyzed, compiled or interpreted by a dedicated runtime component (database, web browser etc.) Most general-purpose programming languages may play role of the host; one of the most evident examples of string-embedded language is dynamic SQL which was specified in ISO SQL standard and is supported by the majority of DBMS. 

Standard IDE functionality such as code completion or syntax highlighting can really helps developers who use this technique. There are several tools providing this functionality, but they all process only one concrete string-embedded language and cannot be easily extended for supporting other language. We present a platform which allows to easily create tools for string-embedded language processing. We also demonstrate a plug-in for ReSharper based on this platform which provides code highlighting and static errors checking for string-embedded languages in C\# (TSQL, JSON).
\end{abstract}





\section*{Введение}\label{s1}

Часто при разработке сложных программных систем используется более, чем один язык программирования. В таком случае принято говорить об основном (или исходном) языке и одном или нескольких встроенных языках. Из строковых выражений основного языка динамически формируются программы на отличном от него языке, которые потом интерпретируются специальными, работающими во время исполнения, компонентами, такими как базы данных или веб-браузеры. Большинство языков программирования общего назначения могут играть роль как основного, так и встроенного языка. Ниже приведены примеры использования встроенных языков.
Код с использованием динамического SQL:

\begin{verbatim}
CREATE PROCEDURE [dbo].[MyProc]  @TABLERes   VarChar(30)
AS
EXECUTE ('INSERT INTO ' + @TABLERes + ' (sText1)' +
' SELECT ''Additional condition: '' + sName' +
' from #tt where sAction = ''1000000''')
GO
\end{verbatim}

Использование нескольких встроенных в PHP языков (MySQL, HTML) 

\begin{verbatim}
<?php
$query = 'SELECT * FROM '. $my_table; // Embedded SQL
$result = mysql_query($query);
// HTML markup generation
echo "<table>\n";
while ($line = mysql_fetch_array($result, MYSQL_ASSOC)) {
echo "\t<tr>\n";	
foreach ($line as $col_value) {
echo "\t\t<td>$col_value</td>\n";}
echo "\t</tr>\n";}
echo "</table>\n";?>
\end{verbatim}

Встроенные языки позволяют компенсировать недостаток выразительности языков общего назначения в случае использования их в контексте специфичном для предметной области. Однако использование такого подхода сопряжено с рядом трудностей. Динамически формируемые выражения обычно конструируются из строковых констант и выражений основного языка посредством конкатенации в циклах, ветках условных операторов или рекурсивных процедурах, причем эти структуры могут вкладываться друг в друга, что порождает множество различных вариантов. Фрагменты кода на встроенных языках воспринимаются компилятором исходного языка как простые строки, не подлежащие анализу. Таким образом, стандартные средства не позволяют проводить даже простой синтаксический анализ динамически формируемых выражений. Невозможность статической проверки корректности формируемого выражения приводит к высокой вероятности возникновения ошибок во время выполнения программы.

Распространенной практикой при написании кода является использование интегрированных сред разработки, производящих подсветку синтаксиса и автодополнение, сигнализирующих о синтаксических ошибках, предоставляющих возможность проводить рефакторинг кода. Все эти функции значительно упрощают процесс разработки и отладки приложений. Полезными могут оказаться инструменты, проводящие статический анализ множества выражений, которые динамически формируются из строковых выражений основного языка во время выполнения программы. Данный процесс назовем статическим анализом динамически формируемых выражений или абстрактным анализом.

В рамках исследовательского проекта YaccConstructor[1], посвященного проведению экспериментов в области синтаксического анализа, ведется работа над платформой для создания инструментов, предназначенных для статического анализа кода на встроенных языках. В данной статье описаны разрабатываемая инфраструктура поддержки встроенных языков и ее компоненты: генераторы абстрактных лексических и синтаксических анализаторов. Также уделено внимание поддержке многих языков и приведен пример использования платформы для создания плагина к ReSharper[2] (плагин к Microsoft Visual Studio [3], расширяющий стандартные средства IDE), позволяющего анализировать динамически формируемые выражения.



\section{Платформа}

Существующие инструменты для работы со встроенными языками реализуют поддержку какого-то одного конкретного языка и поддержка нового языка может потребовать нетривиального ручного вмешательсьва, но намного удобнее было бы получить поддержку встроенного языка без изменений в исходном коде. Для этого необходимо, с одной стороны, предоставить механизм для простой реализации поддержки нового языка и интеграции его в систему, с другой  --- дать пользователю возможность указывать в исходном коде строки, соответствующие конкретным встроенным языкам.


\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.6]{picture/Structure_of_platform}
    \end{center}
    \caption{(1)Зависимость модулей}
    \label{moduleDepence}
\end{figure} 

На рисунке 1 представлена общая структура платформы. Она состоит из следующих модулей.
TSQL, JSON - модули, реализующие поддержку встроенных языков. Каждый из таких модулей реализует общий интерфейс, позволяющий унифицировано подключать поддержку нового языка. 

Common содержит интерфейс для парсеров и атрибут InjectedLanguage, позволяющий указывать встроенный язык для строковых выражений. Например, если код помечен атрибутом [InjectedLanguage (“SQL”)], то соответствующие строковые выражения являются кодом на  языке SQL.
Core обеспечивает связь плагина с модулями, реализующими встроенные языки.




\subsection{Анализ встроенных языков}
Для синтаксического анализа обобщённого представления множества строк, таких как data-flow уравнение, регулярное выражение, существует алгоритм абстрактного синтаксического анализа [4]. Часто удобно считать, что компактное представление описывается с помощью графа, где на дугах содержатся терминальные символы (токены), а вершины соответствуют случаям конкатенации строк в процессе формирования запроса. Например, пусть обрабатывается следующий код, формирующий и выполняющий динамический запрос.

\begin{verbatim}
IF @X = @Y
SET @TABLE = '#tbl1'
ELSE SET @TABLE = 'tbl2'
SET @S = 'SELECT x FROM ' + @TABLE
EXECUTE (@S)
\end{verbatim}

Переменная @S, содержащая динамически формируемый запрос, может принимать два значения в точке выполнения запроса. После обработки этого кода множество значений переменной @S в точке выполнения может быть представлено графом, показанным на рисунке 2. 

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.95]{picture/SimpleSql.eps}
    \end{center}
    \caption{(2)Входной граф для лексического анализатора, построенный по коду из примера 1}
    \label{codeEx}
\end{figure}
 
Граф, полученный в результате применения к нему процедуры токенизации или абстрактного лексического анализа, показан на рисунке 3.

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.65]{picture/simple_sql.eps}
    \end{center}
    \caption{(3)Граф для динамического запроса из примера}
    \label{codeExGraph}
\end{figure}

Следующий шаг  --- абстрактный синтаксический анализ, который основан на идее переиспользования управляющих конструкций из классического синтаксического анализа и реализации специального механизма их интерпретации. По описанию синтаксиса анализируемого языка генерируются управляющие таблицы для анализатора. Интерпретатор таблиц (LR-автомат) при этом модифицируется таким образом, чтобы вычислять все возможные состояния синтаксического анализатора для каждой вершины графа [5]. 
Рассмотрим пример. Пусть задана следующая грамматика:

\begin{verbatim}
s -> Ae
e -> BD | CD
\end{verbatim}

На вход построенному по данной грамматике анализатору подаётся граф, представленный на рисунке 4.

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.9]{picture/simple_grammar_inpt.eps}
    \end{center}
    \caption{(4) Пример входного графа}
    \label{inputExGraph}
\end{figure}

Во время синтаксического анализа будет вычислено множество состояний анализатора в каждой вершине графа (Fig.5).

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.9]{picture/simple_grammar_items.eps}
    \end{center}
    \caption{(5) Состояния парсера для графа, представленного на Fig. 4}
    \label{StateInputExGraph}
\end{figure}


Несмотря на то, что уже существуют реализации инструментов для работы с динамически формируемыми выражениями в конкретных языках, хорошо показавшие себя на практике (например, Java String Analyzer [6], Alvor [7] или PHP String Analyzer [8]), отдельного внимания заслуживает вопрос обобщения лексического анализа и синтаксического разбора, используемых в таких инструментах, с целью создания генератора абстрактных анализаторов.  Кроме того, при промышленной разработке инструментов лексического и синтаксического анализа для языков программирования уже стали традиционными инструменты, позволяющие автоматически генерировать соответствующие анализаторы по спецификациям обрабатываемого языка. В области автоматизации разработки подобных инструментов для абстрактного анализа также получены результаты [11], но они требуют доработки.


\subsection{Генератор лексических анализаторов}

Абстрактный лексический анализатор основан на конечном преобразователе (finite-state transducer [9]). Это конечный автомат, который может выводить конечное число символов для каждого входного символа. В нашем инструменте преобразователь, используя сгенерированное описание автомата, переводит входной граф в граф, содержащий соответствующие спецификации токены. В ходе процесса токенизации сохраняется привязка частей динамически формируемого выражения к исходному коду и привязка лексических единиц внутри каждой части, которая понадобится при дальнейшем разборе полученного графа и при выдаче сообщений о лексических ошибках.

В отличие от классического анализа в абстрактном лексическом анализе бывают ситуации с “рваными” лексическими единицами, то есть случаи, когда токен находился на двух и более ребрах входного графа. Такое возможно, например, когда токен конструируется при помощи условного выражения. На рисунке 6 представлен граф, содержащий “рваные” литералы.

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.85]{picture/sLiterals.eps}
    \end{center}
    \caption{(6) Входной граф, содержащий “рваные” литералы}
    \label{InputGraph}
\end{figure}


Результат лексического анализа, проведённого с помощью реализованного инструмента, представлен на рисунке 7. 

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.9]{picture/sLiterals_lex.eps}
    \end{center}
    \caption{(7) Результат лексического анализа для графа, представленного на рисунке 6}
    \label{LexerGraph}
\end{figure}


\subsection{Генератор синтаксических анализаторов}

В рамках проекта YaccConstructor реализован генератор  синтаксических анализаторов [1], основанный на RNGLR-алгоритме[12], который является модификацией классического GLR-алгоритма, поддерживающей работу с произвольными КС-грамматиками. Важной особенностью данной реализации является построение легковесного внутреннего представления результатов,  над которым после завершения разбора выполняется вычисление пользовательской семантики. Это позволяет не производить лишних вычислений. Например, после получения промежуточного результата пользователь может выбрать только одно дерево и вычислять семантику только для него. Кроме этого, часть вычислений может оказаться ненужными, если они производились в ветке стека, которая впоследствии окажется ошибочной. Поэтому  использование данной  структуры позволяет ускорить абстрактный анализ. 

При обработке графов в RNGLR-алгоритме в момент разветвления возникает ситуация, аналогичная классическим конфликтам Shift/Reduce и Reduce/Reduce, когда необходимо выполнять анализ по нескольким путям. В данном случае необходимость ветвления вызвана тем, что существует несколько вариантов для операции Shift.  Ситуация не является классическим конфликтом, но по аналогии мы будем называть такие ситуации Shift/Shift конфликтами. В алгоритм анализа внесена возможность обработки таких ситуаций. 

\subsubsection{Обнаружение ошибок и восстановление после них}

GLR-алгоритмы предназначены для анализа неоднозначных грамматик и оперируют со структурированным в виде графа стеком который разветвляется при возникновении конфликтов. Если в процессе работы анализатора для некоторого состояния, лежащего на верхушке стека, невозможно сделать ни одного действия, то соответствующую ветку стека считают ошибочной и отбрасывают. В классическом GLR-алгоритме анализа ошибка диагностируется в момент, когда все вершины стека оказываются отброшены. Для абстрактного синтаксического анализатора такой подход верен не всегда. Ветви стека в абстрактном анализе соответствуют не только неоднозначностям грамматики, но и ветвлениям во входном графе, поэтому данная ситуация может сигнализировать об ошибке в одном из входных выражений. Результат классического GLR-алгоритма всегда является либо корректным лесом разбора, либо ошибкой. В абстрактном GLR-алгоритме необходимо возвращать как сокращенное представление леса разбора, содержащее деревья разбора для всех корректных входных выражений, так и список ошибок в случае их возникновения.

В рамках платформы был реализован механизм восстановления после ошибок для классического RNGLR-алгоритма [10]. Однако вопрос о необходимости восстановления после ошибок в абстрактном анализе необходимо исследовать отдельно, так как  он может порождать слишком большое количество ложных ошибок для сложных выражений. Также необходимо оценить уменьшение производительности и выявить проблемы, связанные с переходом к абстрактному. 

\subsubsection{Особенности вычисления семантики}

Для обеспечения такой функциональности, как подсветка и автодополнение, не достаточно только лишь информации о синтаксической корректности выражений. Необходима также работа с семантическими значениями языковых конструкций. При этом далеко не всегда нужно рассматривать все деревья разбора. При подсветке синтаксиса, например,  достаточно выбрать из леса разбора подмножество корректных деревьев таким образом, чтобы множество всех токенов (листьев) было покрыто. То есть, чтобы для каждого токена существовало дерево из выбранного подмножества, которое содержит этот токен. Действительно, если у двух разных деревьев листья совпадают, то при подсветке синтаксиса не так важно, какому именно дереву принадлежит тот или иной лист. Важно, что это дерево синтаксически корректно.

Рассмотрим пример:
\begin{verbatim}
expr: (expr PLUS expr) | NUM
\end{verbatim}

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.8]{picture/shiftreduce.eps}
    \end{center}
    \caption{(8) Граф, содержащий Shift/Reduce конфликт}
    \label{InputGraph}
\end{figure}

Для данного графа в результате синтаксического разбора будет построено четыре дерева разбора: для каждого пути будет построено по два дерева из-за неоднозначности грамматики. Однако порождённые конфликтом Shift/Reduce или Reduce/Reduce деревья соответствуют одному и тому же пути в графе, а значит, множества их листьев совпадают. Поэтому при поддержке подсветки синтаксиса для каждого пути в графе достаточно рассмотреть только одно из таких деревьев. Наиболее сложной для реализации поддержки языков является ситуация, соответствующая ветвлению во входном графе, так как в худшем случае придётся рассматривать все возможные деревья разбора.

В рамках проекта создан генератор, который создаёт семантику для подсветки синтаксиса языка. Также он генерирует конфигурационный файл, в котором пользователь может указать, в какой цвет окрашивать ту или иную языковую конструкцию. 

\section{Дальнейшее развитие}

В дальнейшем планируется как развитие платформы, так и плагина. На уровне платформы необходимо реализовать механизмы, требующиеся для трансформаций кода на встроенных языках. Планируется реализация проверки корректности типов. Для SQL это должна быть как проверка типов внутри запроса, так и проверка того, что тип возвращаемого запросом результата соответствует типу хост-переменной, выделенной для сохранения результата в основном коде.

{\small
\begin{thebibliography}{99}%Пример оформления списка литературы. Для публикаций на русском языке в скобках приводится вариант на англ. языке, если есть (см. Пример 4) или транслитерация (см. Пример 5).

\bibitem{bib_1} \emph{Nicolis G., Prigogine I.}  Self-Organization in Non-Equilibrium Systems.  Wiley, 1977.

\bibitem{Lorenz_63} \emph{Lorenz E.N.} Deterministic nonperiodic flow // J. Atmos. Sci. 1963.  V.~20.  P.~130--141.

\bibitem{Kuramoto_1978} \emph{Kuramoto Y.}  Diffusion-Induced Chaos in Reaction Systems //
Prog. Theor. Phys. Supplement. 1978.  No.~64(1978).  P. 346--367. DOI : 10.1143/PTPS.64.346.

\bibitem{gl_20} \emph{Глызин С.\,Д.} Сценарии фазовых перестроек одной конечноразностной
модели уравнения ``реакция-диффузия''  // Дифференциальные уравнения.  1997. Т.~33, \No~6.~С.~805--811.
(English transl.:  \textit{Glyzin S. D.} Dynamic properties of the simplest finite-difference approximations of the "reaction-diffusion'' boundary value problem // Differential Equations. 1997. V.~33, No.~6. P.~808–814.)

\bibitem{2}  \textit{Ахромеева Т.С., Курдюмов С.П., Малинецкий Г.Г.,
Самарский  А.А.} Структуры и хаос в нелинейных средах.
М.: Физматлит, 2007.
(\textit{Ahromeeva T.S., Kurdyumov S.P., Malinetskiy G.G., Samarskiy A.A } Struktury i haos v nelineynyh sredah. Moskva: Fizmatlit, 2007 [in Russian].)


\end{thebibliography}}
\medskip
\end{document}



