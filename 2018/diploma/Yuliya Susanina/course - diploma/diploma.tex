% Тут используется класс, установленный на сервере Papeeria. На случай, если
% текст понадобится редактировать где-то в другом месте, рядом лежит файл matmex-diploma-custom.cls
% который в момент своего создания был идентичен классу, установленному на сервере.
% Для того, чтобы им воспользоваться, замените matmex-diploma на matmex-diploma-custom
% Если вы работаете исключительно в Papeeria то мы настоятельно рекомендуем пользоваться
% классом matmex-diploma, поскольку он будет автоматически обновляться по мере внесения корректив
%

% По умолчанию используется шрифт 14 размера. Если нужен 12-й шрифт, уберите опцию [14pt]
\documentclass[14pt]{matmex-diploma}
%\documentclass[14pt]{matmex-diploma-custom}

% Package to generate and customize Algorithm as per ACM style
\usepackage[ruled, linesnumbered]{algorithm2e}
\renewcommand{\algorithmcfname}{Алгоритм}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

\usepackage{listings}
\usepackage{amsmath}
\usepackage[amsmath,amsthm,thmmarks]{ntheorem}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{minted}
\usepackage{verbments}
\usepackage{caption}
\usepackage{algorithmicx}
\usepackage{amssymb}
\usepackage{tikz} 
\usepackage{pgfplots} 
\usepackage{sidecap} 
\usepackage{soul}
\usepackage{xcolor}
\usepackage{tabu}
\usepackage{float}


\begin{document}

\renewcommand{\lstlistingname}{Листинг}
\renewcommand\listingscaption{Листинг}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра системного программирования},
    title              = {Распараллеливание алгоритмов синтаксического анализа, основанных на матричных операциях},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {coursework},
    position           = {студентка},
    group              = 344,
    author             = {Сусанина Юлия Алексеевна},
    supervisorPosition = {к.\,ф.-м.\,н., доцент},
    supervisor         = {Григорьев С.\,В.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
   city               = {Санкт-Петербург},
   year               = {2018}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
Синтаксический анализ --- это процесс определения принадлежности некоторой последовательности лексем языку, порождаемому грамматикой. Его классической областью применения является изучение преобразований языков программирования, а именно разбор исходного кода в процессе трансляции (компиляции или интерпретации). В последнее время синтаксический анализ стал применяться для исследования последовательностей ДНК и РНК в биоинформатике~\cite{RNA}. Например, для определения принадлежности организма какому-либо семейству можно использовать его вторичную структуру рРНК~\cite{secRNA}, которая описывается с помощью некоторой грамматики. Более того, из-за больших объемов данных от синтаксического анализа требуется высокая производительность, которой  можно добиться с помощью использования параллелизма.

Алгоритм синтаксического анализа Валианта~\cite{val}, работающий с\linebreak контекстно-свободными грамматиками, который позднее был расширен А.С.Охотиным до семейства булевых грамматик~\cite{okh}, является одним из наиболее подходящих решений для таких задач. Данный алгоритм строит матрицу разбора, элементы которой отвечают за выводимость конкретной подстроки. Валиант добился существенного увеличения производительности алгоритма за счет переноса большей части вычислений на перемножение подматриц исходной матрицы, которое позволяет эффективно использовать параллельные архитектуры. Основной недостаток этого алгоритма --- сложность разделения его на независимые потоки, которые могли бы оперировать различными матрицами.

На кафедре системного программирования в лаборатории языковых инструментов  была предложена модификация алгоритма \linebreak А.С.Охотина~\cite{alg}, которая частично решает эту проблему и позволяет использовать параллелизм как на уровне матричных операций, так и за счет распараллеливания вычислений для целых массивов подматриц. Однако реализация данного алгоритма отсутствует.


\section{Постановка задачи}
Целью данной работы является исследование и реализация модифицированного алгоритма А.С. Охотина. Для достижения цели были поставлены следующие задачи: 
\begin{itemize}
\item реализовать модифицированный алгоритм, а также исходный алгоритм А.С. Охотина;
\item дать теоретическую оценку эффективности использования параллельных вычислений в модифицированном алгоритме;
\item провести экспериментальное исследование модифицированного алгоритма.
\end{itemize}

\section {Обзор}
В этом разделе будут кратко описаны алгоритмы синтаксического анализа, рассматриваемые в рамках данной работы, а также проект YaccConstruсtor, с помощью которого эти алгоритмы реализуются.
 
\subsection {Синтаксический анализ, основанный на  матричных операциях}

Задача синтаксического анализа --- это проверка принадлежности строки $a_{1}...a_{n}$ языку, определенному некоторой грамматикой \linebreak $G = (\Sigma, N, R, S)$, где $\Sigma$, N --- алфавиты терминалов и нетерминалов соответственно, R --- конечное множество правил, S $\in$ N --- стартовый нетерминал.

$\textbf{Определение 1. }$
    Пусть $L_{G}(A)$ --- это язык, заданный грамматикой $G_{A} = (\Sigma, N, R, A)$.

Представленный далее алгоритм Валианта~\cite{val} работает с контекстно-свободными грамматиками в нормальной форме Хомского и строит верхнетреугольную матрицу размера $n \times n$ для конкретной строки $a_{1}...a_{n}$, где n --- длина входной строки. Ее элементами являются множества нетерминалов и отвечают за выводимость конкретной подстроки \linebreak $$T[i,j] = \{ {A \in N | a_{i+1}...a_{j} \in L_{G}(A)} \}$ для $ 0 \leq i < j \leq n $.

Элементы данной матрицы вычисляются, начиная с \linebreak $T[i - 1, i] = \{A | A \rightarrow a_{i} \in R\}$. 

Затем заполняются остальные элементы $$T[i,j] = f(P[i,j]),$ где $P[i, j] =$ {\small$\bigcup\limits_{k = i + 1}^{j - 1} T[i,k] \times T[k, j]$}, а $f(P) = \{A | \exists A \rightarrow BC \in R : (B, C) \in P\}$.

Таким образом, для определения принадлежности строки языку, заданному грамматикой G, необходимо, чтобы стартовый нетерминал S содержался в $T[0, n]$.


Самой трудоемкой операцией в приведенном выше алгоритме является вычисление $P[i,j]$. За счет изменения порядка вычислений Валианту~\cite{val} удалось улучшить алгоритм так, чтобы большая часть вычислений выполнялась с помощью перемножения двух максимально возможных матриц, что заметно увеличило скорость работы алгоритма. \linebreak

% Algorithm1
\begin{algorithm}
\SetAlgoNoLine
\KwIn{Булева грамматика в нормальной форме $G = (\Sigma, N, R, S), w = a_{1}...a_{n}, n \geq 1, a_{i} \in \Sigma$, где n + 1 --- степень двойки}

\underline{main()}{:}{
 
 \textit{compute(0, n + 1)\;}
 accept if and only if $S \in T_{0, n}$
 \linebreak
 }
 
\underline{compute(\textit{l, m})}{:}{

 \If {$m - l \geq 4$}{
     \textit{compute(l, $\frac{l+m}{2}$)\;
     compute($\frac{l+m}{2}$, m)}}
 \textit{complete(l, $\frac{l+m}{2}$, $\frac{l+m}{2}$, m)}
 \linebreak
 }
 
\underline{comlete(\textit{l, m}, $l^\prime$, $m^\prime$)}{:}{

 \If {$m - l = 4$ and $m = l^\prime$}{$T_{l, l + 1} = \{A | A \rightarrow a_{l+ 1} \in R\}$\;}
 \ElseIf{$m - l = 1$ and $m < l^\prime$}{ $T_{l, l'} = f(P_{l, l'})$\;}
 \ElseIf{$m - l > 1$}{
    $B = (l, \frac{l+m}{2}, \frac{l'+m'}{2}, m'), B' = (\frac{l+m}{2}, m, l', \frac{l'+m'}{2}),\linebreak
    C = (\frac{l+m}{2}, m, l', \frac{l'+m'}{2}), D = (l, \frac{l+m}{2}, l', \frac{l'+m'}{2}),\linebreak
    D' = (\frac{l+m}{2}, m, \frac{l'+m'}{2}, m'), E = (l, \frac{l+m}{2}, \frac{l'+m'}{2}, m')$\;
    complete(C)\;
    $P_{D} = P_{D} \cup (T_{B} \times T_{C})$\;
    complete(D)\;
    $P_{D'} = P_{D'} \cup (T_{C} \times T_{B'})$\;
    complete(D')\;
    $P_{E} = P_{E} \cup (T_{B} \times T_{D'})$\;
    $P_{E} = P_{E} \cup (T_{D} \times T_{B'})$\;
    complete(E)
    }
 }
  \textit{complete(l, $\frac{l+m}{2}$, $\frac{l+m}{2}$, m)}
 }
 
\caption{Синтаксический анализ, основанный на матричных операциях (алгоритм Охотина)}
\end{algorithm}

Асимптотическая сложность алгоритма составляет \linebreak
    $O(|G|MM(n)log(n))$, где n --- длина входной строки, |G| --- размер входной грамматики, MM(n) --- количество операций необходимых для перемножения двух матриц размера n $\times$ n. 

$\textbf{Определение 2. }$
    Обозначим $(l, m, l', m')$ подматрицу матрицы $n \times n$, такую что $l \leq i < m$ и $l' \leq j < m'$.
    

Алгоритм Валианта был позже упрощен Александром Охотиным~\cite{okh}, что позволило ему работать в более общем случае, а именно, для конъюнктивных и булевых грамматик (Листинг 1).

Однако, как следует из определения функции $\textit{complete}$, за один вызов данной функции перемножается только одна пара матриц, что накладывает определенные ограничения на его параллельную реализацию, и представленная далее модификация позволяет частично снять это ограничение.


\subsection {Модифицированный алгоритм}

В данном разделе рассматривается модификация алгоритма Охотина~\cite{alg}. 

Функция $\textit{completeLayer}$ (строки 11-21 алгоритма 2) почти аналогична функции $\textit{complete}$ исходного алгоритма (строки 10-28 алгоритма 1). Однако она допускает одновременное независимое перемножение массивов матриц. Это достигается путем разбиения первоначальной матрицы на слои подматриц меньшего размера (функция constructLayer строки 9-10 алгоритма 2) и реорганизации вычислений. 

С этими изменениями появляется возможность использования параллелизма на уровне слоев подматриц(строки 26-28, 29, 31-32 алгоритма 2), что должно положительно сказаться на эффективности работы алгоритма.\\


% Algorithm1
\begin{algorithm}[!h]
\SetAlgoNoLine
\KwIn{Булева грамматика в нормальной форме $G = (\Sigma, N, R, S), w = a_{1}...a_{n}, n \geq 1, a_{i} \in \Sigma$, где n + 1 --- степень двойки}

\underline{main()}{:}{
 
 \For {$l \in \{1, \ldots, n \}$}{$T_{l, l + 1} = \{A | A \rightarrow a_{l+ 1} \in R\}$}
 \For{$1 \le i < k $}{
 layer = $\textit{constructLayer(i)}$\;
 \textit{completeVLayer(layer)}
 }
 \BlankLine
 }
 
\underline{constructLayer(i)}{:}{
 \BlankLine
 $\{B | \exists k \geq 0 : B = (1 + k*2^i, 2^i - 1 + k*2^i, 2^i + k * 2^i, 2^{i + 1} + k * 2^i) \}$
 \BlankLine
    }
\underline{completeLayer(M)}{:}{
\BlankLine
\If {$\forall (l, m, l', m') \in M \quad (m - l = 1)$}{\For{$ (l, m, l', m') \in M$}{$T_{l, l'} = f(P_{l, l'})$\;}}
\Else{
bottomLayer =  $\{ (\frac{l+m}{2}, m, l', \frac{l'+m'}{2}) | (l, m, l', m') \in M\}$\;
\textit{completeLayer(bottomLayer)}\;
\textit{completeVLayer(M)}
}
\BlankLine
}
 
\underline{comleteVLayer(M)}{:}{
 \BlankLine
 leftSubLayer = $\{ (l, \frac{l+m}{2}, l', \frac{l'+m'}{2}) | (l, m, l', m') \in M\}$\;
 rightSubLayer = $\{ (\frac{l+m}{2}, m, \frac{l'+m'}{2}, m') | (l, m, l', m') \in M\}$\;
 topSubLayer = $\{ (l, \frac{l+m}{2}, \frac{l'+m'}{2}, m') | (l, m, l', m') \in M\}$\;
 multiplicationTask1 = $\{(l, m, l', m'), (l, m, m + 1, m' - m - l' + 1), (m, 2*m - 1, l', m') | (l, m, l', m') \in leftSubLayer\} \cup  \{(l, m, l', m'), (l, m, 2*l' - m', l'), (l + l' - m - 1, l' - 1, l', m') | (l, m, l', m') \in rightSubLayer\}$\;
 \BlankLine
 multiplicationTask2 = $\{(l, m, l', m'), (l, m, m + 1, m' - m - l' + 1), (m, 2*m - 1, l', m') | (l, m, l', m') \in topSubLayer\}$\;
 \BlankLine 
 multiplicationTask3 = $\{(l, m, l', m'), (l, m, 2*l' - m', l'), (l + l' - m - 1, l' - 1, l', m') | (l, m, l', m') \in topSubLayer\}$\;
 \BlankLine
 \textit{performMultiplications(multiplicationTask1)}\;
 \textit{completeLayer(leftSubLayer $\cup$ rightSubLayer)}\;
 \textit{performMultiplications(multiplicationTask2)}\;
 \textit{performMultiplications(multiplicationTask3)}\;
 \textit{completeLayer(topSubLayer)}
 

 }
 
\caption{Модифицированный алгоритм}
\end{algorithm}



\subsection{Проект YaccConstruсtor}

Реализация и тестирование данных алгоритмов проводятся в рамках проекта YaccConstructor~\cite{YC}, разрабатываемого на кафедре cистемного программирования~\cite{sp} в лаборатории языковых инструментов~\cite{jet} СПбГУ. YaccConstructor является платформой для исследований в области синтаксического анализа, разработанной на языке \texttt{F\#}. \newpage

\section{Реализация алгоритмов}
\BlankLine
Алгоритм А.С.Охотина и его модификация, рассмотренные в предыдущей главе были реализованы в рамках исследовательского проекта YaccConstructor. В данном разделе описываются детали практической реализации.

Одной из задач данной работы было исследование возможностей новой версии алгоритма, поэтому было решено реализовать оба алгоритма, чтобы затем уже сравнить их производительности на практике. Предполагается увидеть выигрыш в скорости работы модификации, который связан с возможностью, в отличии от исходного алгоритма,  независимого перемножения большого количества пар матриц.
\BlankLine

Алгоритмы были реализованы на платформе .NET на языке программирования \texttt{F\#}.

В проекте используется язык описания грамматик YARD, которые перед запуском алгоритма преобразуются в нормальную форму Хомского. Все необходимые преобразования ранее уже были реализованы в проекте YaccConstructor. 

Рассмотрим представление матриц T и P в реализуемых алгоритмов. На практике данные матрицы можно представить в виде нескольких булевых матриц, где каждой булевой матрице $T_A$ соответствует нетерминал A входной грамматики G и матрице  $P_{BC}$ --- пара нетерминалов (В,С). Таким образом, значения в ячейках теперь задаются следующим образом.

$T[i, j] = \{ A \in N | T_A[i, j] = 1\}$;

$P[i, j] = \{ (B,C) \in N\times N | P_{BC}[i, j] = 1\}$

Это позволяет работать с числовыми значениями, а не с множествами нетерминалов.

Теперь каждый вызов функции performMultiplications реализуемых алгоритмов представляет перемножение булевых матриц для всех пар нетерминалов(алгоритм 3). Все перемножения и заполнение ячеек матриц $T_A$ и $P_{BC}$ могут производиться независимо, то есть их можно выполнять параллельно без необходимости синхронизации данных.
\BlankLine

% Algorithm1
\begin{algorithm}[H]
\SetAlgoNoLine
\KwIn{Множество подматриц task}
\BlankLine
\underline{performMultiplications(task)}{:}{
 
 \For {$(m, m1, m2) \in task$}{
 \For{$(B, C) \in N \times N $}{$P^m_{BC} = P^m_{BC} \union (T^{m1}_{B} \times T^{m2}_{C})$}
 }
 \BlankLine
 }
\caption{ Функция performMultiplications после изменения представления матриц T и P}
\end{algorithm}

\BlankLine

Для параллельного перемножения матриц использовалась библиотека cuBLAS (CUDA Basic Linear Algebra Subroutine library)~\cite{cublas}, реализующая набор базовых функций линейной алгебры, эффективно использующих возможности графических процессоров (GPU). Для интеграции .NET-приложений и cuBLAS использовалась библиотека \linebreak managedCUDA~\cite{managedcuda}.

\section{Теоретическая оценка эффективности использования параллельных вычислений}

При разработке параллельных алгоритмов важным моментом является оценка эффективности использования параллельных вычислений. В данном разделе мы дадим теоретическую оценку таких характеристик, как ускорение и загруженность параллельной версии модифицированного алгоритма.

\textsc{Лемма 1.} 
\textit{Пусть длина входной строки $2^k - 1$. Тогда в Алгоритме 2 количество перемножений для подматриц размера $2^{k - i} \times 2^{k - i}$, где $i \in \{2, \ldots, k\}$, составляет $2^{2i - 1} - 2^{i}$.}

\textsc{Доказательство.}
Изменения в модификации по сравнению с исходным алгоритмов А.С.Охотина состоят в реорганизации порядка вычислений~\cite{alg}. При этом количество перемножений подматриц не меняется и составляет $2^{2i - 1} - 2^{i}$, для матриц размера $2^{k - i} \times 2^{k - i}$, где $i \in \{2, \ldots, k\}$, как уже было доказано в ~\cite{okh}. $\square$

\textsc{Теорема 1.} 
\textit{Пусть G --- контекстно-свободная грамматика в нормальной форме Хомского, n --- длина строки. Тогда  Алгоритм 2 строит таблицу разбора T для этой грамматики и этой строки за время $O(|G|\cdot BMM(n)\cdot log(n))$, где BMM(n) --- количество операций необходимых для перемножения двух булевых матриц размера n $\times$ n.}

\textsc{Доказательство.}
Так как количество операций осталось без изменений (Лемма 1), доказательство строится аналогично доказательству для алгоритма 1 в ~\cite{okh}. $\square$

Теперь рассмотрим паралельную версию алгоритма. Мы будем считать, что слой подматриц, которые необходимо перемножить, обрабатывается параллельно и затрачивает время равное умножению одной пары матриц.

\textsc{Лемма 2.} 
\textit{Пусть длина входной строки $2^k - 1$. Тогда в параллельной версии Алгоритма 2 количество перемножений для подматриц размера $2^{k - i} \times 2^{k - i}$, где $i \in \{2, \ldots, k\}$, составляет $3^{i - 1}$.}

\textsc{Доказательство.}

\textsc{База.}

При i = 2 подматрицами достигают наибольшого размера, соответственно их перемножение происходит 3 раза (вызов функции \linebreak performMultiplication строки 29, 31-32 Алгоритма 2), а все дальнейшие вызовы функции происходят для подматриц меньшего размера.

\textsc{Переход.}

Пусть мы знаем, что количество перемножений для подматриц размера $2^{k - i} \times 2^{k - i}$ составляет $3^{i - 1}$. Теперь рассмотрим матрицы размера $2^{k - (i + 1)} \times 2^{k - (i + 1)}$. Подматрицы размера $2^{k - i} \times 2^{k - i}$ разделяются на 3 непересекающихся слоя (верхняя подматрица, нижняя подматрица и правая и левая подматрицы размера $2^{k - (i + 1)} \times 2^{k - (i + 1)}$), затем в строках 19, 30  и 33 Алгоритма 2 от каждого из этих слоев вызывается функция completeLayer, в которой происходит основное перемножение матриц. Таким образом, количество перемножений для матриц размера $2^{k - (i + 1)} \times 2^{k - (i + 1)}$ составляет $3 \cdot 3^{i - 1}$ = $3^{(i + 1) - 1}$. $\square$

\textsc{Теорема 2.} 
\textit{Пусть G --- контекстно-свободная грамматика в нормальной форме Хомского, n --- длина строки. Тогда параллельная версия Алгоритма 2 строит таблицу разбора T для этой грамматики и этой строки за время $O(|G|\cdot BMM(n)$, где BMM(n) --- количество операций необходимых для перемножения двух булевых матриц размера n $\times$ n.}

\textsc{Доказательство.}

Пусть n = $2^k - 1$, а BMM(n) = $n^\omega \cdot f(n)$, где $\omega \geq 2$ и $f(n) = n^(O(1))$.

Согласно Лемме 2 количество перемножений для подматриц размера $2^{k - i} \times 2^{k - i}$, где $i \in \{2, \ldots, k\}$, составляет $3^{i - 1}$, и каждое из них еще домножается на константу C = O(|G|).

Тогда общее количество операций можно оценить следующим образом: 

$\quad \quad C \sum\limits_{i=2}^k 3^{i - 1}\cdot BMM(2^{k - i}) = C \sum\limits_{i=2}^k 3^{i - 1}\cdot 2^{\omega (k - i)}  \cdot f(2^{k - i})$ 

$\quad \quad \leq 2^{\omega k}  \cdot f(2^{k}) \sum\limits_{i=2}^k 3^{i - 1}\cdot 2^{-\omega i} = BMM(2^k) \sum\limits_{i=2}^k 3^{i - 1}\cdot 2^{-\omega i}$

Осталось оценить сумму $\sum\limits_{i=2}^k 3^{i - 1}\cdot 2^{-\omega i}$. Так как $\omega \geq 2$, то $2^{\omega} > 3$, что означает что ряд сходится. 

$\quad \quad \quad \quad \quad \sum\limits_{i=2}^k 3^{i - 1}\cdot 2^{-\omega i} \leq \sum\limits_{i=2}^{\infty} 3^{i - 1}\cdot 2^{-\omega i} = \frac{3 \cdot 2^{-\omega}} {-3 + 2^{\omega}} $

Более того, он ограничен константой, что приводит к верхней оценке работы алгоритма $O(|G|\cdot BMM(n))$. $\square$

Теперь перейдем к оценке эффективности использования параллелизма в алгоритме 2. Для оценки данной характеристики будем использовать следующие критерии:
\begin{itemize}
\item ускорение $S_p = \frac{T_0}{T_p}$ ($T_0$ --- время исполнения последовательной программы программы, $T_p$ --- время исполнения распараллеленной программы на $p$ процессорах);
\item загруженность $E_p = \frac{S_p}{p}$ (средняя доля времени выполнения алгоритма, в течение которой процессоры реально используются для решения задачи).
\end{itemize}

В данном случае количество процессоров $p$ будет составлять длину максимального массива матриц, который мы хотим обработать за один шаг, то есть $2^{k} - 2$. Для модификации алгоритма А.С.Охотина и его распараллеленной версии ускорение будет составлять $log(n)$, а загруженность --- $\frac{log(n)}{p}$. Разбиение матрицы разбора в процессе ее вычисления на обрабатывающиеся параллельно подслои, количество которых как раз равно $log(n)$, интуитивно и дает нам полученную выше оценку ускорения.

Таким образом, была дана теоретическая оценка эффективности использования параллелизма, однако простейшим примером проблемы, которая появляется при реализации, можно назвать время, затрачиваемое на отправление и получение данных с хоста при работе с GPU, из-за чего достижение высокой скорости работы алгоритма на практике оказывается не совсем простой задачей.


\section{Эксперименты}

В рамках данной работы были проведены исследования по сравнению производительности алгоритма А.С.Охотина и его модифицированной версии.

Компьютер, на котором производились замеры, обладает следующими характеристиками:
\begin{itemize}
    \item операционная система: Windows 10 Pro;
    \item процессор: Intel(R) Core(TM) i7-4790 CPU @ 3.60 GHz;
    \item объем оперативной памяти: 16.0 GB;
    \item видеокарта: NVIDIA GeForce GTX 1070, 1920 cores.
\end{itemize}


Первой грамматикой для сравнения была выбрала грамматика G1\linebreak(Листинг 1). Данная грамматика имеет прежде всего теоретический интерес, потому что, как и большинство грамматик для задач биоинформатики, является сильно неоднозначной и позволяет оценить время работы алгоритмов на простейшем примере.

\begin{listing}
\caption{Грамматика $G1$}
\begin{pyglist}[]
                   s :  s s s  |  s s  |  B 
\end{pyglist}
\end{listing} 


\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=0.6]
    
    \begin{axis}[
    xmin = -25, ymin = -5,
    xmax = 4200, ymax = 160,
    xtick={0,500,...,4200},
    width=1.1\textwidth,
    height=0.6\textwidth,
    legend cell align=center,
    legend pos = north west,
    xlabel = {Длина входа},
    ylabel = {Bpeмя, сек},
    %ymode=log
    ]
    \addplot [red, mark = triangle*,line width = 0.3mm] coordinates {
        (16,0.002) (32,0.005) (64,0.02) (128,0.13) (256,0.58) (512,1.9) (1024,9.4) (2048,35) (4096, 147)
    };
    \addplot [blue, mark=diamond*,line width = 0.3mm] coordinates {
        (16,0.002) (32,0.005) (64,0.04) (128,0.17) (256,0.55) (512,2.1) (1024,8) (2048,30) (4096, 119)
    };
    \legend{ 
        \footnotesize{Алгоритм А.С.Охотина}, 
        \footnotesize{Модифицированный алгоритм}
    };
    \end{axis}
\end{tikzpicture}
\caption{Сравнительный анализ алгоритмов для грамматики $G1$}
\end{figure}


Далее реализованные алгоритмы сравнивались на грамматике G2\linebreak(Листинг 2), с помощью которой задается вторичная структура тРНК. Размер данной грамматики значительно увеличивается во время преобразования ее в нормальную форму Хомского, из-за чего значительно увеличивается время работы алгоритмов.


\begin{listing}[h]
\caption{Грамматика $G2$}
\begin{pyglist}[]

stem<s>:             [<Start>]       
      A stem<s> U    full: folded any?
    | U stem<s> A          
    | C stem<s> G       a_5_8 : any*[5..8]
    | G stem<s> C       a_1_3 : any*[1..3]
    | G stem<s> U
    | U stem<s> G       folded: stem<(a_1_3 stem<any*[7..10]> 
    | s                               a_1_3 stem<a_5_8> 
                                      any*[3..6] 
any: A | U | G | C                    stem<a_5_8>)> 

\end{pyglist}
\end{listing}

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=0.6]
    
    \begin{axis}[
    xmin = -25, ymin = -5,
    xmax = 2200, ymax = 340,
    xtick={0,500,...,2200},
    width=1.1\textwidth,
    height=0.6\textwidth,
    legend cell align=center,
    legend pos = north west,
    xlabel = {Длина входа},
    ylabel = {Bpeмя, сек},
    %ymode=log
    ]
    \addplot [red, mark = triangle*,line width = 0.3mm] coordinates {
        (16,0.02) (32,0.05) (64,0.2) (128,1.1) (256,4.8) (512,21.5) (1024,73.9) (2048,330)
    };
    \addplot [blue, mark=diamond*,line width = 0.3mm] coordinates {
        (16,0.02) (32,0.05) (64,0.18) (128,0.94) (256,4.3) (512,19) (1024,62.8) (2048,270)
    };
    \legend{ 
        \footnotesize{Алгоритм А.С.Охотина}, 
        \footnotesize{Модифицированный алгоритм}
    };
    \end{axis}
\end{tikzpicture}
\caption{Сравнительный анализ алгоритмов для грамматики $G2$}
\end{figure}

Результаты сравнительного анализа алгоритмов для грамматик G1 и G2 представлены на рис.1 и рис.2 соответственно.

Проведенные эксперименты показали, что модифицированная версия алгоритма А.С.Охотина может проигрывать на строках небольшой длины. Однако с увеличением количества лексем во входной строке разница во времени работы реализованных алгоритмов начинает увеличиваться, модификация показывает более высокую производительность, чем исходный алгоритм А.С.Охотина.


\section{Заключение}
В ходе данной работы были получены следующие результаты: 

\begin{itemize}
\item реализованы алгоритм А.С.Охотина и его модифицированная версия на языке программирования \texttt{F\#} с использованием библиотеки для параллельных вычислений cuBLAS в рамках исследовательского проекта YaccConstructor;
\item получена теоретическая оценка эффективности использования параллельных вычислений в модифицированном алгоритме: ускорение параллельной версии в сравнении с последовательной составляет $log(n)$, а загруженность --- $\frac{log(n)}{2^k - 2}$;
\item проведен сравнительный анализ алгоритма А.С.Охотина и модифицированной версии, который показал что модификация показывает лучшие результаты на строках большой длины.
\end{itemize}

Исходный код данной работы можно найти в репозитории проекта YaccConstructor (https://github.com/YaccConstructor/YaccConstructor).

\subsubsection*{Дальнейшее направление работ}

В дальнейшем необходимо добиться снижения времени работы алгоритмов путем применения более эффективных структур данных, например разреженных матриц. Также можно исследовать возможность применения парадигмы "разделяй и властвуй" для модифицированного алгоритма, как это сделано в работах ~\cite{divide} и ~\cite{tobias}.



\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
