%compile with xelatex --shell-escape ContextFreeConstrainedPathFindingInGraph.tex

% v2-acmtog-sample.tex, dated March 7 2012
% This is a sample file for ACM Transactions on Graphics
%
% Compilation using 'acmtog.cls' - version 1.2 (March 2012), Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - March 2012
\documentclass{sig-alternate} % V1.2

%\acmVolume{VV}
%\acmNumber{N}
%\acmYear{YYYY}
%\acmMonth{Month}
%\acmArticleNum{XXX}
%\acmdoi{10.1145/XXXXXXX.YYYYYYY}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{gnuplottex}
\usepackage{tikz}
%\usepackage[T2A]{fontenc} 
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{textcomp}

\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{algorithmicx}


\begin{document}

\newtheorem{mytheorem}{Theorem}
\newtheorem{lemma}{Lemma}

\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}

\algtext*{EndSwitch}
\algtext*{EndCase}
\algtext*{EndWhile}% Remove "end while" text
\algtext*{EndIf}% Remove "end if" text
\algtext*{EndFor}% Remove "end for" text
\algtext*{EndFunction}% Remove "end function" text


\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\title{Generalized LL parsing for context-free constrained path search problem}

\sloppy

\numberofauthors{2}

\author{
\alignauthor
       Semyon Grigorev\\
       \affaddr{Saint Petersburg State University}\\
       \affaddr{7/9 Universitetskaya nab.}\\
       \affaddr{St. Petersburg, 199034 Russia}\\
       \email{semen.grigorev@jetbrains.com}
\alignauthor
       Anastasiya Ragozina\\
       \affaddr{Saint Petersburg State University}\\
       \affaddr{7/9 Universitetskaya nab.}\\
       \affaddr{St. Petersburg, 199034 Russia}\\
       \email{ragozina.anastasiya@gmail.com}
}

\maketitle

\begin{abstract}
Graph data model and graph data bases are very popular in many 
different areas such as bioinformatics, semantic web, social networks etc. 
One of specific problem on graph DB is a path querying with constrains 
formulated in terms of formal grammars. There is number of solutions, but
building structural representation of query result which practical for 
answer understanding and exploration is still a problem. 
%At the same time it is important to adopt advanced parsing algorithm to give 
In this paper we propose graph parsing technique which allows to build such representation with respect to given grammar query for arbitrary context-free grammar and graph.
Proposed algorithm is based on generalized top-down parsing algorithm which have cubic worst-case time complexity and linear for LL grammars.

\end{abstract}

\section{Introduction}
Graph data model and graph data bases are very popular in many different areas such as bioinformatics, semantic web, social networks etc.
Extraction of paths satisfying specific constraints may be useful for graph structured data investigation and for relations between data items detection.
One of specific problem is a path querying with constrains formulated in terms of formal grammars: formal language constrained path problem~\cite{FLCpathProblem}.

%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%Information from different areas such as bioinformatic, semantic web, social networks can be represented in graph model. 
%Moreover, there are data graph data bases. (?) One of the common graph problem is paths extraction from graph. 
%Paths must satisfy specific constrains and the search must use a reasonable time. (?)     
%!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Classical parsing techniques can be used to solve formal language constrained path problem. 
It means that such technique can be used on more common problem --- ``graph parsing''. 
Graph parsing may be required in graph data base querying, formal verification, string-embedded language processing and another areas where graph structured data. 


The most existing solutions in DB area use such parsing algorithms as CYK or Earley(for example~\cite{ConjCFPathQuery}, ~\cite{GraphQueryWithEarley}). These algorithms have nonlinear time complexity ($O(n^3)$ and $O(n^2)$ respectively), but there are exist such parsing algorithms as GLR and GLL, witch have cubic worst-case complexity and linear for unambiguous grammars.  
Complexity is $O(n^3)$ in worst case and linear for unambiguous grammars, that better than complexity of CYK and Earley which used as base in other solutions (for example~\cite{ConjCFPathQuery}, ~\cite{GraphQueryWithEarley})that better than complexity of CYK and Earley.
This fact allows to demonstrate better performance in some cases, on linear subgraphs and unambiguous grammars, for example. 
Also it is not necessary to transform input grammar to CNF which required for CYK which allows to avoid grammar size increasing.
It is important because real performance of parsing algorithm is sensitive to grammar size.

Despite the fact that there is a set of path querying solutions~\cite{GraphQueryWithEarley, ConjCFPathQuery, !!!}, query result exploration is still a challenge~\cite{hofman2015separabilityForRegQueryDebugging}. 
Simplification of complex query debugging is also a problem.
To solve these problems structural representation of query result can be useful, and classical parsing techniques allow to construct such representation: derivation tree contains full information about parsed sentence structure in terms of specified grammar.

Graph parsing can be also used in dynamically generated strings or string-embedded languages processing. 
Regular approximation for value set of string variable can be represented as graph of related finite automata.
As a next step, for example, in order to check correctness of dynamically generated strings we should to check that all generated strings (all paths from start states to final states) are correct with respect to some context-free grammar.
For example grammar of one of SQL dialects can be used for processing string-embedded SQL.
There are some solutions addressed this problem: GLR-based checker of string-embedded SQL queries~\cite{Alvor1, Alvor2};
relaxed parser of string-embedded languages~\cite{relaxedRNGLR} based on RNGLR parsing algorithm. The latest one allows to construct derivation forest for all correct path in input automata.

In this paper we propose graph parsing technique which allows to construct structural representation of query result with respect to given grammar query.
This structure can be useful for query debugging and exploration, or for other purposes. 
Proposed algorithm is based on generalized top-down parsing algorithm --- GLL~\cite{GLL} --- which have cubic worst-case time complexity and linear for LL grammars.  

\input{Preliminaries.tex}
\input{MotivExample.tex}
\input{Gll.tex}
\input{Complexity.tex}
\input{Example.tex}
\input{Evaluation.tex}
\input{Conclusion.tex}

\bibliographystyle{abbrv}
\bibliography{ContextFreeConstrainedPathFindingInGraph}

\input{appendix}

\end{document}
