%compile with xelatex --shell-escape ContextFreeConstrainedPathFindingInGraph.tex

%я все еще не пон€ла пример. 

%” теб€ где-то сказано, что SPPF содержит все решени€, но нигде не приведена аргументаци€. 

%Ѕыло бы неплохо написать мотивацию выбора именно тех бенчмарков, на которых ты графики рисуешь. 

% ажетс€, можно уменьшить распинательства про то, как узлы в дереве отрисовываютс€ -- жалко полстраницы на это. 

%ћне в принципе нравитс€ структура: все достаточно последовательно. 

%“ы упоминаешь formal languages constraint path problem, но не говоришь, что это за проблема. 

%Ћучше не называть константу, завис€щую от грамматики L. L это €зык обычно, а €зыки бывают бесконечными, а это не позвол€ет вз€ть и выкинуть из оценки множитель. 



% v2-acmtog-sample.tex, dated March 7 2012
% This is a sample file for ACM Transactions on Graphics
%
% Compilation using 'acmtog.cls' - version 1.2 (March 2012), Aptara Inc.
% (c) 2010 Association for Computing Machinery (ACM)
%
% Questions/Suggestions/Feedback should be addressed to => "acmtexsupport@aptaracorp.com".
% Users can also go through the FAQs available on the journal's submission webpage.
%
% Steps to compile: latex, bibtex, latex latex
%
% For tracking purposes => this is v1.2 - March 2012
\documentclass{sig-alternate} % V1.2

%\acmVolume{VV}
%\acmNumber{N}
%\acmYear{YYYY}
%\acmMonth{Month}
%\acmArticleNum{XXX}
%\acmdoi{10.1145/XXXXXXX.YYYYYYY}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{gnuplottex}
\usepackage{tikz}
%\usepackage[T2A]{fontenc} 
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{textcomp}

\begin{document}

\newtheorem{mytheorem}{Theorem}
\newtheorem{lemma}{Lemma}

\makeatletter
\def\@copyrightspace{\relax}
\makeatother

\title{Generalized LL parsing for context-free constrained path search problem}

\sloppy

\numberofauthors{2}

\author{
\alignauthor
       Semyon Grigorev\\
       \affaddr{Saint Petersburg State University}\\
       \affaddr{7/9 Universitetskaya nab.}\\
       \affaddr{St. Petersburg, 199034 Russia}\\
       \email{semen.grigorev@jetbrains.com}
\alignauthor
       Anastasiya Ragozina\\
       \affaddr{Saint Petersburg State University}\\
       \affaddr{7/9 Universitetskaya nab.}\\
       \affaddr{St. Petersburg, 199034 Russia}\\
       \email{ragozina.anastasiya@gmail.com}
}

\maketitle

\begin{abstract}
Aaaabstract is very abstract.... 
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10
word1 word2 word3 word4 word5 word6 word7 word8 word9 word10

\end{abstract}

\section{Introduction}
Graph data model and graph data bases are very popular in many different areas such as bioinformatic, semantic web, social networks etc.
Extraction of paths satisfying specific constraints may be useful for graph structured data investigation and for relations between data items detection.
Path querying with constrains formulated in terms of formal grammars is a specific problem named formal language constrained path problem~\cite{FLCpathProblem} and research in this area is still actual~\cite{DirOfBigGraphAnalysis}.

Classical parsing techniques can be used to solve formal language constrained path problem thus we can use ``graph parsing'' and it may be required not only in graph data base quering but also in other 
different areas: formal verification, and string-embedded language processing, for example. 

Classical solution in DB area use such parsing algorithms as CYK or Earley.
In string-embedded languages analysis (RN)GLR is used.
It has better time complexity.

Graph parsing can be also used in string-embedde languages prcessing. 
Regular approximation for value set of string variable can by represened as directed graph of related fite automata.
In orded to check corectness or safety (sql injections)... all generated strings (all paths from start states to final states) are correct w.r.t some context-free grammar.
For example grammar of one of SQL dialects.
GLR-based for string-embedded SQL checking~\cite{Alvor1, Alvor2}.
Solution based on RNGLR~\cite{rnglr} for relaxed parsing of string-embedded languages~\cite{relaxedRNGLR} which allow to find all path between two specified vertices.



despite of the fact There is set of solutions in DB area but !!! Query result exploration is a challenge~\cite{hofman2015separabilityForRegQueryDebugging}. 
Classical parsing allow to construct derivation tree which is structural representation of parsed sentence.
Structural represenatation of query result can be useful for its exploration and qury debugging.
In this paper, we propose graph parsing technique which allow to construct structural representation of query result with reletion to grammar query or derivation of result.


So, we propose algorithm based top-down parsing algorithm. LL is more natural and so on.




\section{Preliminaries}

In this work we are focused on parsing algorithm, and not on the data representation, and de assume that full input graph can be located in RAM memory by the optimal for our algorithm way.

Also we need to introduce some definitions.
\begin{itemize}
  \item Context-free grammar $G=(N, \Sigma, P, S)$ where $N$ is a set of nonterminal symbols, $\Sigma$ is a set of terminal symbols, $S \in N$ is a start nonterminal, and $P$ is a productions set. 
  \item $\mathcal{L}(G)$ is a language specified by grammar $G$.
  \item Directed graph $M = (V,E,L)$ where $V$ --- vertices set, $L \subseteq \Sigma$ --- edge labels set, $E\subseteq V\times L\times V$. 
  We assume that there are no parallel edges with equal labebs: for every $e_1=(v_1,l_1,v_2) \in E, e_2=(u_1,l_2,u_2) \in E$ if $v_1 = u_1$ and $v_2 = u_2$ then $l_1 \neq l_2$.
  \item Helper function for edge's tag calculation $tag: E \rightarrow L$. $$tag(e = (v_1,l,v_2), e \in E) = l$$
  \item Concatenation operation $\oplus: L^+ \times L^+ \rightarrow L^+$.
  \item Path $p$ in graph $M$. 
  \begin{align*}
   p &= (v_0,l_0,v_1),(v_1,l_1,v_2),\dots,(v_{n-1},l_{n-1},v_n) \\
     &= e_0,e_1,\dots,e_{n-1}
  \end{align*}
  where $v_i \in V$,$e_i \in E$, $l_i \in L$, $|p| = n, n \geq 1$. 
  \item Set of paths $P = \{p: p \text{ path in } M\}$
  \item Helper function for string produced by path calculation $\Omega: P \rightarrow L^+$. 
  \begin{align*}
  & \Omega(p = e_{0},e_{1},\dots,e_{n-1}, p \in P) = \\
  & tag (e_{0}) \oplus \dots \oplus tag (e_{n-1})
  \end{align*}
\end{itemize}

As a result we can define that context-free language constrained path querying meens that we get query as grammar $G$ and result of this query is a set of paths $$P=\{p|\Omega(p) \in \mathcal{L}(G)\}.$$

For some graphs and some queries $P$ can be infinite set, and it can not be explicitly represented. 
In order to solve this problem, in this paper, we will construct not explicit representation of $P$ but compact data structure which store all elements of $P$ in finite space and allow to extract any of them.
In this point our solution is slightly similar to subgraph quering proposed in article~\cite{GraphQueryWithEarley}, but we are also construct derivetion forest for result subgraph.

\section{Example}
As a motivation of context-free constraints importance let we introduce the next example.
Let we have graph $M=(\{0;1;2;3\},E,\{A;B\})$ presented in figure~\ref{input} where labels represent next relations:
\begin{itemize}
    \item $A$ --- ``is friend of'' ($v_0 A v_1$ meens $v_0$ is friend of $v_1$);
    \item $B$ --- ``has friend'' ($v_0 B v_1$ meens $v_0$ has friend $v_1$).
\end{itemize} 

Suppose for each $n \geq 1$ we want to find all $n$-th generation friends with a common ancestor.
In the other worlds, we wath to find all paths $p$, such that $\Omega(p) \in \{AB; AABB; AAABBB; \dots\}$ or $\Omega(p) = A^n B^n$ where $n \geq 1$.
This constraint can not be specified with regular language as far as $L=\{A^n B^n; n \geq 1\}$ is not regular but context free.
Required language can be specified by grammar $G_1$ presented in picture~\ref{grammarG} where $N = \{s; middle\}$, $\Sigma = \{A; B\}$, and $S = s$.

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=6cm]{dot/input.pdf}
        \caption{Input graph $M$}
        \label{input}        
    \end{center}
\end{figure}

\begin{figure}[h]
   \begin{center}
\begin{verbatim}
   0: s = L s R 
   1: s = middle
   2: middle = L R
\end{verbatim}
   \caption{Grammar $G_1$ for language $L=\{L^n R^n; n \geq 1\}$}
   \label{grammarG}        
   \end{center}
\end{figure}


Result is infinite for this query, and we can not... 
Also we want to know, who is common accesor.
Futher we show ho to solve it.


\section{Algorithm for graph parsing}
We propose a context-free language constrained path problem solution which allow to find all paths satisfied specified arbitrary context-free grammar and to construct implicit representation of result. 
Finite representation of result set with structure related to specified grammar may be useful not only for results understanding and processing but also for query debugging especially for complex queries. 

Our solution is based on generalized LL (GLL)~\cite{scott2010gll, FastPracticalGLL} parsing algorithm which allow to process ambiguous context-free grammars.
Complexity is $O(n^3)$ in worst case and linear for unambiguous grammars, that better then complexity of CYK and Earley which used as base in other solutions (for example~\cite{ConjCFPathQuery}, ~\cite{GraphQueryWithEarley}).
This fact allow to demonstarte better performance on linear subgraphs and unambiguous grammars.
Also it is not necessary to transform input grammar to CNF which required for CYK which allow to avoid grmmar size decreasing.
It is important because real performance of parsing algorithm is sensetive to grammar size.


\subsection{Generalized LL Parsing Algorithm}

Generalized LL (GLL) is generalized top-down parsing algorithm which handle all context-free grammars (including left recursive) with worst-case cubic time complexity and linear for LL grammars.
GLL is native for grammar, can be simple created blah-blah-blah.

GLL use descriptors for parsing states specification.
Each descriptor contains full specification of process state anought to start parsing from state stored.

Descriptor is a triple $(L, s, j)$ where $L$ is a line label, $s$ is a stack and $j$ is a position in the input.

allows to restore parsing

Graph structured stack (GSS)~\cite{Tomita} for multiple stack combining to prevent duplication.
In GLL each GSS node is pair of position in input and grammmar slot. Grammar slot is a !!! 

\subsection{Shared packed parse forest}

Shared Packed Parse Forest (SPPF) is a spetial data structure for derivation forest compact representation which allow to reuse common nodes and subtrees.
As a result multiple derivation trees, which csn be produced in case of ambiguos grammar, can be compressed in one SPPF with optimal reusing of common parts.  
Binarized form of SPPF proposed in~\cite{brnglr} and it allow to achive worst-case cubic space complexity.
GLL can use SPPF~\cite{gllParsingTree} for results representation achive cubic space complexity with binarised version.

Let we present an example of SPPF for ambiguos grammar $G_0$ (pic~\ref{grammarG0}).

\begin{figure}[h]
   \begin{center}
\begin{verbatim}
   0: s = NUM
   1: s = LBR s RBR
   2: s = s s
\end{verbatim}
   \caption{Grammar $G_0$}
   \label{grammarG0}        
   \end{center}
\end{figure}

Here \verb|N| is token for number, \verb|L| and \verb|R| are tokens for '(' and ')'  respectively.

Let we parse the sentence \verb|(1)(2)(3)|. 
There are two diferent lefmost derivations of this sentence in grammar $G_0$ ($\rightarrow ^ n$ denote an application of production with nimber $n$): 
\begin{enumerate} 
    \item $s \rightarrow ^ 2 s s \rightarrow ^ 2 s s s \rightarrow ^ 1 L s R s s \rightarrow ^ 0 L N R s s \rightarrow ^ 1 
    L N R L s R s \rightarrow ^ 1 L N R L s R s \rightarrow ^ 0 L N R L N R s \rightarrow ^ 1 L N R L N R L s R \rightarrow ^ 0 L N R L N R L N R$
    \item $s \rightarrow ^ 2 s s \rightarrow ^ 1 L s R s  \rightarrow ^ 0 L N R s \rightarrow ^ 2 L N R s s  \rightarrow ^ 1 
    L N R L s R s \rightarrow ^ 1 L N R L s R s \rightarrow ^ 0 L N R L N R s \rightarrow ^ 1 L N R L N R L s R \rightarrow ^ 0 L N R L N R L N R$
\end{enumerate}
    As far as there are tho different derivations, SPPF should contains 2 different trees and it is presented in figure~\ref{sppfSample}: result SPPF~\ref{sppf} and trees for derivation 1~\ref{tree1} and derivation 2~\ref{tree1} respectively. 


\begin{figure*}[ht]
    \begin{center}
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{dot/Brackets.pdf}
        \caption{SPPF}
        \label{sppf}        
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{dot/Brackets.pdf}
        \caption{Tree for derivation 1}
        \label{tree1}        
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{dot/Brackets.pdf}
        \caption{Tree for derivation 2}
        \label{tree2}        
    \end{subfigure}
    \caption{SPPF for sentence \textbf{\texttt{(1)(2)(3)}} and grammar $G_0$}
    \label{sppfSample}
    \end{center}                
\end{figure*}

Binarised SPPF is a graph where !!! and each node has one of four types and one node marked as 'root' --- node for start nonterminal.

\begin{itemize}
    \item terminal node
    \item nonterminal node
    \item intermidiate node
    \item packed node
\end{itemize}

Further we will remove redudant intermidiate and packed nodes from SPPF to simplify it and decrease size of structure.


\subsection{GLL-based graph parsing}

$\mathbb{P}:G,M \rightarrow SPPF$

In order to use GLL for graph parsing we need only use graph verticea as position in input.
As far as we work with context-free languages it is not important how this descriptor was created, and so descriptors management and other basic mechanisms of original algorithm can be reused ``as is''. 
We can merge it if thea are equal. 



We implement some optimizations:~\cite{FastPracticalGLL}

We also use binarised SPPF for result representation whish allow to simplify query debugging and result explortion.
In our case more then one root may be specified. For example, look at picture!!!! 
We 

Binarized SPPF is at most cubic in terms of result size. Any path can be extracted in the linear time.

\subsection{Complexity}

Time complexity estimation in terms of input graph and grammar size is pretty similar to estimation of GLL complexity provided in~\cite{gllParsingTree}.

\begin{lemma}\label{lem:Descriptors}
For any descriptor $(L,u,i,w)$ either $w = \$$ or $w$ has extension $(j,i)$ where u has index $j$.
\end{lemma}
\begin{proof}
Proof of this lemma is the same as provided for riginal GLL in~\cite{gllParsingTree} because main function used for descriptor creation are the same as original one.
\end{proof}


\begin{mytheorem}\label{thm:GSSSpace}
The GSS generated by GLL-based graph parsing algorithm for grammar $G$ on input graph $M=(V,E,L)$ has at most $O(|V|)$ vertices and $O(|V|^2)$ edges.
\end{mytheorem}

\begin{proof}

Proof the same as the proof of \textbf{Theorem 2} from~\cite{gllParsingTree}. 

\end{proof}

\begin{mytheorem}\label{thm:SPPFSpace}
The SPPF generated by GLL-based graph parsing algorithm on input graph $M=(V,E,L)$ has at most $O(|V|^3 + |E|)$ vertices and edges.
\end{mytheorem}

\begin{proof}
Let we estimate number of nodes of each type.
\begin{itemize}
\item Terminal nodes. 
Each of them has label of form $(T, v_0, v_1)$, and such lable can be created only if there is such $e \in E$ that $e=(v_0,T,v_1)$. 
Note, that there are no duplicate edges. 
Hence tere are at most $|E|$ terminal nodes.
\item $\varepsilon$ nodes labled with $(\varepsilon, v ,v)$, hence there are at most $|E|$ of these. 
\item Nonterminal nodes have label of form $(N,v_0,v_1)$, so there are at most $O(|V|^2)$ of these.
\item Intermideate nodes have label of form $(t,v_0,v_1)$, where $t$ is grammar slot, so there are at most $O(|V|^2)$ of these.
\item Packed nodes are children of intermediate or nonterminal nodes and have label of form $(t,v)$ where $t$ is a grammar slot $N : \alpha \cdot \beta$.
There are at most $O(|V|^2)$ parents for packed nodes and each of them can have at most $O(|V|)$ children.
\end{itemize}

As a result there are at most $O(|V|^3 + |E|)$ nodes in SPPF.

The packed nodes have at most two children so there are at most $O(|V|^3 + |E|)$ edges with source in packed node. 
Nonterminal and intermediate nodes have at most $O(|V|)$ children and all of them are packed nodes.
Thus there are at most $O(|V|^3)$ edges with source in nonterminal or intermediate nodes. As a result there are at most $O(|V|^3 + |E|)$ edges in SPPF.


\end{proof}

\begin{mytheorem}
The space complexity of GLL-based graph parsing algorithm for graph $M=(V,E,L)$ is at most $O(|V|^3 + |E|)$.
\end{mytheorem}

\begin{proof}

From theorems~\ref{thm:GSSSpace} and~\ref{thm:SPPFSpace} we have that space requerd for main data structures is at most $O(|V|^3 + |E|)$. 

\end{proof}


\begin{mytheorem}\label{thm:complexity}
The runtime complexity of GLL-based graph parsing algorithm for graph $M=(V,E,L)$ is at most $$O\left(|V|^3*\max\limits_{v \in V}\left(deg^+\left(v\right)\right)\right).$$
\end{mytheorem}

\begin{proof}

From Lemma~\ref{lem:Descriptors} we get that there are at most $O(|V|^2)$ descriptors. 
Complexity of all functions are the same as in proof of \textbf{Theorem 4} from~\cite{gllParsingTree} except \textit{processing} function where we should process not one next input token, but all outgoing edges.
Thus for each descriptor we should examine at most $$\max\limits_{v \in V}\left(deg^+\left(v\right)\right)$$ edges where $deg^+(v)$ is outdegree of vertex $v$.

So, worst-case complexity of proposed algorithm is $$O\left(V^3*\max\limits_{v \in V}\left(deg^+\left(v\right)\right)\right).$$
\end{proof}

%Also we can get averege-case complexity by calculate averege outdegree:
%\begin{align} \label{eq:avg}
%  & O\left(|V|^3*\frac {\sum\limits_{v \in V} deg^+(v)}{|V|}\right) = \nonumber \\
%  & O\left(|V|^2*\sum\limits_{v \in V} deg^+(v)\right) = \nonumber \\
%  & O\left(|V|^2*|E|\right) 
%\end{align}

From theorem~(\ref{thm:complexity}) we can get estimations for linear input and for LL grammars: $\text{for any } v \in V deg^+(v) \leq 1$, so $\max\limits_{v \in V}(deg^+(v))  = 1 $ and we get $O(|V|^3)$. 
For LL grammars and linear input complexity should be $O(|V|)$ for the same reason as for original GLL.
 

As discussed in~\cite{modellingGLL} achiving of theoretical complexity reqired special datastructures which can be irrational for practice implementation and it is necessary to finde balance between performance, software complexity, and hardware resources.
As a result in practice we can get slightly worse performance than theoretical estimation.

Note that result SPPF contains only paths matched specified query, so result SPPF size is $O(|V'|^3 + |E'|)$ where $M'=(V',E',L')$ is a subgraph of input graph $M$ which contains only matched paths.
Also npte that each specific path can be explored with linear SPPF traversal. 

\subsection{Example}
In details, main function input is graph $M$, set of start vertices $V_s\subseteq V$, set of final vertices $V_f\subseteq V$, grammar $G_1$.
Output is Shared Packed Parse Forest (SPPF)~\cite{SPPF} --- finite data structure which contains all derivation trees for all paths in $M$, $\Omega(p) \in L(G_1)$ and allows to reconstruct any of paths implicitly.
As far as we can specify sets of start and final vertices, our solution can find all paths in graph, all paths from specified vertex, all paths between specified vertices. 
Also SPPF represents a structure of paths in terms of derivation which allow to get more useful information about result.

Let we introduce the next example. Grammar $G_1$ is a query and we want to find all paths in graph $M$ (presented in picture~\ref{input}) matched this query.
Result SPPF for this input is presented in picture~\ref{SPPF}. Note that presented version does not contein obsolete nodes.

\begin{figure}[h]
    \begin{center}
        \includegraphics[width=8cm]{dot/AnBn.pdf}
        \caption{Result SPPF for input graph $M$(pic.~\ref{input}) and query $G_1$(pic.~\ref{grammarG})}
        \label{SPPF}        
    \end{center}
\end{figure}

We use next markers for nodes which similar to original SPPF but have some additional information in order to relation with graph.
\begin{itemize}
    \item Node with rectangle shape labeled with $(v_0, T, v_1)$ is terminal node. 
    Each terminal node corresponds with edge in the input graph: for each node with label $(v_0, T, v_1)$ there is $e\in E: e=(v_0,T,v_1)$.
    Duplication of terminal nodes is only for figure simplification.
    \item Node with oval shape labeled with $(v_0, nt, v_1)$ is nonterminal node. 
    This node denote that there is at least one path $p$ from vertex $v_0$ to vertex $v_1$ in input graph $M$ such that $nt \Rightarrow^*_G \Omega(p)$.
    All paths matched this condition can be extracted from SPPF by left-to-right top-down graph traversal started from respective node. 
    \item Filled node with oval shape labeled with $(<\mkern-11mu | \mkern-11mu> (v_0, nt, v_1))$ is nonterminal node denote that there are more then one path $p$ from $v_0$ to $v_1$ such that $nt \Rightarrow^*_G \Omega(p)$.
    \item Node with dot shape is used for representation of derivation variants.
    Subgraph with root in one such node is one variant of derivation.
    Parent of such nodes is always node with label $(<\mkern-9mu | \mkern-9mu> (v_0, nt, v_1))$.
    \item $v_0$ and $v_1$ are left and right extensions of node respectively.
\end{itemize}

As an example of derivation structure usage we can find 'middle' of any path in example above simply by finding corresponded nonterminal $middle$ in SPPF.
So we can found that there is only one common ancestor for all results and it is vertex with $id = 0$. 

Extensions stored in nodes allow to check whether path from $u$ to $v$ exists and extract it. 
To extract specified path we need only travers SPPF which can be done in linear time. 
Let for example we want to find path satisfying specified constraints from vertex $0$.
To do this we should find vertices with label $(0, s, \_)$ in SPPF.
There are two vertices with requred label: $(0, s, 0)$ and $(0, s , 3)$.
In our example there is cycle in SPPF so there are \textbf{at least} two different paths: $$p_0=\{(0,A,1);(1,A,2);(2,A,0);(0,B,3);(3,B,0);(0,B,3)\}$$ and 
\begin{align*}
p_1=\{&(0,A,1);(1,A,2);(2,A,0);(0,A,1);(1,A,2);(2,A,0);\\ &(0,B,3);(3,B,0);(0,B,3);(3,B,0);(0,B,3);(3,B,0)\}.
\end{align*}

\section{Evaluation}

We use two grammars for balanced brakets in order to investigate performance relations with grammar ambiguity: ambiguos grammar $G_0$~\ref{grammarG0} and unambiguos grammar $G_2$~\ref{grammarG2}.

\begin{figure}[ht]
   \begin{center}
\begin{verbatim}
   0: s = L s R s 
   1: s = eps
\end{verbatim}
   \caption{Unambiguos grammar $G_2$ for balanced brackets}
   \label{grammarG2}        
   \end{center}
\end{figure}

For input we use complete graphs where for each termial symbol there is edge between two vertices labeled with it.
Task we solve in performed experiments is find all paths from all vertices to all vertixes satisfied specified query. 

All tests were performed on a PC with following characteristics:
\begin{itemize}
\item OS Name: Microsoft Windows 10 Pro
\item System Type: x64-based PC
\item CPU: Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz, 3601 Mhz, 4 Core(s), 4 Logical Processor(s)
\item RAM: 32 GB
\end{itemize}

Performance mesurament results presented in figure~\ref{pic:Perf}. 
As far as for complete graph $M=(V,E,L)$ $$\max\limits_{v \in V}\left(deg^+\left(v\right)\right) = (|V| - 1)*|\Sigma|$$ where $\Sigma$ is terminals of input grammar, we should get time complexity at most $O(|V|^4)$ and space complexity at most $O(|V|^3)$.
All two curves can be fit with polinomial function of degree 4 to a high level of confidence with $R^2$. 


%g(x) = m*x**3 + n*x**2 + o*x + p
%fit g(x) 'perf/2' using 1:4 via n,m,o,p

\begin{figure}[ht]
\centering
\begin{gnuplot}
set terminal epslatex color size 9cm,8cm
set yrange [0:]
set key box top left
set key width 2
set key opaque
set sample 1000
set xlabel 'Number of vertices in input graph'
set ylabel 'Time in milliseconds'
e = 0
f(x) = a*x**4 + b*x**3 + c*x**2 + d*x + e
fit f(x) 'perf/2' using 1:4 via a,b,c,d
f1(x) = 0.000495989*x**4 + 0.001252184*x**3 + 0.068491746*x**2 - 0.306749160*x
f2(x) = 0.003368883*x**4 - 0.114919298*x**3 + 3.161793404*x**2 - 22.549491142*x

plot 'perf/2' using 1:3  pt 6 title '$G_0$',\
     'perf/2' using 1:4  pt 5 title '$G_2$',\
     f1(x)  with line lt -1 title '$f_1$',\
     f2(x)  lc rgb "black" dashtype 2 title '$f_2$'     

 \end{gnuplot}
\caption{Performance on complete graphs for grmmars $G_0$ and $G_2$ \\ 
$f_1(x) = 0.000495989*x^4 + 0.001252184*x^3 + 0.068491746*x^2 - 0.306749160*x$; $R^2 = 0.99996$ \\
$f_2(x) = 0.003368883*x^4 - 0.114919298*x^3 + 3.161793404*x^2 - 22.549491142*x$; $R^2 = 0.99995$}
\label{pic:Perf}
\end{figure}

Also we present SPPF size in terms of nodes for both $G_0$ and $G_2$ grammars~\ref{pic:SPPFSize}. All two curves are cubic to a high level of confidence with $R^2 = 1$. 

\begin{figure}[ht]
\centering
\begin{gnuplot}
set terminal epslatex color size 9cm,8cm
set key box top left
set key width 2
set key opaque
set sample 1000
set xlabel 'Number of vertices in input graph'
set ylabel 'Number of SPPF nodes'

f1(x) = 3.000047*x**3 + 3.994579*x**2 + 4.191568*x
f2(x) = 3.000050*x**3 + 2.994338*x**2 + 4.196472*x


plot 'perf/2' using 1:6 pt 6 title '$G_2$',\
     'perf/2' using 1:7 pt 5 title '$G_0$',\
     f1(x)  with line lt -1 title '$f_1$',\
     f2(x)  lc rgb "black" dashtype 2 title '$f_2$'     

 \end{gnuplot}
\caption{SPPF size on complete graph for grmmars $G_0$ and $G_2$ an complete graphs \\
$f_1(x) = 3.000047*x^3 + 3.994579*x^2 + 4.191568*x$; $R^2 = 1$\\
$f_2(x) = 3.000050*x^3 + 2.994338*x^2 + 4.196472*x$; $R^2 = 1$}
\label{pic:SPPFSize}
\end{figure}


%\begin{figure}[h]
%\centering
%\begin{gnuplot}
%set terminal epslatex color size 9cm,8cm
%set key box top left
%set logscale y
%set key width 2
%set key opaque
%set sample 1000
%set xlabel '$x$-label'
%set ylabel '$y$-label
%plot 'perf/3' using 1:2 with lines ls 2 ti '$Unamb$',\
%     'perf/3' using 1:3 with lines ls 3 ti '$amb$'
%
% \end{gnuplot}
%\caption{Performance on C graph for grmmars $G_0$ and $G_2$}
%\label{pic:DoubleCyclesPerf}
%\end{figure}




%To summarise we can say that performance for unambiguos grammars is better then for ambiguos. 

%Full graphs for balanced brackets.

%Full graph for highly unambiguos greammar $G_3$ (figure~\ref{grammarG3}).

%\begin{figure}[h]
%   \begin{center}
%\begin{verbatim}
%   0: s = s s s 
%   1: s = s s
%   2: s = A
%\end{verbatim}
%   \caption{Highly ambiguos grammar $G_3$}
%   \label{grammarG3}        
%   \end{center}
%\end{figure}


\section{Conclusion and future work}
We propose GLL-based algorithm for context-free path querying which construct finite structural representation of all paths satisfying given constraint.
Provided data structure can be useful for result investigation and processing, and query debugging.
Presented algorithm implemented in F\#~\cite{FSharp} and available on GitHub:\url{https://github.com/YaccConstructor/YaccConstructor}.

In order to estimate practical value of proposed algorithm we should perform evaluation on real dataset and real queries.
One of possible application of our algorithm is metagenomical assambly quering, and we are working on this topic.

Also we are working on performance improvement by implementation of recently proposed modifications in original GLL algorithm~\cite{FGLL}.
One of direction of our research is generalization of grammar factorization proposed in~\cite{FGLL} which may be useful for regular query processing.

We are working on utilisation of GPGPU and multicore CPU power for graph parsing problem with Valiant~\cite{valiantParsingWithMatrixMultiplication} algorithm modification proposed 
by Alexander Okhotin~\cite{okhotin2014parsingWithMatrixMultiplication}.
One of possible benefit is ability to process more expressive queries because modification proposed by Alexander Okhotin extended to support boolean grammars.

\bibliographystyle{abbrv}
\bibliography{ContextFreeConstrainedPathFindingInGraph}

%\bibitem{PathQuerySemantic}
%Hellings, J. (2015). Querying for Paths in Graphs using Context-Free Path Queries. arXiv preprint 
%arXiv:1502.02242.

%\bibitem{CFPathQuery}
%Sevon, P., /& Eronen, L. (2008). Subgraph queries by context-free grammars. Journal of Integrative 
%Bioinformatics, 5(2), 100.


\end{document}
